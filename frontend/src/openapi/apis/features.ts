/**
 * Generated by Orval
 * Do not edit manually.
 * See `gen:api` script in package.json
 */
import useSwr from 'swr';
import type { SWRConfiguration, Key } from 'swr';
import type {
    ChangeProjectSchema,
    FeaturesSchema,
    GetAllToggles401,
    GetAllToggles403,
    ValidateFeatureSchema,
    TagsSchema,
    ListTags401,
    ListTags403,
    ListTags404,
    TagSchema,
    UpdateTagsSchema,
    FeatureEnvironmentSchema,
    GetFeatureEnvironment401,
    GetFeatureEnvironment403,
    GetFeatureEnvironment404,
    FeatureSchema,
    BulkToggleFeaturesSchema,
    FeatureStrategySchema,
    GetFeatureStrategies401,
    GetFeatureStrategies403,
    GetFeatureStrategies404,
    CreateFeatureStrategySchema,
    GetFeatureStrategy401,
    GetFeatureStrategy403,
    GetFeatureStrategy404,
    UpdateFeatureStrategySchema,
    PatchesSchema,
    SetStrategySortOrderSchema,
    GetFeatures400,
    GetFeatures401,
    GetFeatures403,
    CreateFeatureSchema,
    CloneFeatureSchema,
    GetFeature401,
    GetFeature403,
    GetFeature404,
    UpdateFeatureSchema,
    BatchStaleSchema,
    FeatureVariantsSchema,
    GetFeatureVariants401,
    GetFeatureVariants403,
    GetFeatureVariants404,
    VariantsSchema,
    GetEnvironmentFeatureVariants401,
    GetEnvironmentFeatureVariants403,
    GetEnvironmentFeatureVariants404,
    PushVariantsSchema,
    BatchFeaturesSchema,
    ConstraintSchema,
} from '../models';
import { fetcher } from '../fetcher';
import type { ErrorType, BodyType } from '../fetcher';

/**
 * Moves the specified feature to the new project in the request schema. Requires you to have permissions to move the feature toggle in both projects. Features that are included in any active change requests can not be moved.
 * @summary Move feature to project
 */
export const changeProject = (
    projectId: string,
    featureName: string,
    changeProjectSchema: BodyType<ChangeProjectSchema>
) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/changeProject`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: changeProjectSchema,
    });
};

/**
 * Gets all feature toggles with their full configuration. This endpoint is **deprecated**. You should  use the project-based endpoint instead (`/api/admin/projects/<project-id>/features`).
 * @deprecated
 * @summary Get all feature toggles (deprecated)
 */
export const getAllToggles = () => {
    return fetcher<FeaturesSchema>({
        url: `/api/admin/features`,
        method: 'get',
    });
};

export const getGetAllTogglesKey = () => [`/api/admin/features`] as const;

export type GetAllTogglesQueryResult = NonNullable<
    Awaited<ReturnType<typeof getAllToggles>>
>;
export type GetAllTogglesQueryError = ErrorType<
    GetAllToggles401 | GetAllToggles403
>;

/**
 * @deprecated
 * @summary Get all feature toggles (deprecated)
 */
export const useGetAllToggles = <
    TError = ErrorType<GetAllToggles401 | GetAllToggles403>
>(options?: {
    swr?: SWRConfiguration<
        Awaited<ReturnType<typeof getAllToggles>>,
        TError
    > & { swrKey?: Key; enabled?: boolean };
}) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled = swrOptions?.enabled !== false;
    const swrKey =
        swrOptions?.swrKey ??
        (() => (isEnabled ? getGetAllTogglesKey() : null));
    const swrFn = () => getAllToggles();

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

/**
 * Validates a feature toggle name: checks whether the name is URL-friendly and whether a feature with the given name already exists. Returns 200 if the feature name is compliant and unused.
 * @summary Validate a feature toggle name.
 */
export const validateFeature = (
    validateFeatureSchema: BodyType<ValidateFeatureSchema>
) => {
    return fetcher<void>({
        url: `/api/admin/features/validate`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: validateFeatureSchema,
    });
};

/**
 * Retrieves all the tags for a feature name. If the feature does not exist it returns an empty list.
 * @summary Get all tags for a feature.
 */
export const listTags = (featureName: string) => {
    return fetcher<TagsSchema>({
        url: `/api/admin/features/${featureName}/tags`,
        method: 'get',
    });
};

export const getListTagsKey = (featureName: string) =>
    [`/api/admin/features/${featureName}/tags`] as const;

export type ListTagsQueryResult = NonNullable<
    Awaited<ReturnType<typeof listTags>>
>;
export type ListTagsQueryError = ErrorType<
    ListTags401 | ListTags403 | ListTags404
>;

/**
 * @summary Get all tags for a feature.
 */
export const useListTags = <
    TError = ErrorType<ListTags401 | ListTags403 | ListTags404>
>(
    featureName: string,
    options?: {
        swr?: SWRConfiguration<Awaited<ReturnType<typeof listTags>>, TError> & {
            swrKey?: Key;
            enabled?: boolean;
        };
    }
) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled = swrOptions?.enabled !== false && !!featureName;
    const swrKey =
        swrOptions?.swrKey ??
        (() => (isEnabled ? getListTagsKey(featureName) : null));
    const swrFn = () => listTags(featureName);

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

/**
 * Adds a tag to a feature if the feature and tag type exist in the system. The operation is idempotent, so adding an existing tag will result in a successful response.
 * @summary Adds a tag to a feature.
 */
export const addTag = (featureName: string, tagSchema: BodyType<TagSchema>) => {
    return fetcher<TagSchema>({
        url: `/api/admin/features/${featureName}/tags`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: tagSchema,
    });
};

/**
 * Receives a list of tags to add and a list of tags to remove that are mandatory but can be empty. All tags under addedTags are first added to the feature and then all tags under removedTags are removed from the feature.
 * @summary Updates multiple tags for a feature.
 */
export const updateTags = (
    featureName: string,
    updateTagsSchema: BodyType<UpdateTagsSchema>
) => {
    return fetcher<TagsSchema>({
        url: `/api/admin/features/${featureName}/tags`,
        method: 'put',
        headers: { 'Content-Type': 'application/json' },
        data: updateTagsSchema,
    });
};

/**
 * Removes a tag from a feature. If the feature exists but the tag does not, it returns a successful response.
 * @summary Removes a tag from a feature.
 */
export const removeTag = (featureName: string, type: string, value: string) => {
    return fetcher<void>({
        url: `/api/admin/features/${featureName}/tags/${type}/${value}`,
        method: 'delete',
    });
};

/**
 * Information about the enablement status and strategies for a feature toggle in specified environment.
 * @summary Get a feature environment
 */
export const getFeatureEnvironment = (
    projectId: string,
    featureName: string,
    environment: string
) => {
    return fetcher<FeatureEnvironmentSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}`,
        method: 'get',
    });
};

export const getGetFeatureEnvironmentKey = (
    projectId: string,
    featureName: string,
    environment: string
) =>
    [
        `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}`,
    ] as const;

export type GetFeatureEnvironmentQueryResult = NonNullable<
    Awaited<ReturnType<typeof getFeatureEnvironment>>
>;
export type GetFeatureEnvironmentQueryError = ErrorType<
    | GetFeatureEnvironment401
    | GetFeatureEnvironment403
    | GetFeatureEnvironment404
>;

/**
 * @summary Get a feature environment
 */
export const useGetFeatureEnvironment = <
    TError = ErrorType<
        | GetFeatureEnvironment401
        | GetFeatureEnvironment403
        | GetFeatureEnvironment404
    >
>(
    projectId: string,
    featureName: string,
    environment: string,
    options?: {
        swr?: SWRConfiguration<
            Awaited<ReturnType<typeof getFeatureEnvironment>>,
            TError
        > & { swrKey?: Key; enabled?: boolean };
    }
) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled =
        swrOptions?.enabled !== false &&
        !!(projectId && featureName && environment);
    const swrKey =
        swrOptions?.swrKey ??
        (() =>
            isEnabled
                ? getGetFeatureEnvironmentKey(
                      projectId,
                      featureName,
                      environment
                  )
                : null);
    const swrFn = () =>
        getFeatureEnvironment(projectId, featureName, environment);

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

/**
 * Disable a feature toggle in the specified environment.
 * @summary Disable a feature toggle
 */
export const toggleFeatureEnvironmentOff = (
    projectId: string,
    featureName: string,
    environment: string
) => {
    return fetcher<FeatureSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/off`,
        method: 'post',
    });
};

/**
 * Enable a feature toggle in the specified environment.
 * @summary Enable a feature toggle
 */
export const toggleFeatureEnvironmentOn = (
    projectId: string,
    featureName: string,
    environment: string
) => {
    return fetcher<FeatureSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/on`,
        method: 'post',
    });
};

/**
 * This endpoint enables multiple feature toggles.
 * @summary Bulk enable a list of features
 */
export const bulkToggleFeaturesEnvironmentOn = (
    projectId: string,
    environment: string,
    bulkToggleFeaturesSchema: BodyType<BulkToggleFeaturesSchema>
) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/bulk_features/environments/${environment}/on`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: bulkToggleFeaturesSchema,
    });
};

/**
 * This endpoint disables multiple feature toggles.
 * @summary Bulk disable a list of features
 */
export const bulkToggleFeaturesEnvironmentOff = (
    projectId: string,
    environment: string,
    bulkToggleFeaturesSchema: BodyType<BulkToggleFeaturesSchema>
) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/bulk_features/environments/${environment}/off`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: bulkToggleFeaturesSchema,
    });
};

/**
 * Get strategies defined for a feature toggle in the specified environment.
 * @summary Get feature toggle strategies
 */
export const getFeatureStrategies = (
    projectId: string,
    featureName: string,
    environment: string
) => {
    return fetcher<FeatureStrategySchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies`,
        method: 'get',
    });
};

export const getGetFeatureStrategiesKey = (
    projectId: string,
    featureName: string,
    environment: string
) =>
    [
        `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies`,
    ] as const;

export type GetFeatureStrategiesQueryResult = NonNullable<
    Awaited<ReturnType<typeof getFeatureStrategies>>
>;
export type GetFeatureStrategiesQueryError = ErrorType<
    GetFeatureStrategies401 | GetFeatureStrategies403 | GetFeatureStrategies404
>;

/**
 * @summary Get feature toggle strategies
 */
export const useGetFeatureStrategies = <
    TError = ErrorType<
        | GetFeatureStrategies401
        | GetFeatureStrategies403
        | GetFeatureStrategies404
    >
>(
    projectId: string,
    featureName: string,
    environment: string,
    options?: {
        swr?: SWRConfiguration<
            Awaited<ReturnType<typeof getFeatureStrategies>>,
            TError
        > & { swrKey?: Key; enabled?: boolean };
    }
) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled =
        swrOptions?.enabled !== false &&
        !!(projectId && featureName && environment);
    const swrKey =
        swrOptions?.swrKey ??
        (() =>
            isEnabled
                ? getGetFeatureStrategiesKey(
                      projectId,
                      featureName,
                      environment
                  )
                : null);
    const swrFn = () =>
        getFeatureStrategies(projectId, featureName, environment);

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

/**
 * Add a strategy to a feature toggle in the specified environment.
 * @summary Add a strategy to a feature toggle
 */
export const addFeatureStrategy = (
    projectId: string,
    featureName: string,
    environment: string,
    createFeatureStrategySchema: BodyType<CreateFeatureStrategySchema>
) => {
    return fetcher<FeatureStrategySchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: createFeatureStrategySchema,
    });
};

/**
 * Get a strategy configuration for an environment in a feature toggle.
 * @summary Get a strategy configuration
 */
export const getFeatureStrategy = (
    projectId: string,
    featureName: string,
    environment: string,
    strategyId: string
) => {
    return fetcher<FeatureStrategySchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies/${strategyId}`,
        method: 'get',
    });
};

export const getGetFeatureStrategyKey = (
    projectId: string,
    featureName: string,
    environment: string,
    strategyId: string
) =>
    [
        `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies/${strategyId}`,
    ] as const;

export type GetFeatureStrategyQueryResult = NonNullable<
    Awaited<ReturnType<typeof getFeatureStrategy>>
>;
export type GetFeatureStrategyQueryError = ErrorType<
    GetFeatureStrategy401 | GetFeatureStrategy403 | GetFeatureStrategy404
>;

/**
 * @summary Get a strategy configuration
 */
export const useGetFeatureStrategy = <
    TError = ErrorType<
        GetFeatureStrategy401 | GetFeatureStrategy403 | GetFeatureStrategy404
    >
>(
    projectId: string,
    featureName: string,
    environment: string,
    strategyId: string,
    options?: {
        swr?: SWRConfiguration<
            Awaited<ReturnType<typeof getFeatureStrategy>>,
            TError
        > & { swrKey?: Key; enabled?: boolean };
    }
) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled =
        swrOptions?.enabled !== false &&
        !!(projectId && featureName && environment && strategyId);
    const swrKey =
        swrOptions?.swrKey ??
        (() =>
            isEnabled
                ? getGetFeatureStrategyKey(
                      projectId,
                      featureName,
                      environment,
                      strategyId
                  )
                : null);
    const swrFn = () =>
        getFeatureStrategy(projectId, featureName, environment, strategyId);

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

/**
 * Replace strategy configuration for a feature toggle in the specified environment.
 * @summary Update a strategy
 */
export const updateFeatureStrategy = (
    projectId: string,
    featureName: string,
    environment: string,
    strategyId: string,
    updateFeatureStrategySchema: BodyType<UpdateFeatureStrategySchema>
) => {
    return fetcher<FeatureStrategySchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies/${strategyId}`,
        method: 'put',
        headers: { 'Content-Type': 'application/json' },
        data: updateFeatureStrategySchema,
    });
};

/**
 * Change specific properties of a strategy configuration in a feature toggle.
 * @summary Change specific properties of a strategy
 */
export const patchFeatureStrategy = (
    projectId: string,
    featureName: string,
    environment: string,
    strategyId: string,
    patchesSchema: BodyType<PatchesSchema>
) => {
    return fetcher<FeatureStrategySchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies/${strategyId}`,
        method: 'patch',
        headers: { 'Content-Type': 'application/json' },
        data: patchesSchema,
    });
};

/**
 * Delete a strategy configuration from a feature toggle in the specified environment.
 * @summary Delete a strategy from a feature toggle
 */
export const deleteFeatureStrategy = (
    projectId: string,
    featureName: string,
    environment: string,
    strategyId: string
) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies/${strategyId}`,
        method: 'delete',
    });
};

/**
 * Set the sort order of the provided list of strategies.
 * @summary Set strategy sort order
 */
export const setStrategySortOrder = (
    projectId: string,
    featureName: string,
    environment: string,
    setStrategySortOrderSchema: BodyType<SetStrategySortOrderSchema>
) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies/set-sort-order`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: setStrategySortOrderSchema,
    });
};

/**
 * A list of all features for the specified project.
 * @summary Get all features in a project
 */
export const getFeatures = (projectId: string) => {
    return fetcher<FeaturesSchema>({
        url: `/api/admin/projects/${projectId}/features`,
        method: 'get',
    });
};

export const getGetFeaturesKey = (projectId: string) =>
    [`/api/admin/projects/${projectId}/features`] as const;

export type GetFeaturesQueryResult = NonNullable<
    Awaited<ReturnType<typeof getFeatures>>
>;
export type GetFeaturesQueryError = ErrorType<
    GetFeatures400 | GetFeatures401 | GetFeatures403
>;

/**
 * @summary Get all features in a project
 */
export const useGetFeatures = <
    TError = ErrorType<GetFeatures400 | GetFeatures401 | GetFeatures403>
>(
    projectId: string,
    options?: {
        swr?: SWRConfiguration<
            Awaited<ReturnType<typeof getFeatures>>,
            TError
        > & { swrKey?: Key; enabled?: boolean };
    }
) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled = swrOptions?.enabled !== false && !!projectId;
    const swrKey =
        swrOptions?.swrKey ??
        (() => (isEnabled ? getGetFeaturesKey(projectId) : null));
    const swrFn = () => getFeatures(projectId);

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

/**
 * Create a new feature toggle in a specified project.
 * @summary Add a new feature toggle
 */
export const createFeature = (
    projectId: string,
    createFeatureSchema: BodyType<CreateFeatureSchema>
) => {
    return fetcher<FeatureSchema>({
        url: `/api/admin/projects/${projectId}/features`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: createFeatureSchema,
    });
};

/**
 * Creates a copy of the specified feature toggle. The copy can be created in any project.
 * @summary Clone a feature toggle
 */
export const cloneFeature = (
    projectId: string,
    featureName: string,
    cloneFeatureSchema: BodyType<CloneFeatureSchema>
) => {
    return fetcher<FeatureSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/clone`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: cloneFeatureSchema,
    });
};

/**
 * This endpoint returns the information about the requested feature if the feature belongs to the specified project.
 * @summary Get a feature
 */
export const getFeature = (projectId: string, featureName: string) => {
    return fetcher<FeatureSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}`,
        method: 'get',
    });
};

export const getGetFeatureKey = (projectId: string, featureName: string) =>
    [`/api/admin/projects/${projectId}/features/${featureName}`] as const;

export type GetFeatureQueryResult = NonNullable<
    Awaited<ReturnType<typeof getFeature>>
>;
export type GetFeatureQueryError = ErrorType<
    GetFeature401 | GetFeature403 | GetFeature404
>;

/**
 * @summary Get a feature
 */
export const useGetFeature = <
    TError = ErrorType<GetFeature401 | GetFeature403 | GetFeature404>
>(
    projectId: string,
    featureName: string,
    options?: {
        swr?: SWRConfiguration<
            Awaited<ReturnType<typeof getFeature>>,
            TError
        > & { swrKey?: Key; enabled?: boolean };
    }
) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled =
        swrOptions?.enabled !== false && !!(projectId && featureName);
    const swrKey =
        swrOptions?.swrKey ??
        (() => (isEnabled ? getGetFeatureKey(projectId, featureName) : null));
    const swrFn = () => getFeature(projectId, featureName);

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

/**
 * Updates the specified feature if the feature belongs to the specified project. Only the provided properties are updated; any feature properties left out of the request body are left untouched.
 * @summary Update a feature toggle
 */
export const updateFeature = (
    projectId: string,
    featureName: string,
    updateFeatureSchema: BodyType<UpdateFeatureSchema>
) => {
    return fetcher<FeatureSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}`,
        method: 'put',
        headers: { 'Content-Type': 'application/json' },
        data: updateFeatureSchema,
    });
};

/**
 * Change specific properties of a feature toggle.
 * @summary Modify a feature toggle
 */
export const patchFeature = (
    projectId: string,
    featureName: string,
    patchesSchema: BodyType<PatchesSchema>
) => {
    return fetcher<FeatureSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}`,
        method: 'patch',
        headers: { 'Content-Type': 'application/json' },
        data: patchesSchema,
    });
};

/**
 * This endpoint archives the specified feature if the feature belongs to the specified project.
 * @summary Archive a feature toggle
 */
export const archiveFeature = (projectId: string, featureName: string) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/features/${featureName}`,
        method: 'delete',
    });
};

/**
 * This endpoint marks the provided list of features as either [stale](https://docs.getunleash.io/reference/technical-debt#stale-and-potentially-stale-toggles) or not stale depending on the request body you send. Any provided features that don't exist are ignored.
 * @summary Mark features as stale / not stale
 */
export const staleFeatures = (
    projectId: string,
    batchStaleSchema: BodyType<BatchStaleSchema>
) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/stale`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: batchStaleSchema,
    });
};

/**
 * (deprecated from 4.21) Retrieve the variants for the specified feature. From Unleash 4.21 onwards, this endpoint will attempt to choose a [production-type environment](https://docs.getunleash.io/reference/environments) as the source of truth. If more than one production environment is found, the first one will be used.
 * @deprecated
 * @summary Retrieve variants for a feature (deprecated)
 */
export const getFeatureVariants = (projectId: string, featureName: string) => {
    return fetcher<FeatureVariantsSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/variants`,
        method: 'get',
    });
};

export const getGetFeatureVariantsKey = (
    projectId: string,
    featureName: string
) =>
    [
        `/api/admin/projects/${projectId}/features/${featureName}/variants`,
    ] as const;

export type GetFeatureVariantsQueryResult = NonNullable<
    Awaited<ReturnType<typeof getFeatureVariants>>
>;
export type GetFeatureVariantsQueryError = ErrorType<
    GetFeatureVariants401 | GetFeatureVariants403 | GetFeatureVariants404
>;

/**
 * @deprecated
 * @summary Retrieve variants for a feature (deprecated)
 */
export const useGetFeatureVariants = <
    TError = ErrorType<
        GetFeatureVariants401 | GetFeatureVariants403 | GetFeatureVariants404
    >
>(
    projectId: string,
    featureName: string,
    options?: {
        swr?: SWRConfiguration<
            Awaited<ReturnType<typeof getFeatureVariants>>,
            TError
        > & { swrKey?: Key; enabled?: boolean };
    }
) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled =
        swrOptions?.enabled !== false && !!(projectId && featureName);
    const swrKey =
        swrOptions?.swrKey ??
        (() =>
            isEnabled
                ? getGetFeatureVariantsKey(projectId, featureName)
                : null);
    const swrFn = () => getFeatureVariants(projectId, featureName);

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

/**
 * Apply a list of patches patch to the specified feature's variants. The patch objects should conform to the [JSON-patch format (RFC 6902)](https://www.rfc-editor.org/rfc/rfc6902).

⚠️ **Warning**: This method is not atomic. If something fails in the middle of applying the patch, you can be left with a half-applied patch. We recommend that you instead [patch variants on a per-environment basis](/docs/reference/api/unleash/patch-environments-feature-variants.api.mdx), which **is** an atomic operation.
 * @summary Apply a patch to a feature's variants (in all environments).
 */
export const patchFeatureVariants = (
    projectId: string,
    featureName: string,
    patchesSchema: BodyType<PatchesSchema>
) => {
    return fetcher<FeatureVariantsSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/variants`,
        method: 'patch',
        headers: { 'Content-Type': 'application/json' },
        data: patchesSchema,
    });
};

/**
 * This overwrites the current variants for the feature specified in the :featureName parameter in all environments.

The backend will validate the input for the following invariants

* If there are variants, there needs to be at least one variant with `weightType: variable`
* The sum of the weights of variants with `weightType: fix` must be strictly less than 1000 (< 1000)

The backend will also distribute remaining weight up to 1000 after adding the variants with `weightType: fix` together amongst the variants of `weightType: variable`
 * @summary Create (overwrite) variants for a feature toggle in all environments
 */
export const overwriteFeatureVariants = (
    projectId: string,
    featureName: string,
    variantsSchema: BodyType<VariantsSchema>
) => {
    return fetcher<FeatureVariantsSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/variants`,
        method: 'put',
        headers: { 'Content-Type': 'application/json' },
        data: variantsSchema,
    });
};

/**
 * Returns the variants for a feature in a specific environment. If the feature has no variants it will return an empty array of variants
 * @summary Get variants for a feature in an environment
 */
export const getEnvironmentFeatureVariants = (
    projectId: string,
    featureName: string,
    environment: string
) => {
    return fetcher<FeatureVariantsSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/variants`,
        method: 'get',
    });
};

export const getGetEnvironmentFeatureVariantsKey = (
    projectId: string,
    featureName: string,
    environment: string
) =>
    [
        `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/variants`,
    ] as const;

export type GetEnvironmentFeatureVariantsQueryResult = NonNullable<
    Awaited<ReturnType<typeof getEnvironmentFeatureVariants>>
>;
export type GetEnvironmentFeatureVariantsQueryError = ErrorType<
    | GetEnvironmentFeatureVariants401
    | GetEnvironmentFeatureVariants403
    | GetEnvironmentFeatureVariants404
>;

/**
 * @summary Get variants for a feature in an environment
 */
export const useGetEnvironmentFeatureVariants = <
    TError = ErrorType<
        | GetEnvironmentFeatureVariants401
        | GetEnvironmentFeatureVariants403
        | GetEnvironmentFeatureVariants404
    >
>(
    projectId: string,
    featureName: string,
    environment: string,
    options?: {
        swr?: SWRConfiguration<
            Awaited<ReturnType<typeof getEnvironmentFeatureVariants>>,
            TError
        > & { swrKey?: Key; enabled?: boolean };
    }
) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled =
        swrOptions?.enabled !== false &&
        !!(projectId && featureName && environment);
    const swrKey =
        swrOptions?.swrKey ??
        (() =>
            isEnabled
                ? getGetEnvironmentFeatureVariantsKey(
                      projectId,
                      featureName,
                      environment
                  )
                : null);
    const swrFn = () =>
        getEnvironmentFeatureVariants(projectId, featureName, environment);

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

/**
 * Apply a list of patches to the features environments in the specified environment. The patch objects should conform to the [JSON-patch format (RFC 6902)](https://www.rfc-editor.org/rfc/rfc6902).
 * @summary Patch a feature's variants in an environment
 */
export const patchEnvironmentsFeatureVariants = (
    projectId: string,
    featureName: string,
    environment: string,
    patchesSchema: BodyType<PatchesSchema>
) => {
    return fetcher<FeatureVariantsSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/variants`,
        method: 'patch',
        headers: { 'Content-Type': 'application/json' },
        data: patchesSchema,
    });
};

/**
 * This overwrites the current variants for the feature toggle in the :featureName parameter for the :environment parameter.

The backend will validate the input for the following invariants:

* If there are variants, there needs to be at least one variant with `weightType: variable`
* The sum of the weights of variants with `weightType: fix` must be strictly less than 1000 (< 1000)

The backend will also distribute remaining weight up to 1000 after adding the variants with `weightType: fix` together amongst the variants of `weightType: variable`
 * @summary Create (overwrite) variants for a feature in an environment
 */
export const overwriteEnvironmentFeatureVariants = (
    projectId: string,
    featureName: string,
    environment: string,
    variantsSchema: BodyType<VariantsSchema>
) => {
    return fetcher<FeatureVariantsSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/variants`,
        method: 'put',
        headers: { 'Content-Type': 'application/json' },
        data: variantsSchema,
    });
};

/**
 * This overwrites the current variants for the feature toggle in the :featureName parameter for the :environment parameter.
 * @summary Create (overwrite) variants for a feature toggle in multiple environments
 */
export const overwriteFeatureVariantsOnEnvironments = (
    projectId: string,
    featureName: string,
    pushVariantsSchema: BodyType<PushVariantsSchema>
) => {
    return fetcher<FeatureVariantsSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/variants-batch`,
        method: 'put',
        headers: { 'Content-Type': 'application/json' },
        data: pushVariantsSchema,
    });
};

/**
 * This endpoint archives the specified features. Any features that are already archived or that don't exist are ignored. All existing features (whether already archived or not) that are provided must belong to the specified project.
 * @summary Archives a list of features
 */
export const archiveFeatures = (
    projectId: string,
    batchFeaturesSchema: BodyType<BatchFeaturesSchema>
) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/archive`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: batchFeaturesSchema,
    });
};

/**
 * Validates a constraint definition. Checks whether the context field exists and whether the applied configuration is valid. Additional properties are not allowed on data objects that you send to this endpoint.
 * @summary Validate constraint
 */
export const validateConstraint = (
    constraintSchema: BodyType<ConstraintSchema>
) => {
    return fetcher<void>({
        url: `/api/admin/constraints/validate`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: constraintSchema,
    });
};

/**
 * This endpoint marks the feature in the url as favorite
 * @summary Add feature to favorites
 */
export const addFavoriteFeature = (projectId: string, featureName: string) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/favorites`,
        method: 'post',
    });
};

/**
 * This endpoint removes the feature in the url from favorites
 * @summary Remove feature from favorites
 */
export const removeFavoriteFeature = (
    projectId: string,
    featureName: string
) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/favorites`,
        method: 'delete',
    });
};

/**
 * This endpoint marks the project in the url as favorite
 * @summary Add project to favorites
 */
export const addFavoriteProject = (projectId: string) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/favorites`,
        method: 'post',
    });
};

/**
 * This endpoint removes the project in the url from favorites
 * @summary Remove project from favorites
 */
export const removeFavoriteProject = (projectId: string) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/favorites`,
        method: 'delete',
    });
};
