/**
 * Generated by Orval
 * Do not edit manually.
 * See `gen:api` script in package.json
 */
import useSwr from 'swr';
import type { SWRConfiguration, Key } from 'swr';
import type {
    ChangeProjectSchema,
    FeaturesSchema,
    TagsSchema,
    ListTags401,
    ListTags403,
    ListTags404,
    TagSchema,
    UpdateTagsSchema,
    FeatureTypesSchema,
    FeatureEnvironmentSchema,
    FeatureSchema,
    BulkToggleFeaturesSchema,
    FeatureStrategySchema,
    CreateFeatureStrategySchema,
    UpdateFeatureStrategySchema,
    PatchesSchema,
    SetStrategySortOrderSchema,
    CreateFeatureSchema,
    CloneFeatureSchema,
    GetFeature401,
    GetFeature404,
    UpdateFeatureSchema,
    BatchStaleSchema,
    FeatureVariantsSchema,
    VariantsSchema,
    PushVariantsSchema,
    BatchFeaturesSchema,
    ConstraintSchema,
} from '../models';
import { fetcher } from '../fetcher';
import type { ErrorType, BodyType } from '../fetcher';

/**
 * For the feature toggle in the path, move it to the project specified in the request body.
 * @summary Move feature to another project
 */
export const changeProject = (
    projectId: string,
    featureName: string,
    changeProjectSchema: BodyType<ChangeProjectSchema>
) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/changeProject`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: changeProjectSchema,
    });
};

/**
 * @deprecated
 */
export const getAllToggles = () => {
    return fetcher<FeaturesSchema>({
        url: `/api/admin/features`,
        method: 'get',
    });
};

export const getGetAllTogglesKey = () => [`/api/admin/features`] as const;

export type GetAllTogglesQueryResult = NonNullable<
    Awaited<ReturnType<typeof getAllToggles>>
>;
export type GetAllTogglesQueryError = ErrorType<unknown>;

/**
 * @deprecated
 */
export const useGetAllToggles = <TError = ErrorType<unknown>>(options?: {
    swr?: SWRConfiguration<
        Awaited<ReturnType<typeof getAllToggles>>,
        TError
    > & { swrKey?: Key; enabled?: boolean };
}) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled = swrOptions?.enabled !== false;
    const swrKey =
        swrOptions?.swrKey ??
        (() => (isEnabled ? getGetAllTogglesKey() : null));
    const swrFn = () => getAllToggles();

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

export const validateFeature = () => {
    return fetcher<void>({
        url: `/api/admin/features/validate`,
        method: 'post',
    });
};

/**
 * Retrieves all the tags for a feature name. If the feature does not exist it returns an empty list.
 * @summary Get all tags for a feature.
 */
export const listTags = (featureName: string) => {
    return fetcher<TagsSchema>({
        url: `/api/admin/features/${featureName}/tags`,
        method: 'get',
    });
};

export const getListTagsKey = (featureName: string) =>
    [`/api/admin/features/${featureName}/tags`] as const;

export type ListTagsQueryResult = NonNullable<
    Awaited<ReturnType<typeof listTags>>
>;
export type ListTagsQueryError = ErrorType<
    ListTags401 | ListTags403 | ListTags404
>;

/**
 * @summary Get all tags for a feature.
 */
export const useListTags = <
    TError = ErrorType<ListTags401 | ListTags403 | ListTags404>
>(
    featureName: string,
    options?: {
        swr?: SWRConfiguration<Awaited<ReturnType<typeof listTags>>, TError> & {
            swrKey?: Key;
            enabled?: boolean;
        };
    }
) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled = swrOptions?.enabled !== false && !!featureName;
    const swrKey =
        swrOptions?.swrKey ??
        (() => (isEnabled ? getListTagsKey(featureName) : null));
    const swrFn = () => listTags(featureName);

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

/**
 * Adds a tag to a feature if the feature and tag type exist in the system. The operation is idempotent, so adding an existing tag will result in a successful response.
 * @summary Adds a tag to a feature.
 */
export const addTag = (featureName: string, tagSchema: BodyType<TagSchema>) => {
    return fetcher<TagSchema>({
        url: `/api/admin/features/${featureName}/tags`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: tagSchema,
    });
};

/**
 * Receives a list of tags to add and a list of tags to remove that are mandatory but can be empty. All tags under addedTags are first added to the feature and then all tags under removedTags are removed from the feature.
 * @summary Updates multiple tags for a feature.
 */
export const updateTags = (
    featureName: string,
    updateTagsSchema: BodyType<UpdateTagsSchema>
) => {
    return fetcher<TagsSchema>({
        url: `/api/admin/features/${featureName}/tags`,
        method: 'put',
        headers: { 'Content-Type': 'application/json' },
        data: updateTagsSchema,
    });
};

/**
 * Removes a tag from a feature. If the feature exists but the tag does not, it returns a successful response.
 * @summary Removes a tag from a feature.
 */
export const removeTag = (featureName: string, type: string, value: string) => {
    return fetcher<void>({
        url: `/api/admin/features/${featureName}/tags/${type}/${value}`,
        method: 'delete',
    });
};

export const getAllFeatureTypes = () => {
    return fetcher<FeatureTypesSchema>({
        url: `/api/admin/feature-types`,
        method: 'get',
    });
};

export const getGetAllFeatureTypesKey = () =>
    [`/api/admin/feature-types`] as const;

export type GetAllFeatureTypesQueryResult = NonNullable<
    Awaited<ReturnType<typeof getAllFeatureTypes>>
>;
export type GetAllFeatureTypesQueryError = ErrorType<unknown>;

export const useGetAllFeatureTypes = <TError = ErrorType<unknown>>(options?: {
    swr?: SWRConfiguration<
        Awaited<ReturnType<typeof getAllFeatureTypes>>,
        TError
    > & { swrKey?: Key; enabled?: boolean };
}) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled = swrOptions?.enabled !== false;
    const swrKey =
        swrOptions?.swrKey ??
        (() => (isEnabled ? getGetAllFeatureTypesKey() : null));
    const swrFn = () => getAllFeatureTypes();

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

export const getFeatureEnvironment = (
    projectId: string,
    featureName: string,
    environment: string
) => {
    return fetcher<FeatureEnvironmentSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}`,
        method: 'get',
    });
};

export const getGetFeatureEnvironmentKey = (
    projectId: string,
    featureName: string,
    environment: string
) =>
    [
        `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}`,
    ] as const;

export type GetFeatureEnvironmentQueryResult = NonNullable<
    Awaited<ReturnType<typeof getFeatureEnvironment>>
>;
export type GetFeatureEnvironmentQueryError = ErrorType<unknown>;

export const useGetFeatureEnvironment = <TError = ErrorType<unknown>>(
    projectId: string,
    featureName: string,
    environment: string,
    options?: {
        swr?: SWRConfiguration<
            Awaited<ReturnType<typeof getFeatureEnvironment>>,
            TError
        > & { swrKey?: Key; enabled?: boolean };
    }
) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled =
        swrOptions?.enabled !== false &&
        !!(projectId && featureName && environment);
    const swrKey =
        swrOptions?.swrKey ??
        (() =>
            isEnabled
                ? getGetFeatureEnvironmentKey(
                      projectId,
                      featureName,
                      environment
                  )
                : null);
    const swrFn = () =>
        getFeatureEnvironment(projectId, featureName, environment);

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

export const toggleFeatureEnvironmentOff = (
    projectId: string,
    featureName: string,
    environment: string
) => {
    return fetcher<FeatureSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/off`,
        method: 'post',
    });
};

export const toggleFeatureEnvironmentOn = (
    projectId: string,
    featureName: string,
    environment: string
) => {
    return fetcher<FeatureSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/on`,
        method: 'post',
    });
};

/**
 * This endpoint enables multiple feature toggles.
 * @summary Bulk enable a list of features.
 */
export const bulkToggleFeaturesEnvironmentOn = (
    projectId: string,
    environment: string,
    bulkToggleFeaturesSchema: BodyType<BulkToggleFeaturesSchema>
) => {
    return fetcher<unknown>({
        url: `/api/admin/projects/${projectId}/bulk_features/environments/${environment}/on`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: bulkToggleFeaturesSchema,
    });
};

/**
 * This endpoint disables multiple feature toggles.
 * @summary Bulk disabled a list of features.
 */
export const bulkToggleFeaturesEnvironmentOff = (
    projectId: string,
    environment: string,
    bulkToggleFeaturesSchema: BodyType<BulkToggleFeaturesSchema>
) => {
    return fetcher<unknown>({
        url: `/api/admin/projects/${projectId}/bulk_features/environments/${environment}/off`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: bulkToggleFeaturesSchema,
    });
};

export const getFeatureStrategies = (
    projectId: string,
    featureName: string,
    environment: string
) => {
    return fetcher<FeatureStrategySchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies`,
        method: 'get',
    });
};

export const getGetFeatureStrategiesKey = (
    projectId: string,
    featureName: string,
    environment: string
) =>
    [
        `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies`,
    ] as const;

export type GetFeatureStrategiesQueryResult = NonNullable<
    Awaited<ReturnType<typeof getFeatureStrategies>>
>;
export type GetFeatureStrategiesQueryError = ErrorType<unknown>;

export const useGetFeatureStrategies = <TError = ErrorType<unknown>>(
    projectId: string,
    featureName: string,
    environment: string,
    options?: {
        swr?: SWRConfiguration<
            Awaited<ReturnType<typeof getFeatureStrategies>>,
            TError
        > & { swrKey?: Key; enabled?: boolean };
    }
) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled =
        swrOptions?.enabled !== false &&
        !!(projectId && featureName && environment);
    const swrKey =
        swrOptions?.swrKey ??
        (() =>
            isEnabled
                ? getGetFeatureStrategiesKey(
                      projectId,
                      featureName,
                      environment
                  )
                : null);
    const swrFn = () =>
        getFeatureStrategies(projectId, featureName, environment);

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

export const addFeatureStrategy = (
    projectId: string,
    featureName: string,
    environment: string,
    createFeatureStrategySchema: BodyType<CreateFeatureStrategySchema>
) => {
    return fetcher<FeatureStrategySchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: createFeatureStrategySchema,
    });
};

export const getFeatureStrategy = (
    projectId: string,
    featureName: string,
    environment: string,
    strategyId: string
) => {
    return fetcher<FeatureStrategySchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies/${strategyId}`,
        method: 'get',
    });
};

export const getGetFeatureStrategyKey = (
    projectId: string,
    featureName: string,
    environment: string,
    strategyId: string
) =>
    [
        `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies/${strategyId}`,
    ] as const;

export type GetFeatureStrategyQueryResult = NonNullable<
    Awaited<ReturnType<typeof getFeatureStrategy>>
>;
export type GetFeatureStrategyQueryError = ErrorType<unknown>;

export const useGetFeatureStrategy = <TError = ErrorType<unknown>>(
    projectId: string,
    featureName: string,
    environment: string,
    strategyId: string,
    options?: {
        swr?: SWRConfiguration<
            Awaited<ReturnType<typeof getFeatureStrategy>>,
            TError
        > & { swrKey?: Key; enabled?: boolean };
    }
) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled =
        swrOptions?.enabled !== false &&
        !!(projectId && featureName && environment && strategyId);
    const swrKey =
        swrOptions?.swrKey ??
        (() =>
            isEnabled
                ? getGetFeatureStrategyKey(
                      projectId,
                      featureName,
                      environment,
                      strategyId
                  )
                : null);
    const swrFn = () =>
        getFeatureStrategy(projectId, featureName, environment, strategyId);

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

export const updateFeatureStrategy = (
    projectId: string,
    featureName: string,
    environment: string,
    strategyId: string,
    updateFeatureStrategySchema: BodyType<UpdateFeatureStrategySchema>
) => {
    return fetcher<FeatureStrategySchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies/${strategyId}`,
        method: 'put',
        headers: { 'Content-Type': 'application/json' },
        data: updateFeatureStrategySchema,
    });
};

export const patchFeatureStrategy = (
    projectId: string,
    featureName: string,
    environment: string,
    strategyId: string,
    patchesSchema: BodyType<PatchesSchema>
) => {
    return fetcher<FeatureStrategySchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies/${strategyId}`,
        method: 'patch',
        headers: { 'Content-Type': 'application/json' },
        data: patchesSchema,
    });
};

export const deleteFeatureStrategy = (
    projectId: string,
    featureName: string,
    environment: string,
    strategyId: string
) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies/${strategyId}`,
        method: 'delete',
    });
};

export const setStrategySortOrder = (
    projectId: string,
    featureName: string,
    environment: string,
    setStrategySortOrderSchema: BodyType<SetStrategySortOrderSchema>
) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/strategies/set-sort-order`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: setStrategySortOrderSchema,
    });
};

export const getFeatures = (projectId: string) => {
    return fetcher<FeaturesSchema>({
        url: `/api/admin/projects/${projectId}/features`,
        method: 'get',
    });
};

export const getGetFeaturesKey = (projectId: string) =>
    [`/api/admin/projects/${projectId}/features`] as const;

export type GetFeaturesQueryResult = NonNullable<
    Awaited<ReturnType<typeof getFeatures>>
>;
export type GetFeaturesQueryError = ErrorType<unknown>;

export const useGetFeatures = <TError = ErrorType<unknown>>(
    projectId: string,
    options?: {
        swr?: SWRConfiguration<
            Awaited<ReturnType<typeof getFeatures>>,
            TError
        > & { swrKey?: Key; enabled?: boolean };
    }
) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled = swrOptions?.enabled !== false && !!projectId;
    const swrKey =
        swrOptions?.swrKey ??
        (() => (isEnabled ? getGetFeaturesKey(projectId) : null));
    const swrFn = () => getFeatures(projectId);

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

export const createFeature = (
    projectId: string,
    createFeatureSchema: BodyType<CreateFeatureSchema>
) => {
    return fetcher<FeatureSchema>({
        url: `/api/admin/projects/${projectId}/features`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: createFeatureSchema,
    });
};

export const cloneFeature = (
    projectId: string,
    featureName: string,
    cloneFeatureSchema: BodyType<CloneFeatureSchema>
) => {
    return fetcher<FeatureSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/clone`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: cloneFeatureSchema,
    });
};

/**
 * This endpoint returns the information about the requested feature if the feature belongs to the specified project.
 * @summary Get a feature.
 */
export const getFeature = (projectId: string, featureName: string) => {
    return fetcher<FeatureSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}`,
        method: 'get',
    });
};

export const getGetFeatureKey = (projectId: string, featureName: string) =>
    [`/api/admin/projects/${projectId}/features/${featureName}`] as const;

export type GetFeatureQueryResult = NonNullable<
    Awaited<ReturnType<typeof getFeature>>
>;
export type GetFeatureQueryError = ErrorType<
    GetFeature401 | void | GetFeature404
>;

/**
 * @summary Get a feature.
 */
export const useGetFeature = <
    TError = ErrorType<GetFeature401 | void | GetFeature404>
>(
    projectId: string,
    featureName: string,
    options?: {
        swr?: SWRConfiguration<
            Awaited<ReturnType<typeof getFeature>>,
            TError
        > & { swrKey?: Key; enabled?: boolean };
    }
) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled =
        swrOptions?.enabled !== false && !!(projectId && featureName);
    const swrKey =
        swrOptions?.swrKey ??
        (() => (isEnabled ? getGetFeatureKey(projectId, featureName) : null));
    const swrFn = () => getFeature(projectId, featureName);

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

export const updateFeature = (
    projectId: string,
    featureName: string,
    updateFeatureSchema: BodyType<UpdateFeatureSchema>
) => {
    return fetcher<FeatureSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}`,
        method: 'put',
        headers: { 'Content-Type': 'application/json' },
        data: updateFeatureSchema,
    });
};

export const patchFeature = (
    projectId: string,
    featureName: string,
    patchesSchema: BodyType<PatchesSchema>
) => {
    return fetcher<FeatureSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}`,
        method: 'patch',
        headers: { 'Content-Type': 'application/json' },
        data: patchesSchema,
    });
};

/**
 * This endpoint archives the specified feature if the feature belongs to the specified project.
 * @summary Archive a feature.
 */
export const archiveFeature = (projectId: string, featureName: string) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/features/${featureName}`,
        method: 'delete',
    });
};

/**
 * This endpoint stales the specified features.
 * @summary Stales a list of features
 */
export const staleFeatures = (
    projectId: string,
    batchStaleSchema: BodyType<BatchStaleSchema>
) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/stale`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: batchStaleSchema,
    });
};

/**
 * (deprecated from 4.21) Retrieve the variants for the specified feature. From Unleash 4.21 onwards, this endpoint will attempt to choose a [production-type environment](https://docs.getunleash.io/reference/environments) as the source of truth. If more than one production environment is found, the first one will be used.
 * @deprecated
 * @summary Retrieve variants for a feature (deprecated)
 */
export const getFeatureVariants = (projectId: string, featureName: string) => {
    return fetcher<FeatureVariantsSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/variants`,
        method: 'get',
    });
};

export const getGetFeatureVariantsKey = (
    projectId: string,
    featureName: string
) =>
    [
        `/api/admin/projects/${projectId}/features/${featureName}/variants`,
    ] as const;

export type GetFeatureVariantsQueryResult = NonNullable<
    Awaited<ReturnType<typeof getFeatureVariants>>
>;
export type GetFeatureVariantsQueryError = ErrorType<unknown>;

/**
 * @deprecated
 * @summary Retrieve variants for a feature (deprecated)
 */
export const useGetFeatureVariants = <TError = ErrorType<unknown>>(
    projectId: string,
    featureName: string,
    options?: {
        swr?: SWRConfiguration<
            Awaited<ReturnType<typeof getFeatureVariants>>,
            TError
        > & { swrKey?: Key; enabled?: boolean };
    }
) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled =
        swrOptions?.enabled !== false && !!(projectId && featureName);
    const swrKey =
        swrOptions?.swrKey ??
        (() =>
            isEnabled
                ? getGetFeatureVariantsKey(projectId, featureName)
                : null);
    const swrFn = () => getFeatureVariants(projectId, featureName);

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

/**
 * Apply a list of patches patch to the specified feature's variants. The patch objects should conform to the [JSON-patch format (RFC 6902)](https://www.rfc-editor.org/rfc/rfc6902).
                        
                        ⚠️ **Warning**: This method is not atomic. If something fails in the middle of applying the patch, you can be left with a half-applied patch. We recommend that you instead [patch variants on a per-environment basis](/docs/reference/api/unleash/patch-environments-feature-variants.api.mdx), which **is** an atomic operation.
 * @summary Apply a patch to a feature's variants (in all environments).
 */
export const patchFeatureVariants = (
    projectId: string,
    featureName: string,
    patchesSchema: BodyType<PatchesSchema>
) => {
    return fetcher<FeatureVariantsSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/variants`,
        method: 'patch',
        headers: { 'Content-Type': 'application/json' },
        data: patchesSchema,
    });
};

/**
 * This overwrites the current variants for the feature specified in the :featureName parameter in all environments.

                    The backend will validate the input for the following invariants

                    * If there are variants, there needs to be at least one variant with `weightType: variable`
                    * The sum of the weights of variants with `weightType: fix` must be strictly less than 1000 (< 1000)

                    The backend will also distribute remaining weight up to 1000 after adding the variants with `weightType: fix` together amongst the variants of `weightType: variable`
 * @summary Create (overwrite) variants for a feature toggle in all environments
 */
export const overwriteFeatureVariants = (
    projectId: string,
    featureName: string,
    variantsSchema: BodyType<VariantsSchema>
) => {
    return fetcher<FeatureVariantsSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/variants`,
        method: 'put',
        headers: { 'Content-Type': 'application/json' },
        data: variantsSchema,
    });
};

/**
 * Returns the variants for a feature in a specific environment. If the feature has no variants it will return an empty array of variants
 * @summary Get variants for a feature in an environment
 */
export const getEnvironmentFeatureVariants = (
    projectId: string,
    featureName: string,
    environment: string
) => {
    return fetcher<FeatureVariantsSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/variants`,
        method: 'get',
    });
};

export const getGetEnvironmentFeatureVariantsKey = (
    projectId: string,
    featureName: string,
    environment: string
) =>
    [
        `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/variants`,
    ] as const;

export type GetEnvironmentFeatureVariantsQueryResult = NonNullable<
    Awaited<ReturnType<typeof getEnvironmentFeatureVariants>>
>;
export type GetEnvironmentFeatureVariantsQueryError = ErrorType<unknown>;

/**
 * @summary Get variants for a feature in an environment
 */
export const useGetEnvironmentFeatureVariants = <TError = ErrorType<unknown>>(
    projectId: string,
    featureName: string,
    environment: string,
    options?: {
        swr?: SWRConfiguration<
            Awaited<ReturnType<typeof getEnvironmentFeatureVariants>>,
            TError
        > & { swrKey?: Key; enabled?: boolean };
    }
) => {
    const { swr: swrOptions } = options ?? {};

    const isEnabled =
        swrOptions?.enabled !== false &&
        !!(projectId && featureName && environment);
    const swrKey =
        swrOptions?.swrKey ??
        (() =>
            isEnabled
                ? getGetEnvironmentFeatureVariantsKey(
                      projectId,
                      featureName,
                      environment
                  )
                : null);
    const swrFn = () =>
        getEnvironmentFeatureVariants(projectId, featureName, environment);

    const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
        swrKey,
        swrFn,
        swrOptions
    );

    return {
        swrKey,
        ...query,
    };
};

/**
 * Apply a list of patches to the features environments in the specified environment. The patch objects should conform to the [JSON-patch format (RFC 6902)](https://www.rfc-editor.org/rfc/rfc6902).
 * @summary Patch a feature's variants in an environment
 */
export const patchEnvironmentsFeatureVariants = (
    projectId: string,
    featureName: string,
    environment: string,
    patchesSchema: BodyType<PatchesSchema>
) => {
    return fetcher<FeatureVariantsSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/variants`,
        method: 'patch',
        headers: { 'Content-Type': 'application/json' },
        data: patchesSchema,
    });
};

/**
 * This overwrites the current variants for the feature toggle in the :featureName parameter for the :environment parameter.
                        
                        The backend will validate the input for the following invariants:
                        
                    * If there are variants, there needs to be at least one variant with `weightType: variable`
                    * The sum of the weights of variants with `weightType: fix` must be strictly less than 1000 (< 1000)

                    The backend will also distribute remaining weight up to 1000 after adding the variants with `weightType: fix` together amongst the variants of `weightType: variable`
 * @summary Create (overwrite) variants for a feature in an environment
 */
export const overwriteEnvironmentFeatureVariants = (
    projectId: string,
    featureName: string,
    environment: string,
    variantsSchema: BodyType<VariantsSchema>
) => {
    return fetcher<FeatureVariantsSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/environments/${environment}/variants`,
        method: 'put',
        headers: { 'Content-Type': 'application/json' },
        data: variantsSchema,
    });
};

export const overwriteFeatureVariantsOnEnvironments = (
    projectId: string,
    featureName: string,
    pushVariantsSchema: BodyType<PushVariantsSchema>
) => {
    return fetcher<FeatureVariantsSchema>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/variants-batch`,
        method: 'put',
        headers: { 'Content-Type': 'application/json' },
        data: pushVariantsSchema,
    });
};

/**
 * This endpoint archives the specified features.
 * @summary Archives a list of features
 */
export const archiveFeatures = (
    projectId: string,
    batchFeaturesSchema: BodyType<BatchFeaturesSchema>
) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/archive`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: batchFeaturesSchema,
    });
};

export const validateConstraint = (
    constraintSchema: BodyType<ConstraintSchema>
) => {
    return fetcher<void>({
        url: `/api/admin/constraints/validate`,
        method: 'post',
        headers: { 'Content-Type': 'application/json' },
        data: constraintSchema,
    });
};

export const addFavoriteFeature = (projectId: string, featureName: string) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/favorites`,
        method: 'post',
    });
};

export const removeFavoriteFeature = (
    projectId: string,
    featureName: string
) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/features/${featureName}/favorites`,
        method: 'delete',
    });
};

export const addFavoriteProject = (projectId: string) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/favorites`,
        method: 'post',
    });
};

export const removeFavoriteProject = (projectId: string) => {
    return fetcher<void>({
        url: `/api/admin/projects/${projectId}/favorites`,
        method: 'delete',
    });
};
