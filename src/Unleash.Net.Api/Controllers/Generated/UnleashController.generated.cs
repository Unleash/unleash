//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"

namespace Unleash.Net.Api.Controllers
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IOperationalController
    {

        /// <summary>
        /// Get instance operational status
        /// </summary>

        /// <remarks>
        /// This operation returns information about whether this Unleash instance is healthy and ready to serve requests or not. Typically used by your deployment orchestrator (e.g. Kubernetes, Docker Swarm, Mesos, et al.).
        /// </remarks>

        /// <returns>healthCheckSchema</returns>

        System.Threading.Tasks.Task<HealthCheckSchema> GetHealthAsync();

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class OperationalController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IOperationalController _implementation;

        public OperationalController(IOperationalController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Get instance operational status
        /// </summary>
        /// <remarks>
        /// This operation returns information about whether this Unleash instance is healthy and ready to serve requests or not. Typically used by your deployment orchestrator (e.g. Kubernetes, Docker Swarm, Mesos, et al.).
        /// </remarks>
        /// <returns>healthCheckSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("health", Name = "getHealth")]
        public System.Threading.Tasks.Task<HealthCheckSchema> GetHealth()
        {

            return _implementation.GetHealthAsync();
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IPublic_signup_tokensController
    {

        /// <summary>
        /// Validate signup token
        /// </summary>

        /// <remarks>
        /// Check whether the provided public sign-up token exists, has not expired and is enabled
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ValidatePublicSignupTokenAsync(string token);

        /// <summary>
        /// Add a user via a signup token
        /// </summary>

        /// <remarks>
        /// Create a user with the viewer root role and link them to the provided signup token
        /// </remarks>

        /// <param name="body">createInvitedUserSchema</param>


        /// <returns>userSchema</returns>

        System.Threading.Tasks.Task<UserSchema> AddPublicSignupTokenUserAsync(CreateInvitedUserSchema body, string token);

        /// <summary>
        /// Get public signup tokens
        /// </summary>

        /// <remarks>
        /// Retrieves all existing public signup tokens.
        /// </remarks>

        /// <returns>publicSignupTokensSchema</returns>

        System.Threading.Tasks.Task<PublicSignupTokensSchema> GetAllPublicSignupTokensAsync();

        /// <summary>
        /// Create a public signup token
        /// </summary>

        /// <remarks>
        /// Lets administrators create a invite link to share with colleagues.  People that join using the public invite are assigned the `Viewer` role
        /// </remarks>

        /// <param name="body">publicSignupTokenCreateSchema</param>

        /// <returns>The resource was successfully created.</returns>

        System.Threading.Tasks.Task<PublicSignupTokenSchema> CreatePublicSignupTokenAsync(PublicSignupTokenCreateSchema body);

        /// <summary>
        /// Retrieve a token
        /// </summary>

        /// <remarks>
        /// Get information about a specific token. The `:token` part of the URL should be the token's secret.
        /// </remarks>

        /// <returns>publicSignupTokenSchema</returns>

        System.Threading.Tasks.Task<PublicSignupTokenSchema> GetPublicSignupTokenAsync(string token);

        /// <summary>
        /// Update a public signup token
        /// </summary>

        /// <remarks>
        /// Update information about a specific token. The `:token` part of the URL should be the token's secret.
        /// </remarks>

        /// <param name="body">publicSignupTokenUpdateSchema</param>


        /// <returns>publicSignupTokenSchema</returns>

        System.Threading.Tasks.Task<PublicSignupTokenSchema> UpdatePublicSignupTokenAsync(PublicSignupTokenUpdateSchema body, string token);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class Public_signup_tokensController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IPublic_signup_tokensController _implementation;

        public Public_signup_tokensController(IPublic_signup_tokensController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Validate signup token
        /// </summary>
        /// <remarks>
        /// Check whether the provided public sign-up token exists, has not expired and is enabled
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("invite/{token}/validate", Name = "validatePublicSignupToken")]
        public System.Threading.Tasks.Task ValidatePublicSignupToken([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string token)
        {

            return _implementation.ValidatePublicSignupTokenAsync(token);
        }

        /// <summary>
        /// Add a user via a signup token
        /// </summary>
        /// <remarks>
        /// Create a user with the viewer root role and link them to the provided signup token
        /// </remarks>
        /// <param name="body">createInvitedUserSchema</param>
        /// <returns>userSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("invite/{token}/signup", Name = "addPublicSignupTokenUser")]
        public System.Threading.Tasks.Task<UserSchema> AddPublicSignupTokenUser([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateInvitedUserSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string token)
        {

            return _implementation.AddPublicSignupTokenUserAsync(body, token);
        }

        /// <summary>
        /// Get public signup tokens
        /// </summary>
        /// <remarks>
        /// Retrieves all existing public signup tokens.
        /// </remarks>
        /// <returns>publicSignupTokensSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/invite-link/tokens", Name = "getAllPublicSignupTokens")]
        public System.Threading.Tasks.Task<PublicSignupTokensSchema> GetAllPublicSignupTokens()
        {

            return _implementation.GetAllPublicSignupTokensAsync();
        }

        /// <summary>
        /// Create a public signup token
        /// </summary>
        /// <remarks>
        /// Lets administrators create a invite link to share with colleagues.  People that join using the public invite are assigned the `Viewer` role
        /// </remarks>
        /// <param name="body">publicSignupTokenCreateSchema</param>
        /// <returns>The resource was successfully created.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/invite-link/tokens", Name = "createPublicSignupToken")]
        public System.Threading.Tasks.Task<PublicSignupTokenSchema> CreatePublicSignupToken([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] PublicSignupTokenCreateSchema body)
        {

            return _implementation.CreatePublicSignupTokenAsync(body);
        }

        /// <summary>
        /// Retrieve a token
        /// </summary>
        /// <remarks>
        /// Get information about a specific token. The `:token` part of the URL should be the token's secret.
        /// </remarks>
        /// <returns>publicSignupTokenSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/invite-link/tokens/{token}", Name = "getPublicSignupToken")]
        public System.Threading.Tasks.Task<PublicSignupTokenSchema> GetPublicSignupToken([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string token)
        {

            return _implementation.GetPublicSignupTokenAsync(token);
        }

        /// <summary>
        /// Update a public signup token
        /// </summary>
        /// <remarks>
        /// Update information about a specific token. The `:token` part of the URL should be the token's secret.
        /// </remarks>
        /// <param name="body">publicSignupTokenUpdateSchema</param>
        /// <returns>publicSignupTokenSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/invite-link/tokens/{token}", Name = "updatePublicSignupToken")]
        public System.Threading.Tasks.Task<PublicSignupTokenSchema> UpdatePublicSignupToken([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] PublicSignupTokenUpdateSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string token)
        {

            return _implementation.UpdatePublicSignupTokenAsync(body, token);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IAuthController
    {

        /// <summary>
        /// Log in
        /// </summary>

        /// <remarks>
        /// Logs in the user and creates an active session
        /// </remarks>

        /// <param name="body">loginSchema</param>

        /// <returns>userSchema</returns>

        System.Threading.Tasks.Task<UserSchema> LoginAsync(LoginSchema body);

        /// <summary>
        /// Validates a token
        /// </summary>

        /// <remarks>
        /// If the token is valid returns the user that owns the token
        /// </remarks>

        /// <returns>tokenUserSchema</returns>

        System.Threading.Tasks.Task<TokenUserSchema> ValidateTokenAsync();

        /// <summary>
        /// Changes a user password
        /// </summary>

        /// <remarks>
        /// Allows users with a valid reset token to reset their password without remembering their old password
        /// </remarks>

        /// <param name="body">changePasswordSchema</param>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ChangePasswordAsync(ChangePasswordSchema body);

        /// <summary>
        /// Validates password
        /// </summary>

        /// <remarks>
        /// Verifies that the password adheres to the [Unleash password guidelines](https://docs.getunleash.io/reference/deploy/securing-unleash#password-requirements)
        /// </remarks>

        /// <param name="body">validatePasswordSchema</param>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ValidatePasswordAsync(ValidatePasswordSchema body);

        /// <summary>
        /// Reset password
        /// </summary>

        /// <remarks>
        /// Requests a password reset email for the user. This email can be used to reset the password for a user that has forgotten their password
        /// </remarks>

        /// <param name="body">emailSchema</param>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task SendResetPasswordEmailAsync(EmailSchema body);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class AuthController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IAuthController _implementation;

        public AuthController(IAuthController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Log in
        /// </summary>
        /// <remarks>
        /// Logs in the user and creates an active session
        /// </remarks>
        /// <param name="body">loginSchema</param>
        /// <returns>userSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("auth/simple/login", Name = "login")]
        public System.Threading.Tasks.Task<UserSchema> Login([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] LoginSchema body)
        {

            return _implementation.LoginAsync(body);
        }

        /// <summary>
        /// Validates a token
        /// </summary>
        /// <remarks>
        /// If the token is valid returns the user that owns the token
        /// </remarks>
        /// <returns>tokenUserSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("auth/reset/validate", Name = "validateToken")]
        public System.Threading.Tasks.Task<TokenUserSchema> ValidateToken()
        {

            return _implementation.ValidateTokenAsync();
        }

        /// <summary>
        /// Changes a user password
        /// </summary>
        /// <remarks>
        /// Allows users with a valid reset token to reset their password without remembering their old password
        /// </remarks>
        /// <param name="body">changePasswordSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("auth/reset/password", Name = "changePassword")]
        public System.Threading.Tasks.Task ChangePassword([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ChangePasswordSchema body)
        {

            return _implementation.ChangePasswordAsync(body);
        }

        /// <summary>
        /// Validates password
        /// </summary>
        /// <remarks>
        /// Verifies that the password adheres to the [Unleash password guidelines](https://docs.getunleash.io/reference/deploy/securing-unleash#password-requirements)
        /// </remarks>
        /// <param name="body">validatePasswordSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("auth/reset/validate-password", Name = "validatePassword")]
        public System.Threading.Tasks.Task ValidatePassword([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ValidatePasswordSchema body)
        {

            return _implementation.ValidatePasswordAsync(body);
        }

        /// <summary>
        /// Reset password
        /// </summary>
        /// <remarks>
        /// Requests a password reset email for the user. This email can be used to reset the password for a user that has forgotten their password
        /// </remarks>
        /// <param name="body">emailSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("auth/reset/password-email", Name = "sendResetPasswordEmail")]
        public System.Threading.Tasks.Task SendResetPasswordEmail([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] EmailSchema body)
        {

            return _implementation.SendResetPasswordEmailAsync(body);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IFeaturesController
    {

        /// <summary>
        /// Get all feature toggles (deprecated)
        /// </summary>

        /// <remarks>
        /// Gets all feature toggles with their full configuration. This endpoint is **deprecated**. You should  use the project-based endpoint instead (`/api/admin/projects/&lt;project-id&gt;/features`).
        /// </remarks>

        /// <returns>featuresSchema</returns>

        [System.Obsolete]

        System.Threading.Tasks.Task<FeaturesSchema> GetAllTogglesAsync();

        /// <summary>
        /// Validate a feature toggle name.
        /// </summary>

        /// <remarks>
        /// Validates a feature toggle name: checks whether the name is URL-friendly and whether a feature with the given name already exists. Returns 200 if the feature name is compliant and unused.
        /// </remarks>

        /// <param name="body">validateFeatureSchema</param>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ValidateFeatureAsync(ValidateFeatureSchema body);

        /// <summary>
        /// Get all tags for a feature.
        /// </summary>

        /// <remarks>
        /// Retrieves all the tags for a feature name. If the feature does not exist it returns an empty list.
        /// </remarks>

        /// <returns>tagsSchema</returns>

        System.Threading.Tasks.Task<TagsSchema> ListTagsAsync(string featureName);

        /// <summary>
        /// Adds a tag to a feature.
        /// </summary>

        /// <remarks>
        /// Adds a tag to a feature if the feature and tag type exist in the system. The operation is idempotent, so adding an existing tag will result in a successful response.
        /// </remarks>

        /// <param name="body">tagSchema</param>


        /// <returns>The resource was successfully created.</returns>

        System.Threading.Tasks.Task<TagSchema> AddTagAsync(TagSchema body, string featureName);

        /// <summary>
        /// Updates multiple tags for a feature.
        /// </summary>

        /// <remarks>
        /// Receives a list of tags to add and a list of tags to remove that are mandatory but can be empty. All tags under addedTags are first added to the feature and then all tags under removedTags are removed from the feature.
        /// </remarks>

        /// <param name="body">updateTagsSchema</param>


        /// <returns>The resource was successfully created.</returns>

        System.Threading.Tasks.Task<TagsSchema> UpdateTagsAsync(UpdateTagsSchema body, string featureName);

        /// <summary>
        /// Removes a tag from a feature.
        /// </summary>

        /// <remarks>
        /// Removes a tag from a feature. If the feature exists but the tag does not, it returns a successful response.
        /// </remarks>



        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task RemoveTagAsync(string featureName, string type, string value);

        /// <summary>
        /// Get a feature environment
        /// </summary>

        /// <remarks>
        /// Information about the enablement status and strategies for a feature toggle in specified environment.
        /// </remarks>



        /// <returns>featureEnvironmentSchema</returns>

        System.Threading.Tasks.Task<FeatureEnvironmentSchema> GetFeatureEnvironmentAsync(string projectId, string featureName, string environment);

        /// <summary>
        /// Disable a feature toggle
        /// </summary>

        /// <remarks>
        /// Disable a feature toggle in the specified environment.
        /// </remarks>



        /// <returns>featureSchema</returns>

        System.Threading.Tasks.Task<FeatureSchema> ToggleFeatureEnvironmentOffAsync(string projectId, string featureName, string environment);

        /// <summary>
        /// Enable a feature toggle
        /// </summary>

        /// <remarks>
        /// Enable a feature toggle in the specified environment.
        /// </remarks>



        /// <returns>featureSchema</returns>

        System.Threading.Tasks.Task<FeatureSchema> ToggleFeatureEnvironmentOnAsync(string projectId, string featureName, string environment);

        /// <summary>
        /// Bulk enable a list of features
        /// </summary>

        /// <remarks>
        /// This endpoint enables multiple feature toggles.
        /// </remarks>

        /// <param name="body">bulkToggleFeaturesSchema</param>


        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task BulkToggleFeaturesEnvironmentOnAsync(BulkToggleFeaturesSchema body, string projectId, string environment);

        /// <summary>
        /// Bulk disable a list of features
        /// </summary>

        /// <remarks>
        /// This endpoint disables multiple feature toggles.
        /// </remarks>

        /// <param name="body">bulkToggleFeaturesSchema</param>


        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task BulkToggleFeaturesEnvironmentOffAsync(BulkToggleFeaturesSchema body, string projectId, string environment);

        /// <summary>
        /// Get feature toggle strategies
        /// </summary>

        /// <remarks>
        /// Get strategies defined for a feature toggle in the specified environment.
        /// </remarks>



        /// <returns>featureStrategySchema</returns>

        System.Threading.Tasks.Task<FeatureStrategySchema> GetFeatureStrategiesAsync(string projectId, string featureName, string environment);

        /// <summary>
        /// Add a strategy to a feature toggle
        /// </summary>

        /// <remarks>
        /// Add a strategy to a feature toggle in the specified environment.
        /// </remarks>

        /// <param name="body">createFeatureStrategySchema</param>



        /// <returns>featureStrategySchema</returns>

        System.Threading.Tasks.Task<FeatureStrategySchema> AddFeatureStrategyAsync(CreateFeatureStrategySchema body, string projectId, string featureName, string environment);

        /// <summary>
        /// Get a strategy configuration
        /// </summary>

        /// <remarks>
        /// Get a strategy configuration for an environment in a feature toggle.
        /// </remarks>




        /// <returns>featureStrategySchema</returns>

        System.Threading.Tasks.Task<FeatureStrategySchema> GetFeatureStrategyAsync(string projectId, string featureName, string environment, string strategyId);

        /// <summary>
        /// Update a strategy
        /// </summary>

        /// <remarks>
        /// Replace strategy configuration for a feature toggle in the specified environment.
        /// </remarks>

        /// <param name="body">updateFeatureStrategySchema</param>



        /// <returns>featureStrategySchema</returns>

        System.Threading.Tasks.Task<FeatureStrategySchema> UpdateFeatureStrategyAsync(UpdateFeatureStrategySchema body, string projectId, string featureName, string environment, string strategyId);

        /// <summary>
        /// Change specific properties of a strategy
        /// </summary>

        /// <remarks>
        /// Change specific properties of a strategy configuration in a feature toggle.
        /// </remarks>

        /// <param name="body">patchesSchema</param>



        /// <returns>featureStrategySchema</returns>

        System.Threading.Tasks.Task<FeatureStrategySchema> PatchFeatureStrategyAsync(System.Collections.Generic.IEnumerable<PatchSchema> body, string projectId, string featureName, string environment, string strategyId);

        /// <summary>
        /// Delete a strategy from a feature toggle
        /// </summary>

        /// <remarks>
        /// Delete a strategy configuration from a feature toggle in the specified environment.
        /// </remarks>




        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task DeleteFeatureStrategyAsync(string projectId, string featureName, string environment, string strategyId);

        /// <summary>
        /// Set strategy sort order
        /// </summary>

        /// <remarks>
        /// Set the sort order of the provided list of strategies.
        /// </remarks>

        /// <param name="body">setStrategySortOrderSchema</param>



        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task SetStrategySortOrderAsync(System.Collections.Generic.IEnumerable<Anonymous> body, string projectId, string featureName, string environment);

        /// <summary>
        /// Get all features in a project
        /// </summary>

        /// <remarks>
        /// A list of all features for the specified project.
        /// </remarks>

        /// <returns>featuresSchema</returns>

        System.Threading.Tasks.Task<FeaturesSchema> GetFeaturesAsync(string projectId);

        /// <summary>
        /// Add a new feature toggle
        /// </summary>

        /// <remarks>
        /// Create a new feature toggle in a specified project.
        /// </remarks>

        /// <param name="body">createFeatureSchema</param>


        /// <returns>featureSchema</returns>

        System.Threading.Tasks.Task<FeatureSchema> CreateFeatureAsync(CreateFeatureSchema body, string projectId);

        /// <summary>
        /// Clone a feature toggle
        /// </summary>

        /// <remarks>
        /// Creates a copy of the specified feature toggle. The copy can be created in any project.
        /// </remarks>

        /// <param name="body">cloneFeatureSchema</param>


        /// <returns>featureSchema</returns>

        System.Threading.Tasks.Task<FeatureSchema> CloneFeatureAsync(CloneFeatureSchema body, string projectId, string featureName);

        /// <summary>
        /// Get a feature
        /// </summary>

        /// <remarks>
        /// This endpoint returns the information about the requested feature if the feature belongs to the specified project.
        /// </remarks>



        /// <returns>featureSchema</returns>

        System.Threading.Tasks.Task<FeatureSchema> GetFeatureAsync(string projectId, string featureName);

        /// <summary>
        /// Update a feature toggle
        /// </summary>

        /// <remarks>
        /// Updates the specified feature if the feature belongs to the specified project. Only the provided properties are updated; any feature properties left out of the request body are left untouched.
        /// </remarks>

        /// <param name="body">updateFeatureSchema</param>


        /// <returns>featureSchema</returns>

        System.Threading.Tasks.Task<FeatureSchema> UpdateFeatureAsync(UpdateFeatureSchema body, string projectId, string featureName);

        /// <summary>
        /// Modify a feature toggle
        /// </summary>

        /// <remarks>
        /// Change specific properties of a feature toggle.
        /// </remarks>

        /// <param name="body">patchesSchema</param>


        /// <returns>featureSchema</returns>

        System.Threading.Tasks.Task<FeatureSchema> PatchFeatureAsync(System.Collections.Generic.IEnumerable<PatchSchema> body, string projectId, string featureName);

        /// <summary>
        /// Archive a feature toggle
        /// </summary>

        /// <remarks>
        /// This endpoint archives the specified feature if the feature belongs to the specified project.
        /// </remarks>



        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ArchiveFeatureAsync(string projectId, string featureName);

        /// <summary>
        /// Mark features as stale / not stale
        /// </summary>

        /// <remarks>
        /// This endpoint marks the provided list of features as either [stale](https://docs.getunleash.io/reference/technical-debt#stale-and-potentially-stale-toggles) or not stale depending on the request body you send. Any provided features that don't exist are ignored.
        /// </remarks>

        /// <param name="body">batchStaleSchema</param>


        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task StaleFeaturesAsync(BatchStaleSchema body, string projectId);

        /// <summary>
        /// Retrieve variants for a feature (deprecated)
        /// </summary>

        /// <remarks>
        /// (deprecated from 4.21) Retrieve the variants for the specified feature. From Unleash 4.21 onwards, this endpoint will attempt to choose a [production-type environment](https://docs.getunleash.io/reference/environments) as the source of truth. If more than one production environment is found, the first one will be used.
        /// </remarks>



        /// <returns>featureVariantsSchema</returns>

        [System.Obsolete]

        System.Threading.Tasks.Task<FeatureVariantsSchema> GetFeatureVariantsAsync(string projectId, string featureName);

        /// <summary>
        /// Apply a patch to a feature's variants (in all environments).
        /// </summary>

        /// <remarks>
        /// Apply a list of patches patch to the specified feature's variants. The patch objects should conform to the [JSON-patch format (RFC 6902)](https://www.rfc-editor.org/rfc/rfc6902).
        /// <br/>
        /// <br/>⚠️ **Warning**: This method is not atomic. If something fails in the middle of applying the patch, you can be left with a half-applied patch. We recommend that you instead [patch variants on a per-environment basis](/docs/reference/api/unleash/patch-environments-feature-variants.api.mdx), which **is** an atomic operation.
        /// </remarks>

        /// <param name="body">patchesSchema</param>


        /// <returns>featureVariantsSchema</returns>

        System.Threading.Tasks.Task<FeatureVariantsSchema> PatchFeatureVariantsAsync(System.Collections.Generic.IEnumerable<PatchSchema> body, string projectId, string featureName);

        /// <summary>
        /// Create (overwrite) variants for a feature toggle in all environments
        /// </summary>

        /// <remarks>
        /// This overwrites the current variants for the feature specified in the :featureName parameter in all environments.
        /// <br/>
        /// <br/>The backend will validate the input for the following invariants
        /// <br/>
        /// <br/>* If there are variants, there needs to be at least one variant with `weightType: variable`
        /// <br/>* The sum of the weights of variants with `weightType: fix` must be strictly less than 1000 (&lt; 1000)
        /// <br/>
        /// <br/>The backend will also distribute remaining weight up to 1000 after adding the variants with `weightType: fix` together amongst the variants of `weightType: variable`
        /// </remarks>

        /// <param name="body">variantsSchema</param>


        /// <returns>featureVariantsSchema</returns>

        System.Threading.Tasks.Task<FeatureVariantsSchema> OverwriteFeatureVariantsAsync(System.Collections.Generic.IEnumerable<VariantSchema> body, string projectId, string featureName);

        /// <summary>
        /// Get variants for a feature in an environment
        /// </summary>

        /// <remarks>
        /// Returns the variants for a feature in a specific environment. If the feature has no variants it will return an empty array of variants
        /// </remarks>



        /// <returns>featureVariantsSchema</returns>

        System.Threading.Tasks.Task<FeatureVariantsSchema> GetEnvironmentFeatureVariantsAsync(string projectId, string featureName, string environment);

        /// <summary>
        /// Patch a feature's variants in an environment
        /// </summary>

        /// <remarks>
        /// Apply a list of patches to the features environments in the specified environment. The patch objects should conform to the [JSON-patch format (RFC 6902)](https://www.rfc-editor.org/rfc/rfc6902).
        /// </remarks>

        /// <param name="body">patchesSchema</param>



        /// <returns>featureVariantsSchema</returns>

        System.Threading.Tasks.Task<FeatureVariantsSchema> PatchEnvironmentsFeatureVariantsAsync(System.Collections.Generic.IEnumerable<PatchSchema> body, string projectId, string featureName, string environment);

        /// <summary>
        /// Create (overwrite) variants for a feature in an environment
        /// </summary>

        /// <remarks>
        /// This overwrites the current variants for the feature toggle in the :featureName parameter for the :environment parameter.
        /// <br/>
        /// <br/>The backend will validate the input for the following invariants:
        /// <br/>
        /// <br/>* If there are variants, there needs to be at least one variant with `weightType: variable`
        /// <br/>* The sum of the weights of variants with `weightType: fix` must be strictly less than 1000 (&lt; 1000)
        /// <br/>
        /// <br/>The backend will also distribute remaining weight up to 1000 after adding the variants with `weightType: fix` together amongst the variants of `weightType: variable`
        /// </remarks>

        /// <param name="body">variantsSchema</param>



        /// <returns>featureVariantsSchema</returns>

        System.Threading.Tasks.Task<FeatureVariantsSchema> OverwriteEnvironmentFeatureVariantsAsync(System.Collections.Generic.IEnumerable<VariantSchema> body, string projectId, string featureName, string environment);

        /// <summary>
        /// Create (overwrite) variants for a feature toggle in multiple environments
        /// </summary>

        /// <remarks>
        /// This overwrites the current variants for the feature toggle in the :featureName parameter for the :environment parameter.
        /// </remarks>

        /// <param name="body">pushVariantsSchema</param>


        /// <returns>featureVariantsSchema</returns>

        System.Threading.Tasks.Task<FeatureVariantsSchema> OverwriteFeatureVariantsOnEnvironmentsAsync(PushVariantsSchema body, string projectId, string featureName);

        /// <summary>
        /// Archives a list of features
        /// </summary>

        /// <remarks>
        /// This endpoint archives the specified features. Any features that are already archived or that don't exist are ignored. All existing features (whether already archived or not) that are provided must belong to the specified project.
        /// </remarks>

        /// <param name="body">batchFeaturesSchema</param>


        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ArchiveFeaturesAsync(BatchFeaturesSchema body, string projectId);

        /// <summary>
        /// Validate constraint
        /// </summary>

        /// <remarks>
        /// Validates a constraint definition. Checks whether the context field exists and whether the applied configuration is valid. Additional properties are not allowed on data objects that you send to this endpoint.
        /// </remarks>

        /// <param name="body">constraintSchema</param>

        /// <returns>The constraint is valid</returns>

        System.Threading.Tasks.Task ValidateConstraintAsync(ConstraintSchema body);

        /// <summary>
        /// Add feature to favorites
        /// </summary>

        /// <remarks>
        /// This endpoint marks the feature in the url as favorite
        /// </remarks>



        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task AddFavoriteFeatureAsync(string projectId, string featureName);

        /// <summary>
        /// Remove feature from favorites
        /// </summary>

        /// <remarks>
        /// This endpoint removes the feature in the url from favorites
        /// </remarks>



        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task RemoveFavoriteFeatureAsync(string projectId, string featureName);

        /// <summary>
        /// Add project to favorites
        /// </summary>

        /// <remarks>
        /// This endpoint marks the project in the url as favorite
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task AddFavoriteProjectAsync(string projectId);

        /// <summary>
        /// Remove project from favorites
        /// </summary>

        /// <remarks>
        /// This endpoint removes the project in the url from favorites
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task RemoveFavoriteProjectAsync(string projectId);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class FeaturesController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IFeaturesController _implementation;

        public FeaturesController(IFeaturesController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Get all feature toggles (deprecated)
        /// </summary>
        /// <remarks>
        /// Gets all feature toggles with their full configuration. This endpoint is **deprecated**. You should  use the project-based endpoint instead (`/api/admin/projects/&lt;project-id&gt;/features`).
        /// </remarks>
        /// <returns>featuresSchema</returns>
        [System.Obsolete]
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/features", Name = "getAllToggles")]
        public System.Threading.Tasks.Task<FeaturesSchema> GetAllToggles()
        {

            return _implementation.GetAllTogglesAsync();
        }

        /// <summary>
        /// Validate a feature toggle name.
        /// </summary>
        /// <remarks>
        /// Validates a feature toggle name: checks whether the name is URL-friendly and whether a feature with the given name already exists. Returns 200 if the feature name is compliant and unused.
        /// </remarks>
        /// <param name="body">validateFeatureSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/features/validate", Name = "validateFeature")]
        public System.Threading.Tasks.Task ValidateFeature([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ValidateFeatureSchema body)
        {

            return _implementation.ValidateFeatureAsync(body);
        }

        /// <summary>
        /// Get all tags for a feature.
        /// </summary>
        /// <remarks>
        /// Retrieves all the tags for a feature name. If the feature does not exist it returns an empty list.
        /// </remarks>
        /// <returns>tagsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/features/{featureName}/tags", Name = "listTags")]
        public System.Threading.Tasks.Task<TagsSchema> ListTags([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.ListTagsAsync(featureName);
        }

        /// <summary>
        /// Adds a tag to a feature.
        /// </summary>
        /// <remarks>
        /// Adds a tag to a feature if the feature and tag type exist in the system. The operation is idempotent, so adding an existing tag will result in a successful response.
        /// </remarks>
        /// <param name="body">tagSchema</param>
        /// <returns>The resource was successfully created.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/features/{featureName}/tags", Name = "addTag")]
        public System.Threading.Tasks.Task<TagSchema> AddTag([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] TagSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.AddTagAsync(body, featureName);
        }

        /// <summary>
        /// Updates multiple tags for a feature.
        /// </summary>
        /// <remarks>
        /// Receives a list of tags to add and a list of tags to remove that are mandatory but can be empty. All tags under addedTags are first added to the feature and then all tags under removedTags are removed from the feature.
        /// </remarks>
        /// <param name="body">updateTagsSchema</param>
        /// <returns>The resource was successfully created.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/features/{featureName}/tags", Name = "updateTags")]
        public System.Threading.Tasks.Task<TagsSchema> UpdateTags([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateTagsSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.UpdateTagsAsync(body, featureName);
        }

        /// <summary>
        /// Removes a tag from a feature.
        /// </summary>
        /// <remarks>
        /// Removes a tag from a feature. If the feature exists but the tag does not, it returns a successful response.
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/features/{featureName}/tags/{type}/{value}", Name = "removeTag")]
        public System.Threading.Tasks.Task RemoveTag([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string type, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string value)
        {

            return _implementation.RemoveTagAsync(featureName, type, value);
        }

        /// <summary>
        /// Get a feature environment
        /// </summary>
        /// <remarks>
        /// Information about the enablement status and strategies for a feature toggle in specified environment.
        /// </remarks>
        /// <returns>featureEnvironmentSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/environments/{environment}", Name = "getFeatureEnvironment")]
        public System.Threading.Tasks.Task<FeatureEnvironmentSchema> GetFeatureEnvironment([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment)
        {

            return _implementation.GetFeatureEnvironmentAsync(projectId, featureName, environment);
        }

        /// <summary>
        /// Disable a feature toggle
        /// </summary>
        /// <remarks>
        /// Disable a feature toggle in the specified environment.
        /// </remarks>
        /// <returns>featureSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/off", Name = "toggleFeatureEnvironmentOff")]
        public System.Threading.Tasks.Task<FeatureSchema> ToggleFeatureEnvironmentOff([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment)
        {

            return _implementation.ToggleFeatureEnvironmentOffAsync(projectId, featureName, environment);
        }

        /// <summary>
        /// Enable a feature toggle
        /// </summary>
        /// <remarks>
        /// Enable a feature toggle in the specified environment.
        /// </remarks>
        /// <returns>featureSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/on", Name = "toggleFeatureEnvironmentOn")]
        public System.Threading.Tasks.Task<FeatureSchema> ToggleFeatureEnvironmentOn([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment)
        {

            return _implementation.ToggleFeatureEnvironmentOnAsync(projectId, featureName, environment);
        }

        /// <summary>
        /// Bulk enable a list of features
        /// </summary>
        /// <remarks>
        /// This endpoint enables multiple feature toggles.
        /// </remarks>
        /// <param name="body">bulkToggleFeaturesSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/bulk_features/environments/{environment}/on", Name = "bulkToggleFeaturesEnvironmentOn")]
        public System.Threading.Tasks.Task BulkToggleFeaturesEnvironmentOn([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BulkToggleFeaturesSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment)
        {

            return _implementation.BulkToggleFeaturesEnvironmentOnAsync(body, projectId, environment);
        }

        /// <summary>
        /// Bulk disable a list of features
        /// </summary>
        /// <remarks>
        /// This endpoint disables multiple feature toggles.
        /// </remarks>
        /// <param name="body">bulkToggleFeaturesSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/bulk_features/environments/{environment}/off", Name = "bulkToggleFeaturesEnvironmentOff")]
        public System.Threading.Tasks.Task BulkToggleFeaturesEnvironmentOff([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BulkToggleFeaturesSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment)
        {

            return _implementation.BulkToggleFeaturesEnvironmentOffAsync(body, projectId, environment);
        }

        /// <summary>
        /// Get feature toggle strategies
        /// </summary>
        /// <remarks>
        /// Get strategies defined for a feature toggle in the specified environment.
        /// </remarks>
        /// <returns>featureStrategySchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/strategies", Name = "getFeatureStrategies")]
        public System.Threading.Tasks.Task<FeatureStrategySchema> GetFeatureStrategies([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment)
        {

            return _implementation.GetFeatureStrategiesAsync(projectId, featureName, environment);
        }

        /// <summary>
        /// Add a strategy to a feature toggle
        /// </summary>
        /// <remarks>
        /// Add a strategy to a feature toggle in the specified environment.
        /// </remarks>
        /// <param name="body">createFeatureStrategySchema</param>
        /// <returns>featureStrategySchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/strategies", Name = "addFeatureStrategy")]
        public System.Threading.Tasks.Task<FeatureStrategySchema> AddFeatureStrategy([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateFeatureStrategySchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment)
        {

            return _implementation.AddFeatureStrategyAsync(body, projectId, featureName, environment);
        }

        /// <summary>
        /// Get a strategy configuration
        /// </summary>
        /// <remarks>
        /// Get a strategy configuration for an environment in a feature toggle.
        /// </remarks>
        /// <returns>featureStrategySchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/strategies/{strategyId}", Name = "getFeatureStrategy")]
        public System.Threading.Tasks.Task<FeatureStrategySchema> GetFeatureStrategy([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string strategyId)
        {

            return _implementation.GetFeatureStrategyAsync(projectId, featureName, environment, strategyId);
        }

        /// <summary>
        /// Update a strategy
        /// </summary>
        /// <remarks>
        /// Replace strategy configuration for a feature toggle in the specified environment.
        /// </remarks>
        /// <param name="body">updateFeatureStrategySchema</param>
        /// <returns>featureStrategySchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/strategies/{strategyId}", Name = "updateFeatureStrategy")]
        public System.Threading.Tasks.Task<FeatureStrategySchema> UpdateFeatureStrategy([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateFeatureStrategySchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string strategyId)
        {

            return _implementation.UpdateFeatureStrategyAsync(body, projectId, featureName, environment, strategyId);
        }

        /// <summary>
        /// Change specific properties of a strategy
        /// </summary>
        /// <remarks>
        /// Change specific properties of a strategy configuration in a feature toggle.
        /// </remarks>
        /// <param name="body">patchesSchema</param>
        /// <returns>featureStrategySchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPatch, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/strategies/{strategyId}", Name = "patchFeatureStrategy")]
        public System.Threading.Tasks.Task<FeatureStrategySchema> PatchFeatureStrategy([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] System.Collections.Generic.IEnumerable<PatchSchema> body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string strategyId)
        {

            return _implementation.PatchFeatureStrategyAsync(body, projectId, featureName, environment, strategyId);
        }

        /// <summary>
        /// Delete a strategy from a feature toggle
        /// </summary>
        /// <remarks>
        /// Delete a strategy configuration from a feature toggle in the specified environment.
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/strategies/{strategyId}", Name = "deleteFeatureStrategy")]
        public System.Threading.Tasks.Task DeleteFeatureStrategy([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string strategyId)
        {

            return _implementation.DeleteFeatureStrategyAsync(projectId, featureName, environment, strategyId);
        }

        /// <summary>
        /// Set strategy sort order
        /// </summary>
        /// <remarks>
        /// Set the sort order of the provided list of strategies.
        /// </remarks>
        /// <param name="body">setStrategySortOrderSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/strategies/set-sort-order", Name = "setStrategySortOrder")]
        public System.Threading.Tasks.Task SetStrategySortOrder([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] System.Collections.Generic.IEnumerable<Anonymous> body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment)
        {

            return _implementation.SetStrategySortOrderAsync(body, projectId, featureName, environment);
        }

        /// <summary>
        /// Get all features in a project
        /// </summary>
        /// <remarks>
        /// A list of all features for the specified project.
        /// </remarks>
        /// <returns>featuresSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features", Name = "getFeatures")]
        public System.Threading.Tasks.Task<FeaturesSchema> GetFeatures([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId)
        {

            return _implementation.GetFeaturesAsync(projectId);
        }

        /// <summary>
        /// Add a new feature toggle
        /// </summary>
        /// <remarks>
        /// Create a new feature toggle in a specified project.
        /// </remarks>
        /// <param name="body">createFeatureSchema</param>
        /// <returns>featureSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features", Name = "createFeature")]
        public System.Threading.Tasks.Task<FeatureSchema> CreateFeature([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateFeatureSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId)
        {

            return _implementation.CreateFeatureAsync(body, projectId);
        }

        /// <summary>
        /// Clone a feature toggle
        /// </summary>
        /// <remarks>
        /// Creates a copy of the specified feature toggle. The copy can be created in any project.
        /// </remarks>
        /// <param name="body">cloneFeatureSchema</param>
        /// <returns>featureSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/clone", Name = "cloneFeature")]
        public System.Threading.Tasks.Task<FeatureSchema> CloneFeature([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CloneFeatureSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.CloneFeatureAsync(body, projectId, featureName);
        }

        /// <summary>
        /// Get a feature
        /// </summary>
        /// <remarks>
        /// This endpoint returns the information about the requested feature if the feature belongs to the specified project.
        /// </remarks>
        /// <returns>featureSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}", Name = "getFeature")]
        public System.Threading.Tasks.Task<FeatureSchema> GetFeature([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.GetFeatureAsync(projectId, featureName);
        }

        /// <summary>
        /// Update a feature toggle
        /// </summary>
        /// <remarks>
        /// Updates the specified feature if the feature belongs to the specified project. Only the provided properties are updated; any feature properties left out of the request body are left untouched.
        /// </remarks>
        /// <param name="body">updateFeatureSchema</param>
        /// <returns>featureSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}", Name = "updateFeature")]
        public System.Threading.Tasks.Task<FeatureSchema> UpdateFeature([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateFeatureSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.UpdateFeatureAsync(body, projectId, featureName);
        }

        /// <summary>
        /// Modify a feature toggle
        /// </summary>
        /// <remarks>
        /// Change specific properties of a feature toggle.
        /// </remarks>
        /// <param name="body">patchesSchema</param>
        /// <returns>featureSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPatch, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}", Name = "patchFeature")]
        public System.Threading.Tasks.Task<FeatureSchema> PatchFeature([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] System.Collections.Generic.IEnumerable<PatchSchema> body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.PatchFeatureAsync(body, projectId, featureName);
        }

        /// <summary>
        /// Archive a feature toggle
        /// </summary>
        /// <remarks>
        /// This endpoint archives the specified feature if the feature belongs to the specified project.
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}", Name = "archiveFeature")]
        public System.Threading.Tasks.Task ArchiveFeature([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.ArchiveFeatureAsync(projectId, featureName);
        }

        /// <summary>
        /// Mark features as stale / not stale
        /// </summary>
        /// <remarks>
        /// This endpoint marks the provided list of features as either [stale](https://docs.getunleash.io/reference/technical-debt#stale-and-potentially-stale-toggles) or not stale depending on the request body you send. Any provided features that don't exist are ignored.
        /// </remarks>
        /// <param name="body">batchStaleSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/stale", Name = "staleFeatures")]
        public System.Threading.Tasks.Task StaleFeatures([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BatchStaleSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId)
        {

            return _implementation.StaleFeaturesAsync(body, projectId);
        }

        /// <summary>
        /// Retrieve variants for a feature (deprecated)
        /// </summary>
        /// <remarks>
        /// (deprecated from 4.21) Retrieve the variants for the specified feature. From Unleash 4.21 onwards, this endpoint will attempt to choose a [production-type environment](https://docs.getunleash.io/reference/environments) as the source of truth. If more than one production environment is found, the first one will be used.
        /// </remarks>
        /// <returns>featureVariantsSchema</returns>
        [System.Obsolete]
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/variants", Name = "getFeatureVariants")]
        public System.Threading.Tasks.Task<FeatureVariantsSchema> GetFeatureVariants([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.GetFeatureVariantsAsync(projectId, featureName);
        }

        /// <summary>
        /// Apply a patch to a feature's variants (in all environments).
        /// </summary>
        /// <remarks>
        /// Apply a list of patches patch to the specified feature's variants. The patch objects should conform to the [JSON-patch format (RFC 6902)](https://www.rfc-editor.org/rfc/rfc6902).
        /// <br/>
        /// <br/>⚠️ **Warning**: This method is not atomic. If something fails in the middle of applying the patch, you can be left with a half-applied patch. We recommend that you instead [patch variants on a per-environment basis](/docs/reference/api/unleash/patch-environments-feature-variants.api.mdx), which **is** an atomic operation.
        /// </remarks>
        /// <param name="body">patchesSchema</param>
        /// <returns>featureVariantsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPatch, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/variants", Name = "patchFeatureVariants")]
        public System.Threading.Tasks.Task<FeatureVariantsSchema> PatchFeatureVariants([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] System.Collections.Generic.IEnumerable<PatchSchema> body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.PatchFeatureVariantsAsync(body, projectId, featureName);
        }

        /// <summary>
        /// Create (overwrite) variants for a feature toggle in all environments
        /// </summary>
        /// <remarks>
        /// This overwrites the current variants for the feature specified in the :featureName parameter in all environments.
        /// <br/>
        /// <br/>The backend will validate the input for the following invariants
        /// <br/>
        /// <br/>* If there are variants, there needs to be at least one variant with `weightType: variable`
        /// <br/>* The sum of the weights of variants with `weightType: fix` must be strictly less than 1000 (&lt; 1000)
        /// <br/>
        /// <br/>The backend will also distribute remaining weight up to 1000 after adding the variants with `weightType: fix` together amongst the variants of `weightType: variable`
        /// </remarks>
        /// <param name="body">variantsSchema</param>
        /// <returns>featureVariantsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/variants", Name = "overwriteFeatureVariants")]
        public System.Threading.Tasks.Task<FeatureVariantsSchema> OverwriteFeatureVariants([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] System.Collections.Generic.IEnumerable<VariantSchema> body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.OverwriteFeatureVariantsAsync(body, projectId, featureName);
        }

        /// <summary>
        /// Get variants for a feature in an environment
        /// </summary>
        /// <remarks>
        /// Returns the variants for a feature in a specific environment. If the feature has no variants it will return an empty array of variants
        /// </remarks>
        /// <returns>featureVariantsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/variants", Name = "getEnvironmentFeatureVariants")]
        public System.Threading.Tasks.Task<FeatureVariantsSchema> GetEnvironmentFeatureVariants([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment)
        {

            return _implementation.GetEnvironmentFeatureVariantsAsync(projectId, featureName, environment);
        }

        /// <summary>
        /// Patch a feature's variants in an environment
        /// </summary>
        /// <remarks>
        /// Apply a list of patches to the features environments in the specified environment. The patch objects should conform to the [JSON-patch format (RFC 6902)](https://www.rfc-editor.org/rfc/rfc6902).
        /// </remarks>
        /// <param name="body">patchesSchema</param>
        /// <returns>featureVariantsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPatch, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/variants", Name = "patchEnvironmentsFeatureVariants")]
        public System.Threading.Tasks.Task<FeatureVariantsSchema> PatchEnvironmentsFeatureVariants([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] System.Collections.Generic.IEnumerable<PatchSchema> body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment)
        {

            return _implementation.PatchEnvironmentsFeatureVariantsAsync(body, projectId, featureName, environment);
        }

        /// <summary>
        /// Create (overwrite) variants for a feature in an environment
        /// </summary>
        /// <remarks>
        /// This overwrites the current variants for the feature toggle in the :featureName parameter for the :environment parameter.
        /// <br/>
        /// <br/>The backend will validate the input for the following invariants:
        /// <br/>
        /// <br/>* If there are variants, there needs to be at least one variant with `weightType: variable`
        /// <br/>* The sum of the weights of variants with `weightType: fix` must be strictly less than 1000 (&lt; 1000)
        /// <br/>
        /// <br/>The backend will also distribute remaining weight up to 1000 after adding the variants with `weightType: fix` together amongst the variants of `weightType: variable`
        /// </remarks>
        /// <param name="body">variantsSchema</param>
        /// <returns>featureVariantsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/environments/{environment}/variants", Name = "overwriteEnvironmentFeatureVariants")]
        public System.Threading.Tasks.Task<FeatureVariantsSchema> OverwriteEnvironmentFeatureVariants([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] System.Collections.Generic.IEnumerable<VariantSchema> body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment)
        {

            return _implementation.OverwriteEnvironmentFeatureVariantsAsync(body, projectId, featureName, environment);
        }

        /// <summary>
        /// Create (overwrite) variants for a feature toggle in multiple environments
        /// </summary>
        /// <remarks>
        /// This overwrites the current variants for the feature toggle in the :featureName parameter for the :environment parameter.
        /// </remarks>
        /// <param name="body">pushVariantsSchema</param>
        /// <returns>featureVariantsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/variants-batch", Name = "overwriteFeatureVariantsOnEnvironments")]
        public System.Threading.Tasks.Task<FeatureVariantsSchema> OverwriteFeatureVariantsOnEnvironments([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] PushVariantsSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.OverwriteFeatureVariantsOnEnvironmentsAsync(body, projectId, featureName);
        }

        /// <summary>
        /// Archives a list of features
        /// </summary>
        /// <remarks>
        /// This endpoint archives the specified features. Any features that are already archived or that don't exist are ignored. All existing features (whether already archived or not) that are provided must belong to the specified project.
        /// </remarks>
        /// <param name="body">batchFeaturesSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/archive", Name = "archiveFeatures")]
        public System.Threading.Tasks.Task ArchiveFeatures([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BatchFeaturesSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId)
        {

            return _implementation.ArchiveFeaturesAsync(body, projectId);
        }

        /// <summary>
        /// Validate constraint
        /// </summary>
        /// <remarks>
        /// Validates a constraint definition. Checks whether the context field exists and whether the applied configuration is valid. Additional properties are not allowed on data objects that you send to this endpoint.
        /// </remarks>
        /// <param name="body">constraintSchema</param>
        /// <returns>The constraint is valid</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/constraints/validate", Name = "validateConstraint")]
        public System.Threading.Tasks.Task ValidateConstraint([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ConstraintSchema body)
        {

            return _implementation.ValidateConstraintAsync(body);
        }

        /// <summary>
        /// Add feature to favorites
        /// </summary>
        /// <remarks>
        /// This endpoint marks the feature in the url as favorite
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/favorites", Name = "addFavoriteFeature")]
        public System.Threading.Tasks.Task AddFavoriteFeature([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.AddFavoriteFeatureAsync(projectId, featureName);
        }

        /// <summary>
        /// Remove feature from favorites
        /// </summary>
        /// <remarks>
        /// This endpoint removes the feature in the url from favorites
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/features/{featureName}/favorites", Name = "removeFavoriteFeature")]
        public System.Threading.Tasks.Task RemoveFavoriteFeature([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.RemoveFavoriteFeatureAsync(projectId, featureName);
        }

        /// <summary>
        /// Add project to favorites
        /// </summary>
        /// <remarks>
        /// This endpoint marks the project in the url as favorite
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/favorites", Name = "addFavoriteProject")]
        public System.Threading.Tasks.Task AddFavoriteProject([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId)
        {

            return _implementation.AddFavoriteProjectAsync(projectId);
        }

        /// <summary>
        /// Remove project from favorites
        /// </summary>
        /// <remarks>
        /// This endpoint removes the project in the url from favorites
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/favorites", Name = "removeFavoriteProject")]
        public System.Threading.Tasks.Task RemoveFavoriteProject([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId)
        {

            return _implementation.RemoveFavoriteProjectAsync(projectId);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IFeature_TypesController
    {

        /// <summary>
        /// Get all feature types
        /// </summary>

        /// <remarks>
        /// Retrieves all feature types that exist in this Unleash instance, along with their descriptions and lifetimes.
        /// </remarks>

        /// <returns>featureTypesSchema</returns>

        System.Threading.Tasks.Task<FeatureTypesSchema> GetAllFeatureTypesAsync();

        /// <summary>
        /// Update feature type lifetime
        /// </summary>

        /// <remarks>
        /// Updates the lifetime configuration for the specified [feature toggle type](https://docs.getunleash.io/reference/feature-toggle-types). The expected lifetime is an integer representing the number of days before Unleash marks a feature toggle of that type as potentially stale. If set to `null` or `0`, then feature toggles of that particular type will never be marked as potentially stale.
        /// <br/>
        /// <br/>When a feature toggle type's expected lifetime is changed, this will also cause any feature toggles of this type to be reevaluated for potential staleness.
        /// </remarks>

        /// <param name="body">updateFeatureTypeLifetimeSchema</param>


        /// <returns>featureTypeSchema</returns>

        System.Threading.Tasks.Task<FeatureTypeSchema> UpdateFeatureTypeLifetimeAsync(UpdateFeatureTypeLifetimeSchema body, string id);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class Feature_TypesController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IFeature_TypesController _implementation;

        public Feature_TypesController(IFeature_TypesController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Get all feature types
        /// </summary>
        /// <remarks>
        /// Retrieves all feature types that exist in this Unleash instance, along with their descriptions and lifetimes.
        /// </remarks>
        /// <returns>featureTypesSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/feature-types", Name = "getAllFeatureTypes")]
        public System.Threading.Tasks.Task<FeatureTypesSchema> GetAllFeatureTypes()
        {

            return _implementation.GetAllFeatureTypesAsync();
        }

        /// <summary>
        /// Update feature type lifetime
        /// </summary>
        /// <remarks>
        /// Updates the lifetime configuration for the specified [feature toggle type](https://docs.getunleash.io/reference/feature-toggle-types). The expected lifetime is an integer representing the number of days before Unleash marks a feature toggle of that type as potentially stale. If set to `null` or `0`, then feature toggles of that particular type will never be marked as potentially stale.
        /// <br/>
        /// <br/>When a feature toggle type's expected lifetime is changed, this will also cause any feature toggles of this type to be reevaluated for potential staleness.
        /// </remarks>
        /// <param name="body">updateFeatureTypeLifetimeSchema</param>
        /// <returns>featureTypeSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/feature-types/{id}/lifetime", Name = "updateFeatureTypeLifetime")]
        public System.Threading.Tasks.Task<FeatureTypeSchema> UpdateFeatureTypeLifetime([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateFeatureTypeLifetimeSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string id)
        {

            return _implementation.UpdateFeatureTypeLifetimeAsync(body, id);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IArchiveController
    {

        /// <summary>
        /// Get archived features
        /// </summary>

        /// <remarks>
        /// Retrieve a list of all [archived feature toggles](https://docs.getunleash.io/reference/archived-toggles).
        /// </remarks>

        /// <returns>featuresSchema</returns>

        [System.Obsolete]

        System.Threading.Tasks.Task<FeaturesSchema> GetArchivedFeaturesAsync();

        /// <summary>
        /// Get archived features in project
        /// </summary>

        /// <remarks>
        /// Retrieves a list of archived features that belong to the provided project.
        /// </remarks>

        /// <returns>featuresSchema</returns>

        [System.Obsolete]

        System.Threading.Tasks.Task<FeaturesSchema> GetArchivedFeaturesByProjectIdAsync(string projectId);

        /// <summary>
        /// Archives a feature
        /// </summary>

        /// <remarks>
        /// This endpoint archives the specified feature.
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task DeleteFeatureAsync(string featureName);

        /// <summary>
        /// Revives a feature
        /// </summary>

        /// <remarks>
        /// This endpoint revives the specified feature from archive.
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ReviveFeatureAsync(string featureName);

        /// <summary>
        /// Deletes a list of features
        /// </summary>

        /// <remarks>
        /// This endpoint deletes the specified features, that are in archive.
        /// </remarks>

        /// <param name="body">batchFeaturesSchema</param>


        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task DeleteFeaturesAsync(BatchFeaturesSchema body, string projectId);

        /// <summary>
        /// Revives a list of features
        /// </summary>

        /// <remarks>
        /// This endpoint revives the specified features.
        /// </remarks>

        /// <param name="body">batchFeaturesSchema</param>


        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ReviveFeaturesAsync(BatchFeaturesSchema body, string projectId);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class ArchiveController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IArchiveController _implementation;

        public ArchiveController(IArchiveController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Get archived features
        /// </summary>
        /// <remarks>
        /// Retrieve a list of all [archived feature toggles](https://docs.getunleash.io/reference/archived-toggles).
        /// </remarks>
        /// <returns>featuresSchema</returns>
        [System.Obsolete]
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/archive/features", Name = "getArchivedFeatures")]
        public System.Threading.Tasks.Task<FeaturesSchema> GetArchivedFeatures()
        {

            return _implementation.GetArchivedFeaturesAsync();
        }

        /// <summary>
        /// Get archived features in project
        /// </summary>
        /// <remarks>
        /// Retrieves a list of archived features that belong to the provided project.
        /// </remarks>
        /// <returns>featuresSchema</returns>
        [System.Obsolete]
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/archive/features/{projectId}", Name = "getArchivedFeaturesByProjectId")]
        public System.Threading.Tasks.Task<FeaturesSchema> GetArchivedFeaturesByProjectId([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId)
        {

            return _implementation.GetArchivedFeaturesByProjectIdAsync(projectId);
        }

        /// <summary>
        /// Archives a feature
        /// </summary>
        /// <remarks>
        /// This endpoint archives the specified feature.
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/archive/{featureName}", Name = "deleteFeature")]
        public System.Threading.Tasks.Task DeleteFeature([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.DeleteFeatureAsync(featureName);
        }

        /// <summary>
        /// Revives a feature
        /// </summary>
        /// <remarks>
        /// This endpoint revives the specified feature from archive.
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/archive/revive/{featureName}", Name = "reviveFeature")]
        public System.Threading.Tasks.Task ReviveFeature([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.ReviveFeatureAsync(featureName);
        }

        /// <summary>
        /// Deletes a list of features
        /// </summary>
        /// <remarks>
        /// This endpoint deletes the specified features, that are in archive.
        /// </remarks>
        /// <param name="body">batchFeaturesSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/delete", Name = "deleteFeatures")]
        public System.Threading.Tasks.Task DeleteFeatures([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BatchFeaturesSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId)
        {

            return _implementation.DeleteFeaturesAsync(body, projectId);
        }

        /// <summary>
        /// Revives a list of features
        /// </summary>
        /// <remarks>
        /// This endpoint revives the specified features.
        /// </remarks>
        /// <param name="body">batchFeaturesSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/revive", Name = "reviveFeatures")]
        public System.Threading.Tasks.Task ReviveFeatures([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BatchFeaturesSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId)
        {

            return _implementation.ReviveFeaturesAsync(body, projectId);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IStrategiesController
    {

        /// <summary>
        /// Get all strategies
        /// </summary>

        /// <remarks>
        /// Retrieves all strategy types ([predefined](https://docs.getunleash.io/reference/activation-strategies "predefined strategies") and [custom strategies](https://docs.getunleash.io/reference/custom-activation-strategies)) that are defined on this Unleash instance.
        /// </remarks>

        /// <returns>strategiesSchema</returns>

        System.Threading.Tasks.Task<StrategiesSchema> GetAllStrategiesAsync();

        /// <summary>
        /// Create a strategy
        /// </summary>

        /// <remarks>
        /// Creates a strategy type based on the supplied data.
        /// </remarks>

        /// <param name="body">createStrategySchema</param>

        /// <returns>The resource was successfully created.</returns>

        System.Threading.Tasks.Task<StrategySchema> CreateStrategyAsync(CreateStrategySchema body);

        /// <summary>
        /// Get a strategy definition
        /// </summary>

        /// <remarks>
        /// Retrieves the definition of the strategy specified in the URL
        /// </remarks>

        /// <returns>strategySchema</returns>

        System.Threading.Tasks.Task<StrategySchema> GetStrategyAsync(string name);

        /// <summary>
        /// Delete a strategy
        /// </summary>

        /// <remarks>
        /// Deletes the specified strategy definition
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task RemoveStrategyAsync(string name);

        /// <summary>
        /// Update a strategy type
        /// </summary>

        /// <remarks>
        /// Updates the specified strategy type. Any properties not specified in the request body are left untouched.
        /// </remarks>

        /// <param name="body">updateStrategySchema</param>


        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task UpdateStrategyAsync(UpdateStrategySchema body, string name);

        /// <summary>
        /// Deprecate a strategy
        /// </summary>

        /// <remarks>
        /// Marks the specified strategy as deprecated.
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task DeprecateStrategyAsync(string strategyName);

        /// <summary>
        /// Reactivate a strategy
        /// </summary>

        /// <remarks>
        /// Marks the specified strategy as not deprecated. If the strategy wasn't already deprecated, nothing changes.
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ReactivateStrategyAsync(string strategyName);

        /// <summary>
        /// Get strategies that use a context field
        /// </summary>

        /// <remarks>
        /// Retrieves a list of all strategies that use the specified context field. If the context field doesn't exist, returns an empty list of strategies
        /// </remarks>

        /// <returns>contextFieldStrategiesSchema</returns>

        System.Threading.Tasks.Task<ContextFieldStrategiesSchema> GetStrategiesByContextFieldAsync(string contextField);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class StrategiesController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IStrategiesController _implementation;

        public StrategiesController(IStrategiesController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Get all strategies
        /// </summary>
        /// <remarks>
        /// Retrieves all strategy types ([predefined](https://docs.getunleash.io/reference/activation-strategies "predefined strategies") and [custom strategies](https://docs.getunleash.io/reference/custom-activation-strategies)) that are defined on this Unleash instance.
        /// </remarks>
        /// <returns>strategiesSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/strategies", Name = "getAllStrategies")]
        public System.Threading.Tasks.Task<StrategiesSchema> GetAllStrategies()
        {

            return _implementation.GetAllStrategiesAsync();
        }

        /// <summary>
        /// Create a strategy
        /// </summary>
        /// <remarks>
        /// Creates a strategy type based on the supplied data.
        /// </remarks>
        /// <param name="body">createStrategySchema</param>
        /// <returns>The resource was successfully created.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/strategies", Name = "createStrategy")]
        public System.Threading.Tasks.Task<StrategySchema> CreateStrategy([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateStrategySchema body)
        {

            return _implementation.CreateStrategyAsync(body);
        }

        /// <summary>
        /// Get a strategy definition
        /// </summary>
        /// <remarks>
        /// Retrieves the definition of the strategy specified in the URL
        /// </remarks>
        /// <returns>strategySchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/strategies/{name}", Name = "getStrategy")]
        public System.Threading.Tasks.Task<StrategySchema> GetStrategy([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string name)
        {

            return _implementation.GetStrategyAsync(name);
        }

        /// <summary>
        /// Delete a strategy
        /// </summary>
        /// <remarks>
        /// Deletes the specified strategy definition
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/strategies/{name}", Name = "removeStrategy")]
        public System.Threading.Tasks.Task RemoveStrategy([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string name)
        {

            return _implementation.RemoveStrategyAsync(name);
        }

        /// <summary>
        /// Update a strategy type
        /// </summary>
        /// <remarks>
        /// Updates the specified strategy type. Any properties not specified in the request body are left untouched.
        /// </remarks>
        /// <param name="body">updateStrategySchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/strategies/{name}", Name = "updateStrategy")]
        public System.Threading.Tasks.Task UpdateStrategy([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateStrategySchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string name)
        {

            return _implementation.UpdateStrategyAsync(body, name);
        }

        /// <summary>
        /// Deprecate a strategy
        /// </summary>
        /// <remarks>
        /// Marks the specified strategy as deprecated.
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/strategies/{strategyName}/deprecate", Name = "deprecateStrategy")]
        public System.Threading.Tasks.Task DeprecateStrategy([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string strategyName)
        {

            return _implementation.DeprecateStrategyAsync(strategyName);
        }

        /// <summary>
        /// Reactivate a strategy
        /// </summary>
        /// <remarks>
        /// Marks the specified strategy as not deprecated. If the strategy wasn't already deprecated, nothing changes.
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/strategies/{strategyName}/reactivate", Name = "reactivateStrategy")]
        public System.Threading.Tasks.Task ReactivateStrategy([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string strategyName)
        {

            return _implementation.ReactivateStrategyAsync(strategyName);
        }

        /// <summary>
        /// Get strategies that use a context field
        /// </summary>
        /// <remarks>
        /// Retrieves a list of all strategies that use the specified context field. If the context field doesn't exist, returns an empty list of strategies
        /// </remarks>
        /// <returns>contextFieldStrategiesSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/context/{contextField}/strategies", Name = "getStrategiesByContextField")]
        public System.Threading.Tasks.Task<ContextFieldStrategiesSchema> GetStrategiesByContextField([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string contextField)
        {

            return _implementation.GetStrategiesByContextFieldAsync(contextField);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IEventsController
    {

        /// <summary>
        /// Get the most recent events from the Unleash instance or all events related to a project.
        /// </summary>

        /// <remarks>
        /// Returns **the last 100** events from the Unleash instance when called without a query parameter. When called with a `project` parameter, returns **all events** for the specified project.
        /// <br/>
        /// <br/>If the provided project does not exist, the list of events will be empty.
        /// </remarks>

        /// <param name="project">The name of the project whose events you want to retrieve</param>

        /// <returns>eventsSchema</returns>

        System.Threading.Tasks.Task<EventsSchema> GetEventsAsync(string project);

        /// <summary>
        /// Get all events related to a specific feature toggle.
        /// </summary>

        /// <remarks>
        /// Returns all events related to the specified feature toggle. If the feature toggle does not exist, the list of events will be empty.
        /// </remarks>

        /// <returns>featureEventsSchema</returns>

        System.Threading.Tasks.Task<FeatureEventsSchema> GetEventsForToggleAsync(string featureName);

        /// <summary>
        /// Search for events
        /// </summary>

        /// <remarks>
        /// Allows searching for events matching the search criteria in the request body
        /// </remarks>

        /// <param name="body">searchEventsSchema</param>

        /// <returns>eventsSchema</returns>

        System.Threading.Tasks.Task<EventsSchema> SearchEventsAsync(SearchEventsSchema body);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class EventsController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IEventsController _implementation;

        public EventsController(IEventsController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Get the most recent events from the Unleash instance or all events related to a project.
        /// </summary>
        /// <remarks>
        /// Returns **the last 100** events from the Unleash instance when called without a query parameter. When called with a `project` parameter, returns **all events** for the specified project.
        /// <br/>
        /// <br/>If the provided project does not exist, the list of events will be empty.
        /// </remarks>
        /// <param name="project">The name of the project whose events you want to retrieve</param>
        /// <returns>eventsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/events", Name = "getEvents")]
        public System.Threading.Tasks.Task<EventsSchema> GetEvents([Microsoft.AspNetCore.Mvc.FromQuery] string project)
        {

            return _implementation.GetEventsAsync(project);
        }

        /// <summary>
        /// Get all events related to a specific feature toggle.
        /// </summary>
        /// <remarks>
        /// Returns all events related to the specified feature toggle. If the feature toggle does not exist, the list of events will be empty.
        /// </remarks>
        /// <returns>featureEventsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/events/{featureName}", Name = "getEventsForToggle")]
        public System.Threading.Tasks.Task<FeatureEventsSchema> GetEventsForToggle([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.GetEventsForToggleAsync(featureName);
        }

        /// <summary>
        /// Search for events
        /// </summary>
        /// <remarks>
        /// Allows searching for events matching the search criteria in the request body
        /// </remarks>
        /// <param name="body">searchEventsSchema</param>
        /// <returns>eventsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/events/search", Name = "searchEvents")]
        public System.Threading.Tasks.Task<EventsSchema> SearchEvents([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SearchEventsSchema body)
        {

            return _implementation.SearchEventsAsync(body);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IPlaygroundController
    {

        /// <summary>
        /// Evaluate an Unleash context against a set of environments and projects.
        /// </summary>

        /// <remarks>
        /// Deprecated. Will be removed in the next Unleash major update. Use the provided `context`, `environment`, and `projects` to evaluate toggles on this Unleash instance. Returns a list of all toggles that match the parameters and what they evaluate to. The response also contains the input parameters that were provided.
        /// </remarks>

        /// <param name="body">playgroundRequestSchema</param>

        /// <returns>playgroundResponseSchema</returns>

        System.Threading.Tasks.Task<PlaygroundResponseSchema> GetPlaygroundAsync(PlaygroundRequestSchema body);

        /// <summary>
        /// Batch evaluate an Unleash context against a set of environments and projects.
        /// </summary>

        /// <remarks>
        /// Use the provided `context`, `environments`, and `projects` to evaluate toggles on this Unleash instance. You can use comma-separated values to provide multiple values to each context field. Returns a combinatorial list of all toggles that match the parameters and what they evaluate to. The response also contains the input parameters that were provided.
        /// </remarks>

        /// <param name="body">advancedPlaygroundRequestSchema</param>

        /// <returns>advancedPlaygroundResponseSchema</returns>

        System.Threading.Tasks.Task<AdvancedPlaygroundResponseSchema> GetAdvancedPlaygroundAsync(AdvancedPlaygroundRequestSchema body);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class PlaygroundController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IPlaygroundController _implementation;

        public PlaygroundController(IPlaygroundController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Evaluate an Unleash context against a set of environments and projects.
        /// </summary>
        /// <remarks>
        /// Deprecated. Will be removed in the next Unleash major update. Use the provided `context`, `environment`, and `projects` to evaluate toggles on this Unleash instance. Returns a list of all toggles that match the parameters and what they evaluate to. The response also contains the input parameters that were provided.
        /// </remarks>
        /// <param name="body">playgroundRequestSchema</param>
        /// <returns>playgroundResponseSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/playground", Name = "getPlayground")]
        public System.Threading.Tasks.Task<PlaygroundResponseSchema> GetPlayground([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] PlaygroundRequestSchema body)
        {

            return _implementation.GetPlaygroundAsync(body);
        }

        /// <summary>
        /// Batch evaluate an Unleash context against a set of environments and projects.
        /// </summary>
        /// <remarks>
        /// Use the provided `context`, `environments`, and `projects` to evaluate toggles on this Unleash instance. You can use comma-separated values to provide multiple values to each context field. Returns a combinatorial list of all toggles that match the parameters and what they evaluate to. The response also contains the input parameters that were provided.
        /// </remarks>
        /// <param name="body">advancedPlaygroundRequestSchema</param>
        /// <returns>advancedPlaygroundResponseSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/playground/advanced", Name = "getAdvancedPlayground")]
        public System.Threading.Tasks.Task<AdvancedPlaygroundResponseSchema> GetAdvancedPlayground([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AdvancedPlaygroundRequestSchema body)
        {

            return _implementation.GetAdvancedPlaygroundAsync(body);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IMetricsController
    {

        /// <summary>
        /// Create an application to connect reported metrics
        /// </summary>

        /// <remarks>
        /// Is used to report usage as well which sdk the application uses
        /// </remarks>

        /// <param name="body">createApplicationSchema</param>


        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task CreateApplicationAsync(CreateApplicationSchema body, string appName);

        /// <summary>
        /// Delete an application
        /// </summary>

        /// <remarks>
        /// Delete the application specified in the request URL. Returns 200 OK if the application was successfully deleted or if it didn't exist
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task DeleteApplicationAsync(string appName);

        /// <summary>
        /// Get application data
        /// </summary>

        /// <remarks>
        /// Returns data about the specified application (`appName`). The data contains information on the name of the application, sdkVersion (which sdk reported these metrics, typically `unleash-client-node:3.4.1` or `unleash-client-java:7.1.0`), as well as data about how to display this application in a list.
        /// </remarks>

        /// <returns>applicationSchema</returns>

        System.Threading.Tasks.Task<ApplicationSchema> GetApplicationAsync(string appName);

        /// <summary>
        /// Get all applications
        /// </summary>

        /// <remarks>
        /// Returns all applications registered with Unleash. Applications can be created via metrics reporting or manual creation
        /// </remarks>

        /// <returns>applicationsSchema</returns>

        System.Threading.Tasks.Task<ApplicationsSchema> GetApplicationsAsync();

        /// <summary>
        /// Get feature metrics
        /// </summary>

        /// <remarks>
        /// Get usage metrics for a specific feature for the last 48 hours, grouped by hour
        /// </remarks>

        /// <returns>featureMetricsSchema</returns>

        System.Threading.Tasks.Task<FeatureMetricsSchema> GetRawFeatureMetricsAsync(string name);

        /// <summary>
        /// Last hour of usage and a list of applications that have reported seeing this feature toggle
        /// </summary>

        /// <remarks>
        /// Separate counts for yes (enabled), no (disabled), as well as how many times each variant was selected during the last hour
        /// </remarks>

        /// <returns>featureUsageSchema</returns>

        System.Threading.Tasks.Task<FeatureUsageSchema> GetFeatureUsageSummaryAsync(string name);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class MetricsController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IMetricsController _implementation;

        public MetricsController(IMetricsController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Create an application to connect reported metrics
        /// </summary>
        /// <remarks>
        /// Is used to report usage as well which sdk the application uses
        /// </remarks>
        /// <param name="body">createApplicationSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/metrics/applications/{appName}", Name = "createApplication")]
        public System.Threading.Tasks.Task CreateApplication([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateApplicationSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string appName)
        {

            return _implementation.CreateApplicationAsync(body, appName);
        }

        /// <summary>
        /// Delete an application
        /// </summary>
        /// <remarks>
        /// Delete the application specified in the request URL. Returns 200 OK if the application was successfully deleted or if it didn't exist
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/metrics/applications/{appName}", Name = "deleteApplication")]
        public System.Threading.Tasks.Task DeleteApplication([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string appName)
        {

            return _implementation.DeleteApplicationAsync(appName);
        }

        /// <summary>
        /// Get application data
        /// </summary>
        /// <remarks>
        /// Returns data about the specified application (`appName`). The data contains information on the name of the application, sdkVersion (which sdk reported these metrics, typically `unleash-client-node:3.4.1` or `unleash-client-java:7.1.0`), as well as data about how to display this application in a list.
        /// </remarks>
        /// <returns>applicationSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/metrics/applications/{appName}", Name = "getApplication")]
        public System.Threading.Tasks.Task<ApplicationSchema> GetApplication([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string appName)
        {

            return _implementation.GetApplicationAsync(appName);
        }

        /// <summary>
        /// Get all applications
        /// </summary>
        /// <remarks>
        /// Returns all applications registered with Unleash. Applications can be created via metrics reporting or manual creation
        /// </remarks>
        /// <returns>applicationsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/metrics/applications", Name = "getApplications")]
        public System.Threading.Tasks.Task<ApplicationsSchema> GetApplications()
        {

            return _implementation.GetApplicationsAsync();
        }

        /// <summary>
        /// Get feature metrics
        /// </summary>
        /// <remarks>
        /// Get usage metrics for a specific feature for the last 48 hours, grouped by hour
        /// </remarks>
        /// <returns>featureMetricsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/client-metrics/features/{name}/raw", Name = "getRawFeatureMetrics")]
        public System.Threading.Tasks.Task<FeatureMetricsSchema> GetRawFeatureMetrics([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string name)
        {

            return _implementation.GetRawFeatureMetricsAsync(name);
        }

        /// <summary>
        /// Last hour of usage and a list of applications that have reported seeing this feature toggle
        /// </summary>
        /// <remarks>
        /// Separate counts for yes (enabled), no (disabled), as well as how many times each variant was selected during the last hour
        /// </remarks>
        /// <returns>featureUsageSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/client-metrics/features/{name}", Name = "getFeatureUsageSummary")]
        public System.Threading.Tasks.Task<FeatureUsageSchema> GetFeatureUsageSummary([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string name)
        {

            return _implementation.GetFeatureUsageSummaryAsync(name);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IUsersController
    {

        /// <summary>
        /// Get your own user details
        /// </summary>

        /// <remarks>
        /// Detailed information about the current user, user permissions and user feedback
        /// </remarks>

        /// <returns>meSchema</returns>

        System.Threading.Tasks.Task<MeSchema> GetMeAsync();

        /// <summary>
        /// Get your own user profile
        /// </summary>

        /// <remarks>
        /// Detailed information about the current user root role and project membership
        /// </remarks>

        /// <returns>profileSchema</returns>

        System.Threading.Tasks.Task<ProfileSchema> GetProfileAsync();

        /// <summary>
        /// Change your own password
        /// </summary>

        /// <remarks>
        /// Requires specifying old password and confirming new password
        /// </remarks>

        /// <param name="body">passwordSchema</param>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ChangeMyPasswordAsync(PasswordSchema body);

        /// <summary>
        /// Validate password for a user
        /// </summary>

        /// <remarks>
        /// Validate the password strength. Minimum 10 characters, uppercase letter, number, special character.
        /// </remarks>

        /// <param name="body">passwordSchema</param>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ValidateUserPasswordAsync(PasswordSchema body);

        /// <summary>
        /// Change password for a user
        /// </summary>

        /// <remarks>
        /// Change password for a user as an admin
        /// </remarks>

        /// <param name="body">passwordSchema</param>


        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ChangeUserPasswordAsync(PasswordSchema body, string id);

        /// <summary>
        /// Reset user password
        /// </summary>

        /// <remarks>
        /// Reset user password as an admin
        /// </remarks>

        /// <param name="body">idSchema</param>

        /// <returns>resetPasswordSchema</returns>

        System.Threading.Tasks.Task<ResetPasswordSchema> ResetUserPasswordAsync(IdSchema body);

        /// <summary>
        /// Get all users and [root roles](https://docs.getunleash.io/reference/rbac#predefined-roles)
        /// </summary>

        /// <remarks>
        /// Will return all users and all available root roles for the Unleash instance.
        /// </remarks>

        /// <returns>usersSchema</returns>

        System.Threading.Tasks.Task<UsersSchema> GetUsersAsync();

        /// <summary>
        /// Create a new user
        /// </summary>

        /// <remarks>
        /// Creates a new user with the given root role.
        /// </remarks>

        /// <param name="body">createUserSchema</param>

        /// <returns>The resource was successfully created.</returns>

        System.Threading.Tasks.Task<CreateUserResponseSchema> CreateUserAsync(CreateUserSchema body);

        /// <summary>
        /// Search users
        /// </summary>

        /// <remarks>
        /// It will preform a simple search based on name and email matching the given query. Requires minimum 2 characters
        /// </remarks>

        /// <param name="q">The pattern to search in the username or email</param>

        /// <returns>usersSchema</returns>

        System.Threading.Tasks.Task<UsersSchema> SearchUsersAsync(string q);

        /// <summary>
        /// Get basic user and group information
        /// </summary>

        /// <remarks>
        /// Get a subset of user and group information eligible even for non-admin users
        /// </remarks>

        /// <returns>usersGroupsBaseSchema</returns>

        System.Threading.Tasks.Task<UsersGroupsBaseSchema> GetBaseUsersAndGroupsAsync();

        /// <summary>
        /// Get total count of admin accounts
        /// </summary>

        /// <remarks>
        /// Get a total count of admins with password, without password and admin service accounts
        /// </remarks>

        /// <returns>adminCountSchema</returns>

        System.Threading.Tasks.Task<AdminCountSchema> GetAdminCountAsync();

        /// <summary>
        /// Get user
        /// </summary>

        /// <remarks>
        /// Will return a single user by id
        /// </remarks>

        /// <returns>userSchema</returns>

        System.Threading.Tasks.Task<UserSchema> GetUserAsync(string id);

        /// <summary>
        /// Update a user
        /// </summary>

        /// <remarks>
        /// Only the explicitly specified fields get updated.
        /// </remarks>

        /// <param name="body">updateUserSchema</param>


        /// <returns>createUserResponseSchema</returns>

        System.Threading.Tasks.Task<CreateUserResponseSchema> UpdateUserAsync(UpdateUserSchema body, string id);

        /// <summary>
        /// Delete a user
        /// </summary>

        /// <remarks>
        /// Deletes the user with the given userId
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task DeleteUserAsync(string id);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class UsersController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IUsersController _implementation;

        public UsersController(IUsersController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Get your own user details
        /// </summary>
        /// <remarks>
        /// Detailed information about the current user, user permissions and user feedback
        /// </remarks>
        /// <returns>meSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/user", Name = "getMe")]
        public System.Threading.Tasks.Task<MeSchema> GetMe()
        {

            return _implementation.GetMeAsync();
        }

        /// <summary>
        /// Get your own user profile
        /// </summary>
        /// <remarks>
        /// Detailed information about the current user root role and project membership
        /// </remarks>
        /// <returns>profileSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/user/profile", Name = "getProfile")]
        public System.Threading.Tasks.Task<ProfileSchema> GetProfile()
        {

            return _implementation.GetProfileAsync();
        }

        /// <summary>
        /// Change your own password
        /// </summary>
        /// <remarks>
        /// Requires specifying old password and confirming new password
        /// </remarks>
        /// <param name="body">passwordSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/user/change-password", Name = "changeMyPassword")]
        public System.Threading.Tasks.Task ChangeMyPassword([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] PasswordSchema body)
        {

            return _implementation.ChangeMyPasswordAsync(body);
        }

        /// <summary>
        /// Validate password for a user
        /// </summary>
        /// <remarks>
        /// Validate the password strength. Minimum 10 characters, uppercase letter, number, special character.
        /// </remarks>
        /// <param name="body">passwordSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/user-admin/validate-password", Name = "validateUserPassword")]
        public System.Threading.Tasks.Task ValidateUserPassword([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] PasswordSchema body)
        {

            return _implementation.ValidateUserPasswordAsync(body);
        }

        /// <summary>
        /// Change password for a user
        /// </summary>
        /// <remarks>
        /// Change password for a user as an admin
        /// </remarks>
        /// <param name="body">passwordSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/user-admin/{id}/change-password", Name = "changeUserPassword")]
        public System.Threading.Tasks.Task ChangeUserPassword([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] PasswordSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string id)
        {

            return _implementation.ChangeUserPasswordAsync(body, id);
        }

        /// <summary>
        /// Reset user password
        /// </summary>
        /// <remarks>
        /// Reset user password as an admin
        /// </remarks>
        /// <param name="body">idSchema</param>
        /// <returns>resetPasswordSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/user-admin/reset-password", Name = "resetUserPassword")]
        public System.Threading.Tasks.Task<ResetPasswordSchema> ResetUserPassword([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] IdSchema body)
        {

            return _implementation.ResetUserPasswordAsync(body);
        }

        /// <summary>
        /// Get all users and [root roles](https://docs.getunleash.io/reference/rbac#predefined-roles)
        /// </summary>
        /// <remarks>
        /// Will return all users and all available root roles for the Unleash instance.
        /// </remarks>
        /// <returns>usersSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/user-admin", Name = "getUsers")]
        public System.Threading.Tasks.Task<UsersSchema> GetUsers()
        {

            return _implementation.GetUsersAsync();
        }

        /// <summary>
        /// Create a new user
        /// </summary>
        /// <remarks>
        /// Creates a new user with the given root role.
        /// </remarks>
        /// <param name="body">createUserSchema</param>
        /// <returns>The resource was successfully created.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/user-admin", Name = "createUser")]
        public System.Threading.Tasks.Task<CreateUserResponseSchema> CreateUser([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateUserSchema body)
        {

            return _implementation.CreateUserAsync(body);
        }

        /// <summary>
        /// Search users
        /// </summary>
        /// <remarks>
        /// It will preform a simple search based on name and email matching the given query. Requires minimum 2 characters
        /// </remarks>
        /// <param name="q">The pattern to search in the username or email</param>
        /// <returns>usersSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/user-admin/search", Name = "searchUsers")]
        public System.Threading.Tasks.Task<UsersSchema> SearchUsers([Microsoft.AspNetCore.Mvc.FromQuery] string q)
        {

            return _implementation.SearchUsersAsync(q);
        }

        /// <summary>
        /// Get basic user and group information
        /// </summary>
        /// <remarks>
        /// Get a subset of user and group information eligible even for non-admin users
        /// </remarks>
        /// <returns>usersGroupsBaseSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/user-admin/access", Name = "getBaseUsersAndGroups")]
        public System.Threading.Tasks.Task<UsersGroupsBaseSchema> GetBaseUsersAndGroups()
        {

            return _implementation.GetBaseUsersAndGroupsAsync();
        }

        /// <summary>
        /// Get total count of admin accounts
        /// </summary>
        /// <remarks>
        /// Get a total count of admins with password, without password and admin service accounts
        /// </remarks>
        /// <returns>adminCountSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/user-admin/admin-count", Name = "getAdminCount")]
        public System.Threading.Tasks.Task<AdminCountSchema> GetAdminCount()
        {

            return _implementation.GetAdminCountAsync();
        }

        /// <summary>
        /// Get user
        /// </summary>
        /// <remarks>
        /// Will return a single user by id
        /// </remarks>
        /// <returns>userSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/user-admin/{id}", Name = "getUser")]
        public System.Threading.Tasks.Task<UserSchema> GetUser([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string id)
        {

            return _implementation.GetUserAsync(id);
        }

        /// <summary>
        /// Update a user
        /// </summary>
        /// <remarks>
        /// Only the explicitly specified fields get updated.
        /// </remarks>
        /// <param name="body">updateUserSchema</param>
        /// <returns>createUserResponseSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/user-admin/{id}", Name = "updateUser")]
        public System.Threading.Tasks.Task<CreateUserResponseSchema> UpdateUser([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateUserSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string id)
        {

            return _implementation.UpdateUserAsync(body, id);
        }

        /// <summary>
        /// Delete a user
        /// </summary>
        /// <remarks>
        /// Deletes the user with the given userId
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/user-admin/{id}", Name = "deleteUser")]
        public System.Threading.Tasks.Task DeleteUser([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string id)
        {

            return _implementation.DeleteUserAsync(id);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IPersonal_access_tokensController
    {

        /// <summary>
        /// Get all Personal Access Tokens for the current user.
        /// </summary>

        /// <remarks>
        /// Returns all of the [Personal Access Tokens](https://docs.getunleash.io/how-to/how-to-create-personal-access-tokens) belonging to the current user.
        /// </remarks>

        /// <returns>patsSchema</returns>

        System.Threading.Tasks.Task<PatsSchema> GetPatsAsync();

        /// <summary>
        /// Create a new Personal Access Token.
        /// </summary>

        /// <remarks>
        /// Creates a new [Personal Access Token](https://docs.getunleash.io/how-to/how-to-create-personal-access-tokens) for the current user.
        /// </remarks>

        /// <param name="body">patSchema</param>

        /// <returns>The resource was successfully created.</returns>

        System.Threading.Tasks.Task<PatSchema> CreatePatAsync(PatSchema body);

        /// <summary>
        /// Delete a Personal Access Token.
        /// </summary>

        /// <remarks>
        /// This endpoint allows for deleting a [Personal Access Token](https://docs.getunleash.io/how-to/how-to-create-personal-access-tokens) belonging to the current user.
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task DeletePatAsync(string id);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class Personal_access_tokensController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IPersonal_access_tokensController _implementation;

        public Personal_access_tokensController(IPersonal_access_tokensController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Get all Personal Access Tokens for the current user.
        /// </summary>
        /// <remarks>
        /// Returns all of the [Personal Access Tokens](https://docs.getunleash.io/how-to/how-to-create-personal-access-tokens) belonging to the current user.
        /// </remarks>
        /// <returns>patsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/user/tokens", Name = "getPats")]
        public System.Threading.Tasks.Task<PatsSchema> GetPats()
        {

            return _implementation.GetPatsAsync();
        }

        /// <summary>
        /// Create a new Personal Access Token.
        /// </summary>
        /// <remarks>
        /// Creates a new [Personal Access Token](https://docs.getunleash.io/how-to/how-to-create-personal-access-tokens) for the current user.
        /// </remarks>
        /// <param name="body">patSchema</param>
        /// <returns>The resource was successfully created.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/user/tokens", Name = "createPat")]
        public System.Threading.Tasks.Task<PatSchema> CreatePat([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] PatSchema body)
        {

            return _implementation.CreatePatAsync(body);
        }

        /// <summary>
        /// Delete a Personal Access Token.
        /// </summary>
        /// <remarks>
        /// This endpoint allows for deleting a [Personal Access Token](https://docs.getunleash.io/how-to/how-to-create-personal-access-tokens) belonging to the current user.
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/user/tokens/{id}", Name = "deletePat")]
        public System.Threading.Tasks.Task DeletePat([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string id)
        {

            return _implementation.DeletePatAsync(id);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IAdmin_UIController
    {

        /// <summary>
        /// Get UI configuration
        /// </summary>

        /// <remarks>
        /// Retrieves the full configuration used to set up the Unleash Admin UI.
        /// </remarks>

        /// <returns>uiConfigSchema</returns>

        System.Threading.Tasks.Task<UiConfigSchema> GetUiConfigAsync();

        /// <summary>
        /// Set UI configuration
        /// </summary>

        /// <remarks>
        /// Sets the UI configuration for this Unleash instance.
        /// </remarks>

        /// <param name="body">setUiConfigSchema</param>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task SetUiConfigAsync(SetUiConfigSchema body);

        /// <summary>
        /// Send Unleash feedback
        /// </summary>

        /// <remarks>
        /// Sends feedback gathered from the Unleash UI to the Unleash server. Must be called with a token with an identifiable user (either from being sent from the UI or from using a [PAT](https://docs.getunleash.io/reference/api-tokens-and-client-keys#personal-access-tokens)).
        /// </remarks>

        /// <param name="body">feedbackCreateSchema</param>

        /// <returns>feedbackResponseSchema</returns>

        System.Threading.Tasks.Task<FeedbackResponseSchema> CreateFeedbackAsync(FeedbackCreateSchema body);

        /// <summary>
        /// Update Unleash feedback
        /// </summary>

        /// <remarks>
        /// Updates the feedback with the provided ID. Only provided fields are updated. Fields left out are left untouched. Must be called with a token with an identifiable user (either from being sent from the UI or from using a [PAT](https://docs.getunleash.io/reference/api-tokens-and-client-keys#personal-access-tokens)).
        /// </remarks>

        /// <param name="body">feedbackUpdateSchema</param>


        /// <returns>feedbackResponseSchema</returns>

        System.Threading.Tasks.Task<FeedbackResponseSchema> UpdateFeedbackAsync(FeedbackUpdateSchema body, string id);

        /// <summary>
        /// Update splash settings
        /// </summary>

        /// <remarks>
        /// This operation updates splash settings for a user, indicating that they have seen a particualar splash screen.
        /// </remarks>

        /// <returns>splashResponseSchema</returns>

        System.Threading.Tasks.Task<SplashResponseSchema> UpdateSplashSettingsAsync(string id);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class Admin_UIController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IAdmin_UIController _implementation;

        public Admin_UIController(IAdmin_UIController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Get UI configuration
        /// </summary>
        /// <remarks>
        /// Retrieves the full configuration used to set up the Unleash Admin UI.
        /// </remarks>
        /// <returns>uiConfigSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/ui-config", Name = "getUiConfig")]
        public System.Threading.Tasks.Task<UiConfigSchema> GetUiConfig()
        {

            return _implementation.GetUiConfigAsync();
        }

        /// <summary>
        /// Set UI configuration
        /// </summary>
        /// <remarks>
        /// Sets the UI configuration for this Unleash instance.
        /// </remarks>
        /// <param name="body">setUiConfigSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/ui-config", Name = "setUiConfig")]
        public System.Threading.Tasks.Task SetUiConfig([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SetUiConfigSchema body)
        {

            return _implementation.SetUiConfigAsync(body);
        }

        /// <summary>
        /// Send Unleash feedback
        /// </summary>
        /// <remarks>
        /// Sends feedback gathered from the Unleash UI to the Unleash server. Must be called with a token with an identifiable user (either from being sent from the UI or from using a [PAT](https://docs.getunleash.io/reference/api-tokens-and-client-keys#personal-access-tokens)).
        /// </remarks>
        /// <param name="body">feedbackCreateSchema</param>
        /// <returns>feedbackResponseSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/feedback", Name = "createFeedback")]
        public System.Threading.Tasks.Task<FeedbackResponseSchema> CreateFeedback([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] FeedbackCreateSchema body)
        {

            return _implementation.CreateFeedbackAsync(body);
        }

        /// <summary>
        /// Update Unleash feedback
        /// </summary>
        /// <remarks>
        /// Updates the feedback with the provided ID. Only provided fields are updated. Fields left out are left untouched. Must be called with a token with an identifiable user (either from being sent from the UI or from using a [PAT](https://docs.getunleash.io/reference/api-tokens-and-client-keys#personal-access-tokens)).
        /// </remarks>
        /// <param name="body">feedbackUpdateSchema</param>
        /// <returns>feedbackResponseSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/feedback/{id}", Name = "updateFeedback")]
        public System.Threading.Tasks.Task<FeedbackResponseSchema> UpdateFeedback([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] FeedbackUpdateSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string id)
        {

            return _implementation.UpdateFeedbackAsync(body, id);
        }

        /// <summary>
        /// Update splash settings
        /// </summary>
        /// <remarks>
        /// This operation updates splash settings for a user, indicating that they have seen a particualar splash screen.
        /// </remarks>
        /// <returns>splashResponseSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/splash/{id}", Name = "updateSplashSettings")]
        public System.Threading.Tasks.Task<SplashResponseSchema> UpdateSplashSettings([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string id)
        {

            return _implementation.UpdateSplashSettingsAsync(id);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IContextController
    {

        /// <summary>
        /// Gets configured context fields
        /// </summary>

        /// <remarks>
        /// Returns all configured [Context fields](https://docs.getunleash.io/how-to/how-to-define-custom-context-fields) that have been created.
        /// </remarks>

        /// <returns>contextFieldsSchema</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ContextFieldSchema>> GetContextFieldsAsync();

        /// <summary>
        /// Create a context field
        /// </summary>

        /// <remarks>
        /// Endpoint that allows creation of [custom context fields](https://docs.getunleash.io/reference/unleash-context#custom-context-fields)
        /// </remarks>

        /// <param name="body">createContextFieldSchema</param>

        /// <returns>The resource was successfully created.</returns>

        System.Threading.Tasks.Task<ContextFieldSchema> CreateContextFieldAsync(CreateContextFieldSchema body);

        /// <summary>
        /// Gets context field
        /// </summary>

        /// <remarks>
        /// Returns specific [context field](https://docs.getunleash.io/reference/unleash-context) identified by the name in the path
        /// </remarks>

        /// <returns>contextFieldSchema</returns>

        System.Threading.Tasks.Task<ContextFieldSchema> GetContextFieldAsync(string contextField);

        /// <summary>
        /// Update an existing context field
        /// </summary>

        /// <remarks>
        /// Endpoint that allows updating a custom context field. Used to toggle stickiness and add/remove legal values for this context field
        /// </remarks>

        /// <param name="body">updateContextFieldSchema</param>


        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task UpdateContextFieldAsync(UpdateContextFieldSchema body, string contextField);

        /// <summary>
        /// Delete an existing context field
        /// </summary>

        /// <remarks>
        /// Endpoint that allows deletion of a custom context field. Does not validate that context field is not in use, but since context field configuration is stored in a json blob for the strategy, existing strategies are safe.
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task DeleteContextFieldAsync(string contextField);

        /// <summary>
        /// Validate a context field
        /// </summary>

        /// <remarks>
        /// Check whether the provided data can be used to create a context field. If the data is not valid, ...?
        /// </remarks>

        /// <param name="body">nameSchema</param>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ValidateAsync(NameSchema body);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class ContextController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IContextController _implementation;

        public ContextController(IContextController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Gets configured context fields
        /// </summary>
        /// <remarks>
        /// Returns all configured [Context fields](https://docs.getunleash.io/how-to/how-to-define-custom-context-fields) that have been created.
        /// </remarks>
        /// <returns>contextFieldsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/context", Name = "getContextFields")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ContextFieldSchema>> GetContextFields()
        {

            return _implementation.GetContextFieldsAsync();
        }

        /// <summary>
        /// Create a context field
        /// </summary>
        /// <remarks>
        /// Endpoint that allows creation of [custom context fields](https://docs.getunleash.io/reference/unleash-context#custom-context-fields)
        /// </remarks>
        /// <param name="body">createContextFieldSchema</param>
        /// <returns>The resource was successfully created.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/context", Name = "createContextField")]
        public System.Threading.Tasks.Task<ContextFieldSchema> CreateContextField([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateContextFieldSchema body)
        {

            return _implementation.CreateContextFieldAsync(body);
        }

        /// <summary>
        /// Gets context field
        /// </summary>
        /// <remarks>
        /// Returns specific [context field](https://docs.getunleash.io/reference/unleash-context) identified by the name in the path
        /// </remarks>
        /// <returns>contextFieldSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/context/{contextField}", Name = "getContextField")]
        public System.Threading.Tasks.Task<ContextFieldSchema> GetContextField([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string contextField)
        {

            return _implementation.GetContextFieldAsync(contextField);
        }

        /// <summary>
        /// Update an existing context field
        /// </summary>
        /// <remarks>
        /// Endpoint that allows updating a custom context field. Used to toggle stickiness and add/remove legal values for this context field
        /// </remarks>
        /// <param name="body">updateContextFieldSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/context/{contextField}", Name = "updateContextField")]
        public System.Threading.Tasks.Task UpdateContextField([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateContextFieldSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string contextField)
        {

            return _implementation.UpdateContextFieldAsync(body, contextField);
        }

        /// <summary>
        /// Delete an existing context field
        /// </summary>
        /// <remarks>
        /// Endpoint that allows deletion of a custom context field. Does not validate that context field is not in use, but since context field configuration is stored in a json blob for the strategy, existing strategies are safe.
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/context/{contextField}", Name = "deleteContextField")]
        public System.Threading.Tasks.Task DeleteContextField([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string contextField)
        {

            return _implementation.DeleteContextFieldAsync(contextField);
        }

        /// <summary>
        /// Validate a context field
        /// </summary>
        /// <remarks>
        /// Check whether the provided data can be used to create a context field. If the data is not valid, ...?
        /// </remarks>
        /// <param name="body">nameSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/context/validate", Name = "validate")]
        public System.Threading.Tasks.Task Validate([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] NameSchema body)
        {

            return _implementation.ValidateAsync(body);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IImport_ExportController
    {

        /// <summary>
        /// Import state (deprecated)
        /// </summary>

        /// <remarks>
        /// Imports state into the system. Deprecated in favor of /api/admin/features-batch/import
        /// </remarks>

        /// <param name="body">stateSchema</param>

        /// <returns>This response has no body.</returns>

        [System.Obsolete]

        System.Threading.Tasks.Task ImportAsync(StateSchema body);

        /// <summary>
        /// Export state (deprecated)
        /// </summary>

        /// <remarks>
        /// Exports the current state of the system. Deprecated in favor of /api/admin/features-batch/export
        /// </remarks>

        /// <param name="format">Desired export format. Must be either `json` or `yaml`.</param>

        /// <param name="download">Whether exported data should be downloaded as a file.</param>

        /// <param name="strategies">Whether strategies should be included in the exported data.</param>

        /// <param name="featureToggles">Whether feature toggles should be included in the exported data.</param>

        /// <param name="projects">Whether projects should be included in the exported data.</param>

        /// <param name="tags">Whether tag types, tags, and feature_tags should be included in the exported data.</param>

        /// <param name="environments">Whether environments should be included in the exported data.</param>

        /// <returns>stateSchema</returns>

        [System.Obsolete]

        System.Threading.Tasks.Task<StateSchema> ExportAsync(Format format, Download download, Strategies strategies, FeatureToggles featureToggles, Projects projects, Tags tags, Environments environments);

        /// <summary>
        /// Export feature toggles from an environment
        /// </summary>

        /// <remarks>
        /// Exports all features listed in the `features` property from the environment specified in the request body. If set to `true`, the `downloadFile` property will let you download a file with the exported data. Otherwise, the export data is returned directly as JSON. Refer to the documentation for more information about [Unleash's export functionality](https://docs.getunleash.io/reference/deploy/environment-import-export#export).
        /// </remarks>

        /// <param name="body">exportQuerySchema</param>

        /// <returns>exportResultSchema</returns>

        System.Threading.Tasks.Task<ExportResultSchema> ExportFeaturesAsync(ExportQuerySchema body);

        /// <summary>
        /// Validate feature import data
        /// </summary>

        /// <remarks>
        /// Validates a feature toggle data set. Checks whether the data can be imported into the specified project and environment. The returned value is an object that contains errors, warnings, and permissions required to perform the import, as described in the [import documentation](https://docs.getunleash.io/reference/deploy/environment-import-export#import).
        /// </remarks>

        /// <param name="body">importTogglesSchema</param>

        /// <returns>importTogglesValidateSchema</returns>

        System.Threading.Tasks.Task<ImportTogglesValidateSchema> ValidateImportAsync(ImportTogglesSchema body);

        /// <summary>
        /// Import feature toggles
        /// </summary>

        /// <remarks>
        /// [Import feature toggles](https://docs.getunleash.io/reference/deploy/environment-import-export#import) into a specific project and environment.
        /// </remarks>

        /// <param name="body">importTogglesSchema</param>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ImportTogglesAsync(ImportTogglesSchema body);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class Import_ExportController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IImport_ExportController _implementation;

        public Import_ExportController(IImport_ExportController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Import state (deprecated)
        /// </summary>
        /// <remarks>
        /// Imports state into the system. Deprecated in favor of /api/admin/features-batch/import
        /// </remarks>
        /// <param name="body">stateSchema</param>
        /// <returns>This response has no body.</returns>
        [System.Obsolete]
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/state/import", Name = "import")]
        public System.Threading.Tasks.Task Import([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] StateSchema body)
        {

            return _implementation.ImportAsync(body);
        }

        /// <summary>
        /// Export state (deprecated)
        /// </summary>
        /// <remarks>
        /// Exports the current state of the system. Deprecated in favor of /api/admin/features-batch/export
        /// </remarks>
        /// <param name="format">Desired export format. Must be either `json` or `yaml`.</param>
        /// <param name="download">Whether exported data should be downloaded as a file.</param>
        /// <param name="strategies">Whether strategies should be included in the exported data.</param>
        /// <param name="featureToggles">Whether feature toggles should be included in the exported data.</param>
        /// <param name="projects">Whether projects should be included in the exported data.</param>
        /// <param name="tags">Whether tag types, tags, and feature_tags should be included in the exported data.</param>
        /// <param name="environments">Whether environments should be included in the exported data.</param>
        /// <returns>stateSchema</returns>
        [System.Obsolete]
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/state/export", Name = "export")]
        public System.Threading.Tasks.Task<StateSchema> Export([Microsoft.AspNetCore.Mvc.FromQuery] Format? format, [Microsoft.AspNetCore.Mvc.FromQuery] Download download, [Microsoft.AspNetCore.Mvc.FromQuery] Strategies strategies, [Microsoft.AspNetCore.Mvc.FromQuery] FeatureToggles featureToggles, [Microsoft.AspNetCore.Mvc.FromQuery] Projects projects, [Microsoft.AspNetCore.Mvc.FromQuery] Tags tags, [Microsoft.AspNetCore.Mvc.FromQuery] Environments environments)
        {

            return _implementation.ExportAsync(format ?? Unleash.Net.Api.Controllers.Format.Json, download, strategies, featureToggles, projects, tags, environments);
        }

        /// <summary>
        /// Export feature toggles from an environment
        /// </summary>
        /// <remarks>
        /// Exports all features listed in the `features` property from the environment specified in the request body. If set to `true`, the `downloadFile` property will let you download a file with the exported data. Otherwise, the export data is returned directly as JSON. Refer to the documentation for more information about [Unleash's export functionality](https://docs.getunleash.io/reference/deploy/environment-import-export#export).
        /// </remarks>
        /// <param name="body">exportQuerySchema</param>
        /// <returns>exportResultSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/features-batch/export", Name = "exportFeatures")]
        public System.Threading.Tasks.Task<ExportResultSchema> ExportFeatures([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ExportQuerySchema body)
        {

            return _implementation.ExportFeaturesAsync(body);
        }

        /// <summary>
        /// Validate feature import data
        /// </summary>
        /// <remarks>
        /// Validates a feature toggle data set. Checks whether the data can be imported into the specified project and environment. The returned value is an object that contains errors, warnings, and permissions required to perform the import, as described in the [import documentation](https://docs.getunleash.io/reference/deploy/environment-import-export#import).
        /// </remarks>
        /// <param name="body">importTogglesSchema</param>
        /// <returns>importTogglesValidateSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/features-batch/validate", Name = "validateImport")]
        public System.Threading.Tasks.Task<ImportTogglesValidateSchema> ValidateImport([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ImportTogglesSchema body)
        {

            return _implementation.ValidateImportAsync(body);
        }

        /// <summary>
        /// Import feature toggles
        /// </summary>
        /// <remarks>
        /// [Import feature toggles](https://docs.getunleash.io/reference/deploy/environment-import-export#import) into a specific project and environment.
        /// </remarks>
        /// <param name="body">importTogglesSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/features-batch/import", Name = "importToggles")]
        public System.Threading.Tasks.Task ImportToggles([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ImportTogglesSchema body)
        {

            return _implementation.ImportTogglesAsync(body);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface ITagsController
    {

        /// <summary>
        /// List all tags.
        /// </summary>

        /// <remarks>
        /// List all tags available in Unleash.
        /// </remarks>

        /// <returns>tagsSchema</returns>

        System.Threading.Tasks.Task<TagsSchema> GetTagsAsync();

        /// <summary>
        /// Create a new tag.
        /// </summary>

        /// <remarks>
        /// Create a new tag with the specified data.
        /// </remarks>

        /// <param name="body">tagSchema</param>

        /// <returns>The resource was successfully created.</returns>

        System.Threading.Tasks.Task<TagWithVersionSchema> CreateTagAsync(TagSchema body);

        /// <summary>
        /// List all tags of a given type.
        /// </summary>

        /// <remarks>
        /// List all tags of a given type. If the tag type does not exist it returns an empty list.
        /// </remarks>

        /// <returns>tagsSchema</returns>

        System.Threading.Tasks.Task<TagsSchema> GetTagsByTypeAsync(string type);

        /// <summary>
        /// Get a tag by type and value.
        /// </summary>

        /// <remarks>
        /// Get a tag by type and value. Can be used to check whether a given tag already exists in Unleash or not.
        /// </remarks>



        /// <returns>tagWithVersionSchema</returns>

        System.Threading.Tasks.Task<TagWithVersionSchema> GetTagAsync(string type, string value);

        /// <summary>
        /// Delete a tag.
        /// </summary>

        /// <remarks>
        /// Delete a tag by type and value. When a tag is deleted all references to the tag are removed.
        /// </remarks>



        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task DeleteTagAsync(string type, string value);

        /// <summary>
        /// Get all tag types
        /// </summary>

        /// <remarks>
        /// Get a list of all available tag types.
        /// </remarks>

        /// <returns>tagTypesSchema</returns>

        System.Threading.Tasks.Task<TagTypesSchema> GetTagTypesAsync();

        /// <summary>
        /// Create a tag type
        /// </summary>

        /// <remarks>
        /// Create a new tag type.
        /// </remarks>

        /// <param name="body">tagTypeSchema</param>

        /// <returns>The resource was successfully created.</returns>

        System.Threading.Tasks.Task<TagTypeSchema> CreateTagTypeAsync(TagTypeSchema body);

        /// <summary>
        /// Validate a tag type
        /// </summary>

        /// <remarks>
        /// Validates whether if the body of the request is a valid tag and whether the a tag type with that name already exists or not. If a tag type with the same name exists, this operation will return a 409 status code.
        /// </remarks>

        /// <param name="body">tagTypeSchema</param>

        /// <returns>validateTagTypeSchema</returns>

        System.Threading.Tasks.Task<ValidateTagTypeSchema> ValidateTagTypeAsync(TagTypeSchema body);

        /// <summary>
        /// Get a tag type
        /// </summary>

        /// <remarks>
        /// Get a tag type by name.
        /// </remarks>

        /// <returns>tagTypeSchema</returns>

        System.Threading.Tasks.Task<TagTypeSchema> GetTagTypeAsync(string name);

        /// <summary>
        /// Update a tag type
        /// </summary>

        /// <remarks>
        /// Update the configuration for the specified tag type.
        /// </remarks>

        /// <param name="body">updateTagTypeSchema</param>


        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task UpdateTagTypeAsync(UpdateTagTypeSchema body, string name);

        /// <summary>
        /// Delete a tag type
        /// </summary>

        /// <remarks>
        /// Deletes a tag type. If any features have tags of this type, those tags will be deleted.
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task DeleteTagTypeAsync(string name);

        /// <summary>
        /// Adds a tag to the specified features
        /// </summary>

        /// <remarks>
        /// Add a tag to a list of features. Create tags if needed.
        /// </remarks>

        /// <param name="body">tagsBulkAddSchema</param>


        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task AddTagToFeaturesAsync(TagsBulkAddSchema body, string projectId);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class TagsController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private ITagsController _implementation;

        public TagsController(ITagsController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// List all tags.
        /// </summary>
        /// <remarks>
        /// List all tags available in Unleash.
        /// </remarks>
        /// <returns>tagsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/tags", Name = "getTags")]
        public System.Threading.Tasks.Task<TagsSchema> GetTags()
        {

            return _implementation.GetTagsAsync();
        }

        /// <summary>
        /// Create a new tag.
        /// </summary>
        /// <remarks>
        /// Create a new tag with the specified data.
        /// </remarks>
        /// <param name="body">tagSchema</param>
        /// <returns>The resource was successfully created.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/tags", Name = "createTag")]
        public System.Threading.Tasks.Task<TagWithVersionSchema> CreateTag([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] TagSchema body)
        {

            return _implementation.CreateTagAsync(body);
        }

        /// <summary>
        /// List all tags of a given type.
        /// </summary>
        /// <remarks>
        /// List all tags of a given type. If the tag type does not exist it returns an empty list.
        /// </remarks>
        /// <returns>tagsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/tags/{type}", Name = "getTagsByType")]
        public System.Threading.Tasks.Task<TagsSchema> GetTagsByType([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string type)
        {

            return _implementation.GetTagsByTypeAsync(type);
        }

        /// <summary>
        /// Get a tag by type and value.
        /// </summary>
        /// <remarks>
        /// Get a tag by type and value. Can be used to check whether a given tag already exists in Unleash or not.
        /// </remarks>
        /// <returns>tagWithVersionSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/tags/{type}/{value}", Name = "getTag")]
        public System.Threading.Tasks.Task<TagWithVersionSchema> GetTag([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string type, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string value)
        {

            return _implementation.GetTagAsync(type, value);
        }

        /// <summary>
        /// Delete a tag.
        /// </summary>
        /// <remarks>
        /// Delete a tag by type and value. When a tag is deleted all references to the tag are removed.
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/tags/{type}/{value}", Name = "deleteTag")]
        public System.Threading.Tasks.Task DeleteTag([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string type, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string value)
        {

            return _implementation.DeleteTagAsync(type, value);
        }

        /// <summary>
        /// Get all tag types
        /// </summary>
        /// <remarks>
        /// Get a list of all available tag types.
        /// </remarks>
        /// <returns>tagTypesSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/tag-types", Name = "getTagTypes")]
        public System.Threading.Tasks.Task<TagTypesSchema> GetTagTypes()
        {

            return _implementation.GetTagTypesAsync();
        }

        /// <summary>
        /// Create a tag type
        /// </summary>
        /// <remarks>
        /// Create a new tag type.
        /// </remarks>
        /// <param name="body">tagTypeSchema</param>
        /// <returns>The resource was successfully created.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/tag-types", Name = "createTagType")]
        public System.Threading.Tasks.Task<TagTypeSchema> CreateTagType([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] TagTypeSchema body)
        {

            return _implementation.CreateTagTypeAsync(body);
        }

        /// <summary>
        /// Validate a tag type
        /// </summary>
        /// <remarks>
        /// Validates whether if the body of the request is a valid tag and whether the a tag type with that name already exists or not. If a tag type with the same name exists, this operation will return a 409 status code.
        /// </remarks>
        /// <param name="body">tagTypeSchema</param>
        /// <returns>validateTagTypeSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/tag-types/validate", Name = "validateTagType")]
        public System.Threading.Tasks.Task<ValidateTagTypeSchema> ValidateTagType([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] TagTypeSchema body)
        {

            return _implementation.ValidateTagTypeAsync(body);
        }

        /// <summary>
        /// Get a tag type
        /// </summary>
        /// <remarks>
        /// Get a tag type by name.
        /// </remarks>
        /// <returns>tagTypeSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/tag-types/{name}", Name = "getTagType")]
        public System.Threading.Tasks.Task<TagTypeSchema> GetTagType([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string name)
        {

            return _implementation.GetTagTypeAsync(name);
        }

        /// <summary>
        /// Update a tag type
        /// </summary>
        /// <remarks>
        /// Update the configuration for the specified tag type.
        /// </remarks>
        /// <param name="body">updateTagTypeSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/tag-types/{name}", Name = "updateTagType")]
        public System.Threading.Tasks.Task UpdateTagType([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateTagTypeSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string name)
        {

            return _implementation.UpdateTagTypeAsync(body, name);
        }

        /// <summary>
        /// Delete a tag type
        /// </summary>
        /// <remarks>
        /// Deletes a tag type. If any features have tags of this type, those tags will be deleted.
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/tag-types/{name}", Name = "deleteTagType")]
        public System.Threading.Tasks.Task DeleteTagType([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string name)
        {

            return _implementation.DeleteTagTypeAsync(name);
        }

        /// <summary>
        /// Adds a tag to the specified features
        /// </summary>
        /// <remarks>
        /// Add a tag to a list of features. Create tags if needed.
        /// </remarks>
        /// <param name="body">tagsBulkAddSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/tags", Name = "addTagToFeatures")]
        public System.Threading.Tasks.Task AddTagToFeatures([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] TagsBulkAddSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId)
        {

            return _implementation.AddTagToFeaturesAsync(body, projectId);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IAddonsController
    {

        /// <summary>
        /// Get all addons and providers
        /// </summary>

        /// <remarks>
        /// Retrieve all addons and providers that are defined on this Unleash instance.
        /// </remarks>

        /// <returns>addonsSchema</returns>

        System.Threading.Tasks.Task<AddonsSchema> GetAddonsAsync();

        /// <summary>
        /// Create a new addon
        /// </summary>

        /// <remarks>
        /// Create an addon instance. The addon must use one of the providers available on this Unleash instance.
        /// </remarks>

        /// <param name="body">addonCreateUpdateSchema</param>

        /// <returns>addonSchema</returns>

        System.Threading.Tasks.Task<AddonSchema> CreateAddonAsync(AddonCreateUpdateSchema body);

        /// <summary>
        /// Get a specific addon
        /// </summary>

        /// <remarks>
        /// Retrieve information about the addon whose ID matches the ID in the request URL.
        /// </remarks>

        /// <returns>addonSchema</returns>

        System.Threading.Tasks.Task<AddonSchema> GetAddonAsync(string id);

        /// <summary>
        /// Update an addon
        /// </summary>

        /// <remarks>
        /// Update the addon with a specific ID. Any fields in the update object will be updated. Properties that are not included in the update object will not be affected. To empty a property, pass `null` as that property's value.
        /// <br/>
        /// <br/>Note: passing `null` as a value for the description property will set it to an empty string.
        /// </remarks>

        /// <param name="body">addonCreateUpdateSchema</param>


        /// <returns>addonSchema</returns>

        System.Threading.Tasks.Task<AddonSchema> UpdateAddonAsync(AddonCreateUpdateSchema body, string id);

        /// <summary>
        /// Delete an addon
        /// </summary>

        /// <remarks>
        /// Delete the addon specified by the ID in the request path.
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task DeleteAddonAsync(string id);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class AddonsController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IAddonsController _implementation;

        public AddonsController(IAddonsController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Get all addons and providers
        /// </summary>
        /// <remarks>
        /// Retrieve all addons and providers that are defined on this Unleash instance.
        /// </remarks>
        /// <returns>addonsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/addons", Name = "getAddons")]
        public System.Threading.Tasks.Task<AddonsSchema> GetAddons()
        {

            return _implementation.GetAddonsAsync();
        }

        /// <summary>
        /// Create a new addon
        /// </summary>
        /// <remarks>
        /// Create an addon instance. The addon must use one of the providers available on this Unleash instance.
        /// </remarks>
        /// <param name="body">addonCreateUpdateSchema</param>
        /// <returns>addonSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/addons", Name = "createAddon")]
        public System.Threading.Tasks.Task<AddonSchema> CreateAddon([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AddonCreateUpdateSchema body)
        {

            return _implementation.CreateAddonAsync(body);
        }

        /// <summary>
        /// Get a specific addon
        /// </summary>
        /// <remarks>
        /// Retrieve information about the addon whose ID matches the ID in the request URL.
        /// </remarks>
        /// <returns>addonSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/addons/{id}", Name = "getAddon")]
        public System.Threading.Tasks.Task<AddonSchema> GetAddon([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string id)
        {

            return _implementation.GetAddonAsync(id);
        }

        /// <summary>
        /// Update an addon
        /// </summary>
        /// <remarks>
        /// Update the addon with a specific ID. Any fields in the update object will be updated. Properties that are not included in the update object will not be affected. To empty a property, pass `null` as that property's value.
        /// <br/>
        /// <br/>Note: passing `null` as a value for the description property will set it to an empty string.
        /// </remarks>
        /// <param name="body">addonCreateUpdateSchema</param>
        /// <returns>addonSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/addons/{id}", Name = "updateAddon")]
        public System.Threading.Tasks.Task<AddonSchema> UpdateAddon([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AddonCreateUpdateSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string id)
        {

            return _implementation.UpdateAddonAsync(body, id);
        }

        /// <summary>
        /// Delete an addon
        /// </summary>
        /// <remarks>
        /// Delete the addon specified by the ID in the request path.
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/addons/{id}", Name = "deleteAddon")]
        public System.Threading.Tasks.Task DeleteAddon([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string id)
        {

            return _implementation.DeleteAddonAsync(id);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IAPI_tokensController
    {

        /// <summary>
        /// Get API tokens
        /// </summary>

        /// <remarks>
        /// Retrieves all API tokens that exist in the Unleash instance.
        /// </remarks>

        /// <returns>apiTokensSchema</returns>

        System.Threading.Tasks.Task<ApiTokensSchema> GetAllApiTokensAsync();

        /// <summary>
        /// Create API token
        /// </summary>

        /// <remarks>
        /// Create an API token of a specific type: one of client, admin, frontend.
        /// </remarks>

        /// <param name="body">createApiTokenSchema</param>

        /// <returns>The resource was successfully created.</returns>

        System.Threading.Tasks.Task<ApiTokenSchema> CreateApiTokenAsync(CreateApiTokenSchema body);

        /// <summary>
        /// Get API tokens by name
        /// </summary>

        /// <remarks>
        /// Retrieves all API tokens that match a given token name. Because token names are not unique, this endpoint will always return a list. If no tokens with the provided name exist, the list will be empty. Otherwise, it will contain all the tokens with the given name.
        /// </remarks>

        /// <returns>apiTokensSchema</returns>

        System.Threading.Tasks.Task<ApiTokensSchema> GetApiTokensByNameAsync(string name);

        /// <summary>
        /// Update API token
        /// </summary>

        /// <remarks>
        /// Updates an existing API token with a new expiry date. The `token` path parameter is the token's `secret`. If the token does not exist, this endpoint returns a 200 OK, but does nothing.
        /// </remarks>

        /// <param name="body">updateApiTokenSchema</param>


        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task UpdateApiTokenAsync(UpdateApiTokenSchema body, string token);

        /// <summary>
        /// Delete API token
        /// </summary>

        /// <remarks>
        /// Deletes an existing API token. The `token` path parameter is the token's `secret`. If the token does not exist, this endpoint returns a 200 OK, but does nothing.
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task DeleteApiTokenAsync(string token);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class API_tokensController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IAPI_tokensController _implementation;

        public API_tokensController(IAPI_tokensController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Get API tokens
        /// </summary>
        /// <remarks>
        /// Retrieves all API tokens that exist in the Unleash instance.
        /// </remarks>
        /// <returns>apiTokensSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/api-tokens", Name = "getAllApiTokens")]
        public System.Threading.Tasks.Task<ApiTokensSchema> GetAllApiTokens()
        {

            return _implementation.GetAllApiTokensAsync();
        }

        /// <summary>
        /// Create API token
        /// </summary>
        /// <remarks>
        /// Create an API token of a specific type: one of client, admin, frontend.
        /// </remarks>
        /// <param name="body">createApiTokenSchema</param>
        /// <returns>The resource was successfully created.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/api-tokens", Name = "createApiToken")]
        public System.Threading.Tasks.Task<ApiTokenSchema> CreateApiToken([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateApiTokenSchema body)
        {

            return _implementation.CreateApiTokenAsync(body);
        }

        /// <summary>
        /// Get API tokens by name
        /// </summary>
        /// <remarks>
        /// Retrieves all API tokens that match a given token name. Because token names are not unique, this endpoint will always return a list. If no tokens with the provided name exist, the list will be empty. Otherwise, it will contain all the tokens with the given name.
        /// </remarks>
        /// <returns>apiTokensSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/api-tokens/{name}", Name = "getApiTokensByName")]
        public System.Threading.Tasks.Task<ApiTokensSchema> GetApiTokensByName([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string name)
        {

            return _implementation.GetApiTokensByNameAsync(name);
        }

        /// <summary>
        /// Update API token
        /// </summary>
        /// <remarks>
        /// Updates an existing API token with a new expiry date. The `token` path parameter is the token's `secret`. If the token does not exist, this endpoint returns a 200 OK, but does nothing.
        /// </remarks>
        /// <param name="body">updateApiTokenSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/api-tokens/{token}", Name = "updateApiToken")]
        public System.Threading.Tasks.Task UpdateApiToken([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateApiTokenSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string token)
        {

            return _implementation.UpdateApiTokenAsync(body, token);
        }

        /// <summary>
        /// Delete API token
        /// </summary>
        /// <remarks>
        /// Deletes an existing API token. The `token` path parameter is the token's `secret`. If the token does not exist, this endpoint returns a 200 OK, but does nothing.
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/api-tokens/{token}", Name = "deleteApiToken")]
        public System.Threading.Tasks.Task DeleteApiToken([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string token)
        {

            return _implementation.DeleteApiTokenAsync(token);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IProjectsController
    {

        /// <summary>
        /// Get a list of all projects.
        /// </summary>

        /// <remarks>
        /// This endpoint returns an list of all the projects in the Unleash instance.
        /// </remarks>

        /// <returns>projectsSchema</returns>

        System.Threading.Tasks.Task<ProjectsSchema> GetProjectsAsync();

        /// <summary>
        /// Get an overview of a project.
        /// </summary>

        /// <remarks>
        /// This endpoint returns an overview of the specified projects stats, project health, number of members, which environments are configured, and the features in the project.
        /// </remarks>

        /// <returns>projectOverviewSchema</returns>

        System.Threading.Tasks.Task<ProjectOverviewSchema> GetProjectOverviewAsync(string projectId);

        /// <summary>
        /// Add an environment to a project.
        /// </summary>

        /// <remarks>
        /// This endpoint adds the provided environment to the specified project, with optional support for enabling and disabling change requests for the environment and project.
        /// </remarks>

        /// <param name="body">projectEnvironmentSchema</param>


        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task AddEnvironmentToProjectAsync(ProjectEnvironmentSchema body, string projectId);

        /// <summary>
        /// Remove an environment from a project.
        /// </summary>

        /// <remarks>
        /// This endpoint removes the specified environment from the project.
        /// </remarks>



        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task RemoveEnvironmentFromProjectAsync(string projectId, string environment);

        /// <summary>
        /// Set environment-default strategy
        /// </summary>

        /// <remarks>
        /// Adds a default strategy for this environment. Unleash will use this strategy by default when enabling a toggle. Use the wild card "*" for `:environment` to add to all environments.
        /// </remarks>

        /// <param name="body">createFeatureStrategySchema</param>


        /// <returns>createFeatureStrategySchema</returns>

        System.Threading.Tasks.Task<CreateFeatureStrategySchema> AddDefaultStrategyToProjectEnvironmentAsync(CreateFeatureStrategySchema body, string projectId, string environment);

        /// <summary>
        /// Get a health report for a project.
        /// </summary>

        /// <remarks>
        /// This endpoint returns a health report for the specified project. This data is used for [the technical debt dashboard](https://docs.getunleash.io/reference/technical-debt#the-technical-debt-dashboard)
        /// </remarks>

        /// <returns>healthReportSchema</returns>

        System.Threading.Tasks.Task<HealthReportSchema> GetProjectHealthReportAsync(string projectId);

        /// <summary>
        /// Get api tokens for project.
        /// </summary>

        /// <remarks>
        /// Returns the [project API tokens](https://docs.getunleash.io/how-to/how-to-create-project-api-tokens) that have been created for this project.
        /// </remarks>

        /// <returns>apiTokensSchema</returns>

        System.Threading.Tasks.Task<ApiTokensSchema> GetProjectApiTokensAsync(string projectId);

        /// <summary>
        /// Create a project API token.
        /// </summary>

        /// <remarks>
        /// Endpoint that allows creation of [project API tokens](https://docs.getunleash.io/reference/api-tokens-and-client-keys#api-token-visibility) for the specified project.
        /// </remarks>

        /// <param name="body">createApiTokenSchema</param>


        /// <returns>The resource was successfully created.</returns>

        System.Threading.Tasks.Task<ApiTokenSchema> CreateProjectApiTokenAsync(CreateApiTokenSchema body, string projectId);

        /// <summary>
        /// Delete a project API token.
        /// </summary>

        /// <remarks>
        /// This operation deletes the API token specified in the request URL. If the token doesn't exist, returns an OK response (status code 200).
        /// </remarks>



        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task DeleteProjectApiTokenAsync(string projectId, string token);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class ProjectsController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IProjectsController _implementation;

        public ProjectsController(IProjectsController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Get a list of all projects.
        /// </summary>
        /// <remarks>
        /// This endpoint returns an list of all the projects in the Unleash instance.
        /// </remarks>
        /// <returns>projectsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/projects", Name = "getProjects")]
        public System.Threading.Tasks.Task<ProjectsSchema> GetProjects()
        {

            return _implementation.GetProjectsAsync();
        }

        /// <summary>
        /// Get an overview of a project.
        /// </summary>
        /// <remarks>
        /// This endpoint returns an overview of the specified projects stats, project health, number of members, which environments are configured, and the features in the project.
        /// </remarks>
        /// <returns>projectOverviewSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}", Name = "getProjectOverview")]
        public System.Threading.Tasks.Task<ProjectOverviewSchema> GetProjectOverview([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId)
        {

            return _implementation.GetProjectOverviewAsync(projectId);
        }

        /// <summary>
        /// Add an environment to a project.
        /// </summary>
        /// <remarks>
        /// This endpoint adds the provided environment to the specified project, with optional support for enabling and disabling change requests for the environment and project.
        /// </remarks>
        /// <param name="body">projectEnvironmentSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/environments", Name = "addEnvironmentToProject")]
        public System.Threading.Tasks.Task AddEnvironmentToProject([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ProjectEnvironmentSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId)
        {

            return _implementation.AddEnvironmentToProjectAsync(body, projectId);
        }

        /// <summary>
        /// Remove an environment from a project.
        /// </summary>
        /// <remarks>
        /// This endpoint removes the specified environment from the project.
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/environments/{environment}", Name = "removeEnvironmentFromProject")]
        public System.Threading.Tasks.Task RemoveEnvironmentFromProject([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment)
        {

            return _implementation.RemoveEnvironmentFromProjectAsync(projectId, environment);
        }

        /// <summary>
        /// Set environment-default strategy
        /// </summary>
        /// <remarks>
        /// Adds a default strategy for this environment. Unleash will use this strategy by default when enabling a toggle. Use the wild card "*" for `:environment` to add to all environments.
        /// </remarks>
        /// <param name="body">createFeatureStrategySchema</param>
        /// <returns>createFeatureStrategySchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/environments/{environment}/default-strategy", Name = "addDefaultStrategyToProjectEnvironment")]
        public System.Threading.Tasks.Task<CreateFeatureStrategySchema> AddDefaultStrategyToProjectEnvironment([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateFeatureStrategySchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string environment)
        {

            return _implementation.AddDefaultStrategyToProjectEnvironmentAsync(body, projectId, environment);
        }

        /// <summary>
        /// Get a health report for a project.
        /// </summary>
        /// <remarks>
        /// This endpoint returns a health report for the specified project. This data is used for [the technical debt dashboard](https://docs.getunleash.io/reference/technical-debt#the-technical-debt-dashboard)
        /// </remarks>
        /// <returns>healthReportSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/health-report", Name = "getProjectHealthReport")]
        public System.Threading.Tasks.Task<HealthReportSchema> GetProjectHealthReport([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId)
        {

            return _implementation.GetProjectHealthReportAsync(projectId);
        }

        /// <summary>
        /// Get api tokens for project.
        /// </summary>
        /// <remarks>
        /// Returns the [project API tokens](https://docs.getunleash.io/how-to/how-to-create-project-api-tokens) that have been created for this project.
        /// </remarks>
        /// <returns>apiTokensSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/api-tokens", Name = "getProjectApiTokens")]
        public System.Threading.Tasks.Task<ApiTokensSchema> GetProjectApiTokens([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId)
        {

            return _implementation.GetProjectApiTokensAsync(projectId);
        }

        /// <summary>
        /// Create a project API token.
        /// </summary>
        /// <remarks>
        /// Endpoint that allows creation of [project API tokens](https://docs.getunleash.io/reference/api-tokens-and-client-keys#api-token-visibility) for the specified project.
        /// </remarks>
        /// <param name="body">createApiTokenSchema</param>
        /// <returns>The resource was successfully created.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/api-tokens", Name = "createProjectApiToken")]
        public System.Threading.Tasks.Task<ApiTokenSchema> CreateProjectApiToken([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateApiTokenSchema body, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId)
        {

            return _implementation.CreateProjectApiTokenAsync(body, projectId);
        }

        /// <summary>
        /// Delete a project API token.
        /// </summary>
        /// <remarks>
        /// This operation deletes the API token specified in the request URL. If the token doesn't exist, returns an OK response (status code 200).
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("api/admin/projects/{projectId}/api-tokens/{token}", Name = "deleteProjectApiToken")]
        public System.Threading.Tasks.Task DeleteProjectApiToken([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId, [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string token)
        {

            return _implementation.DeleteProjectApiTokenAsync(projectId, token);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IEnvironmentsController
    {

        /// <summary>
        /// Get all environments
        /// </summary>

        /// <remarks>
        /// Retrieves all environments that exist in this Unleash instance.
        /// </remarks>

        /// <returns>environmentsSchema</returns>

        System.Threading.Tasks.Task<EnvironmentsSchema> GetAllEnvironmentsAsync();

        /// <summary>
        /// Get the environment with `name`
        /// </summary>

        /// <remarks>
        /// Retrieves the environment with `name` if it exists in this Unleash instance
        /// </remarks>

        /// <returns>environmentSchema</returns>

        System.Threading.Tasks.Task<EnvironmentSchema> GetEnvironmentAsync(string name);

        /// <summary>
        /// Get the environments available to a project
        /// </summary>

        /// <remarks>
        /// Gets the environments that are available for this project. An environment is available for a project if enabled in the [project configuration](https://docs.getunleash.io/reference/environments#step-1-enable-new-environments-for-your-project)
        /// </remarks>

        /// <returns>environmentsProjectSchema</returns>

        System.Threading.Tasks.Task<EnvironmentsProjectSchema> GetProjectEnvironmentsAsync(string projectId);

        /// <summary>
        /// Update environment sort orders
        /// </summary>

        /// <remarks>
        /// Updates sort orders for the named environments. Environments not specified are unaffected.
        /// </remarks>

        /// <param name="body">sortOrderSchema</param>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task UpdateSortOrderAsync(System.Collections.Generic.IDictionary<string, int> body);

        /// <summary>
        /// Toggle the environment with `name` on
        /// </summary>

        /// <remarks>
        /// Makes it possible to enable this environment for a project. An environment must first be globally enabled using this endpoint before it can be enabled for a project
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ToggleEnvironmentOnAsync(string name);

        /// <summary>
        /// Toggle the environment with `name` off
        /// </summary>

        /// <remarks>
        /// Removes this environment from the list of available environments for projects to use
        /// </remarks>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ToggleEnvironmentOffAsync(string name);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class EnvironmentsController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IEnvironmentsController _implementation;

        public EnvironmentsController(IEnvironmentsController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Get all environments
        /// </summary>
        /// <remarks>
        /// Retrieves all environments that exist in this Unleash instance.
        /// </remarks>
        /// <returns>environmentsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/environments", Name = "getAllEnvironments")]
        public System.Threading.Tasks.Task<EnvironmentsSchema> GetAllEnvironments()
        {

            return _implementation.GetAllEnvironmentsAsync();
        }

        /// <summary>
        /// Get the environment with `name`
        /// </summary>
        /// <remarks>
        /// Retrieves the environment with `name` if it exists in this Unleash instance
        /// </remarks>
        /// <returns>environmentSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/environments/{name}", Name = "getEnvironment")]
        public System.Threading.Tasks.Task<EnvironmentSchema> GetEnvironment([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string name)
        {

            return _implementation.GetEnvironmentAsync(name);
        }

        /// <summary>
        /// Get the environments available to a project
        /// </summary>
        /// <remarks>
        /// Gets the environments that are available for this project. An environment is available for a project if enabled in the [project configuration](https://docs.getunleash.io/reference/environments#step-1-enable-new-environments-for-your-project)
        /// </remarks>
        /// <returns>environmentsProjectSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/environments/project/{projectId}", Name = "getProjectEnvironments")]
        public System.Threading.Tasks.Task<EnvironmentsProjectSchema> GetProjectEnvironments([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string projectId)
        {

            return _implementation.GetProjectEnvironmentsAsync(projectId);
        }

        /// <summary>
        /// Update environment sort orders
        /// </summary>
        /// <remarks>
        /// Updates sort orders for the named environments. Environments not specified are unaffected.
        /// </remarks>
        /// <param name="body">sortOrderSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("api/admin/environments/sort-order", Name = "updateSortOrder")]
        public System.Threading.Tasks.Task UpdateSortOrder([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] System.Collections.Generic.IDictionary<string, int> body)
        {

            return _implementation.UpdateSortOrderAsync(body);
        }

        /// <summary>
        /// Toggle the environment with `name` on
        /// </summary>
        /// <remarks>
        /// Makes it possible to enable this environment for a project. An environment must first be globally enabled using this endpoint before it can be enabled for a project
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/environments/{name}/on", Name = "toggleEnvironmentOn")]
        public System.Threading.Tasks.Task ToggleEnvironmentOn([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string name)
        {

            return _implementation.ToggleEnvironmentOnAsync(name);
        }

        /// <summary>
        /// Toggle the environment with `name` off
        /// </summary>
        /// <remarks>
        /// Removes this environment from the list of available environments for projects to use
        /// </remarks>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/environments/{name}/off", Name = "toggleEnvironmentOff")]
        public System.Threading.Tasks.Task ToggleEnvironmentOff([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string name)
        {

            return _implementation.ToggleEnvironmentOffAsync(name);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IInstance_AdminController
    {

        /// <summary>
        /// Instance usage statistics
        /// </summary>

        /// <remarks>
        /// Provides statistics about various features of Unleash to allow for reporting of usage for self-hosted customers. The response contains data such as the number of users, groups, features, strategies, versions, etc.
        /// </remarks>

        /// <returns>instanceAdminStatsSchemaCsv</returns>

        System.Threading.Tasks.Task<string> GetInstanceAdminStatsCsvAsync();

        /// <summary>
        /// Instance usage statistics
        /// </summary>

        /// <remarks>
        /// Provides statistics about various features of Unleash to allow for reporting of usage for self-hosted customers. The response contains data such as the number of users, groups, features, strategies, versions, etc.
        /// </remarks>

        /// <returns>instanceAdminStatsSchema</returns>

        [System.Obsolete]

        System.Threading.Tasks.Task<InstanceAdminStatsSchema> GetInstanceAdminStatsAsync();

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class Instance_AdminController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IInstance_AdminController _implementation;

        public Instance_AdminController(IInstance_AdminController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Instance usage statistics
        /// </summary>
        /// <remarks>
        /// Provides statistics about various features of Unleash to allow for reporting of usage for self-hosted customers. The response contains data such as the number of users, groups, features, strategies, versions, etc.
        /// </remarks>
        /// <returns>instanceAdminStatsSchemaCsv</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/instance-admin/statistics/csv", Name = "getInstanceAdminStatsCsv")]
        public System.Threading.Tasks.Task<string> GetInstanceAdminStatsCsv()
        {

            return _implementation.GetInstanceAdminStatsCsvAsync();
        }

        /// <summary>
        /// Instance usage statistics
        /// </summary>
        /// <remarks>
        /// Provides statistics about various features of Unleash to allow for reporting of usage for self-hosted customers. The response contains data such as the number of users, groups, features, strategies, versions, etc.
        /// </remarks>
        /// <returns>instanceAdminStatsSchema</returns>
        [System.Obsolete]
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/instance-admin/statistics", Name = "getInstanceAdminStats")]
        public System.Threading.Tasks.Task<InstanceAdminStatsSchema> GetInstanceAdminStats()
        {

            return _implementation.GetInstanceAdminStatsAsync();
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IMaintenanceController
    {

        /// <summary>
        /// Enabled/disabled maintenance mode
        /// </summary>

        /// <remarks>
        /// Lets administrators put Unleash into a mostly read-only mode. While Unleash is in maintenance mode, users can not change any configuration settings
        /// </remarks>

        /// <param name="body">toggleMaintenanceSchema</param>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task ToggleMaintenanceAsync(ToggleMaintenanceSchema body);

        /// <summary>
        /// Get maintenance mode status
        /// </summary>

        /// <remarks>
        /// Tells you whether maintenance mode is enabled or disabled
        /// </remarks>

        /// <returns>maintenanceSchema</returns>

        System.Threading.Tasks.Task<MaintenanceSchema> GetMaintenanceAsync();

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class MaintenanceController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IMaintenanceController _implementation;

        public MaintenanceController(IMaintenanceController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Enabled/disabled maintenance mode
        /// </summary>
        /// <remarks>
        /// Lets administrators put Unleash into a mostly read-only mode. While Unleash is in maintenance mode, users can not change any configuration settings
        /// </remarks>
        /// <param name="body">toggleMaintenanceSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/admin/maintenance", Name = "toggleMaintenance")]
        public System.Threading.Tasks.Task ToggleMaintenance([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ToggleMaintenanceSchema body)
        {

            return _implementation.ToggleMaintenanceAsync(body);
        }

        /// <summary>
        /// Get maintenance mode status
        /// </summary>
        /// <remarks>
        /// Tells you whether maintenance mode is enabled or disabled
        /// </remarks>
        /// <returns>maintenanceSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/maintenance", Name = "getMaintenance")]
        public System.Threading.Tasks.Task<MaintenanceSchema> GetMaintenance()
        {

            return _implementation.GetMaintenanceAsync();
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface ITelemetryController
    {

        /// <summary>
        /// Get telemetry settings
        /// </summary>

        /// <remarks>
        /// Provides the configured settings for [telemetry information collection](https://docs.getunleash.io/topics/data-collection)
        /// </remarks>

        /// <returns>telemetrySettingsSchema</returns>

        System.Threading.Tasks.Task<TelemetrySettingsSchema> GetTelemetrySettingsAsync();

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class TelemetryController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private ITelemetryController _implementation;

        public TelemetryController(ITelemetryController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Get telemetry settings
        /// </summary>
        /// <remarks>
        /// Provides the configured settings for [telemetry information collection](https://docs.getunleash.io/topics/data-collection)
        /// </remarks>
        /// <returns>telemetrySettingsSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/admin/telemetry/settings", Name = "getTelemetrySettings")]
        public System.Threading.Tasks.Task<TelemetrySettingsSchema> GetTelemetrySettings()
        {

            return _implementation.GetTelemetrySettingsAsync();
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IClientController
    {

        /// <summary>
        /// Get a single feature toggle
        /// </summary>

        /// <remarks>
        /// Gets all the client data for a single toggle. Contains the exact same information about a toggle as the `/api/client/features` endpoint does, but only contains data about the specified toggle. All SDKs should use `/api/client/features`
        /// </remarks>

        /// <returns>clientFeatureSchema</returns>

        System.Threading.Tasks.Task<ClientFeatureSchema> GetClientFeatureAsync(string featureName);

        /// <summary>
        /// Get all toggles (SDK)
        /// </summary>

        /// <remarks>
        /// Returns the SDK configuration for all feature toggles that are available to the provided API key. Used by SDKs to configure local evaluation
        /// </remarks>

        /// <returns>clientFeaturesSchema</returns>

        System.Threading.Tasks.Task<ClientFeaturesSchema> GetAllClientFeaturesAsync();

        /// <summary>
        /// Register client usage metrics
        /// </summary>

        /// <remarks>
        /// Registers usage metrics. Stores information about how many times each toggle was evaluated to enabled and disabled within a time frame. If provided, this operation will also store data on how many times each feature toggle's variants were displayed to the end user.
        /// </remarks>

        /// <param name="body">clientMetricsSchema</param>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task RegisterClientMetricsAsync(ClientMetricsSchema body);

        /// <summary>
        /// Register a client SDK
        /// </summary>

        /// <remarks>
        /// Register a client SDK with Unleash. SDKs call this endpoint on startup to tell Unleash about their existence. Used to track custom strategies in use as well as SDK versions.
        /// </remarks>

        /// <param name="body">clientApplicationSchema</param>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task RegisterClientApplicationAsync(ClientApplicationSchema body);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class ClientController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IClientController _implementation;

        public ClientController(IClientController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Get a single feature toggle
        /// </summary>
        /// <remarks>
        /// Gets all the client data for a single toggle. Contains the exact same information about a toggle as the `/api/client/features` endpoint does, but only contains data about the specified toggle. All SDKs should use `/api/client/features`
        /// </remarks>
        /// <returns>clientFeatureSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/client/features/{featureName}", Name = "getClientFeature")]
        public System.Threading.Tasks.Task<ClientFeatureSchema> GetClientFeature([Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string featureName)
        {

            return _implementation.GetClientFeatureAsync(featureName);
        }

        /// <summary>
        /// Get all toggles (SDK)
        /// </summary>
        /// <remarks>
        /// Returns the SDK configuration for all feature toggles that are available to the provided API key. Used by SDKs to configure local evaluation
        /// </remarks>
        /// <returns>clientFeaturesSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/client/features", Name = "getAllClientFeatures")]
        public System.Threading.Tasks.Task<ClientFeaturesSchema> GetAllClientFeatures()
        {

            return _implementation.GetAllClientFeaturesAsync();
        }

        /// <summary>
        /// Register client usage metrics
        /// </summary>
        /// <remarks>
        /// Registers usage metrics. Stores information about how many times each toggle was evaluated to enabled and disabled within a time frame. If provided, this operation will also store data on how many times each feature toggle's variants were displayed to the end user.
        /// </remarks>
        /// <param name="body">clientMetricsSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/client/metrics", Name = "registerClientMetrics")]
        public System.Threading.Tasks.Task RegisterClientMetrics([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ClientMetricsSchema body)
        {

            return _implementation.RegisterClientMetricsAsync(body);
        }

        /// <summary>
        /// Register a client SDK
        /// </summary>
        /// <remarks>
        /// Register a client SDK with Unleash. SDKs call this endpoint on startup to tell Unleash about their existence. Used to track custom strategies in use as well as SDK versions.
        /// </remarks>
        /// <param name="body">clientApplicationSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/client/register", Name = "registerClientApplication")]
        public System.Threading.Tasks.Task RegisterClientApplication([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ClientApplicationSchema body)
        {

            return _implementation.RegisterClientApplicationAsync(body);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IFrontend_APIController
    {

        /// <summary>
        /// Retrieve enabled feature toggles for the provided context.
        /// </summary>

        /// <remarks>
        /// This endpoint returns the list of feature toggles that the proxy evaluates to enabled for the given context. Context values are provided as query parameters. If the Frontend API is disabled 404 is returned.
        /// </remarks>

        /// <returns>proxyFeaturesSchema</returns>

        System.Threading.Tasks.Task<ProxyFeaturesSchema> GetFrontendFeaturesAsync();

        /// <summary>
        /// Register client usage metrics
        /// </summary>

        /// <remarks>
        /// Registers usage metrics. Stores information about how many times each toggle was evaluated to enabled and disabled within a time frame. If provided, this operation will also store data on how many times each feature toggle's variants were displayed to the end user. If the Frontend API is disabled 404 is returned.
        /// </remarks>

        /// <param name="body">clientMetricsSchema</param>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task RegisterFrontendMetricsAsync(ClientMetricsSchema body);

        /// <summary>
        /// Register a client SDK
        /// </summary>

        /// <remarks>
        /// This is for future use. Currently Frontend client registration is not supported. Returning 200 for clients that expect this status code. If the Frontend API is disabled 404 is returned.
        /// </remarks>

        /// <param name="body">proxyClientSchema</param>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task RegisterFrontendClientAsync(ProxyClientSchema body);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class Frontend_APIController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IFrontend_APIController _implementation;

        public Frontend_APIController(IFrontend_APIController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Retrieve enabled feature toggles for the provided context.
        /// </summary>
        /// <remarks>
        /// This endpoint returns the list of feature toggles that the proxy evaluates to enabled for the given context. Context values are provided as query parameters. If the Frontend API is disabled 404 is returned.
        /// </remarks>
        /// <returns>proxyFeaturesSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("api/frontend", Name = "getFrontendFeatures")]
        public System.Threading.Tasks.Task<ProxyFeaturesSchema> GetFrontendFeatures()
        {

            return _implementation.GetFrontendFeaturesAsync();
        }

        /// <summary>
        /// Register client usage metrics
        /// </summary>
        /// <remarks>
        /// Registers usage metrics. Stores information about how many times each toggle was evaluated to enabled and disabled within a time frame. If provided, this operation will also store data on how many times each feature toggle's variants were displayed to the end user. If the Frontend API is disabled 404 is returned.
        /// </remarks>
        /// <param name="body">clientMetricsSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/frontend/client/metrics", Name = "registerFrontendMetrics")]
        public System.Threading.Tasks.Task RegisterFrontendMetrics([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ClientMetricsSchema body)
        {

            return _implementation.RegisterFrontendMetricsAsync(body);
        }

        /// <summary>
        /// Register a client SDK
        /// </summary>
        /// <remarks>
        /// This is for future use. Currently Frontend client registration is not supported. Returning 200 for clients that expect this status code. If the Frontend API is disabled 404 is returned.
        /// </remarks>
        /// <param name="body">proxyClientSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("api/frontend/client/register", Name = "registerFrontendClient")]
        public System.Threading.Tasks.Task RegisterFrontendClient([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ProxyClientSchema body)
        {

            return _implementation.RegisterFrontendClientAsync(body);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IEdgeController
    {

        /// <summary>
        /// Check which tokens are valid
        /// </summary>

        /// <remarks>
        /// This operation accepts a list of tokens to validate. Unleash will validate each token you provide. For each valid token you provide, Unleash will return the token along with its type and which projects it has access to.
        /// </remarks>

        /// <param name="body">tokenStringListSchema</param>

        /// <returns>validatedEdgeTokensSchema</returns>

        System.Threading.Tasks.Task<ValidatedEdgeTokensSchema> GetValidTokensAsync(TokenStringListSchema body);

        /// <summary>
        /// Send metrics from Edge
        /// </summary>

        /// <remarks>
        /// This operation accepts batched metrics from Edge. Metrics will be inserted into Unleash's metrics storage
        /// </remarks>

        /// <param name="body">bulkMetricsSchema</param>

        /// <returns>This response has no body.</returns>

        System.Threading.Tasks.Task BulkMetricsAsync(BulkMetricsSchema body);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class EdgeController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IEdgeController _implementation;

        public EdgeController(IEdgeController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Check which tokens are valid
        /// </summary>
        /// <remarks>
        /// This operation accepts a list of tokens to validate. Unleash will validate each token you provide. For each valid token you provide, Unleash will return the token along with its type and which projects it has access to.
        /// </remarks>
        /// <param name="body">tokenStringListSchema</param>
        /// <returns>validatedEdgeTokensSchema</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("edge/validate", Name = "getValidTokens")]
        public System.Threading.Tasks.Task<ValidatedEdgeTokensSchema> GetValidTokens([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] TokenStringListSchema body)
        {

            return _implementation.GetValidTokensAsync(body);
        }

        /// <summary>
        /// Send metrics from Edge
        /// </summary>
        /// <remarks>
        /// This operation accepts batched metrics from Edge. Metrics will be inserted into Unleash's metrics storage
        /// </remarks>
        /// <param name="body">bulkMetricsSchema</param>
        /// <returns>This response has no body.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("edge/metrics", Name = "bulkMetrics")]
        public System.Threading.Tasks.Task BulkMetrics([Microsoft.AspNetCore.Mvc.FromBody][Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BulkMetricsSchema body)
        {

            return _implementation.BulkMetricsAsync(body);
        }

    }

    /// <summary>
    /// Contains total admin counts for an Unleash instance.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AdminCountSchema
    {
        /// <summary>
        /// Total number of admins that have a password set.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        public double Password { get; set; }

        /// <summary>
        /// Total number of admins that do not have a password set. May be SSO, but may also be users that did not set a password yet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("noPassword", Required = Newtonsoft.Json.Required.Always)]
        public double NoPassword { get; set; }

        /// <summary>
        /// Total number of service accounts that have the admin root role.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service", Required = Newtonsoft.Json.Required.Always)]
        public double Service { get; set; }

    }

    /// <summary>
    /// Query parameters used to modify the list of features returned.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AdminFeaturesQuerySchema
    {
        /// <summary>
        /// Used to filter by tags. For each entry, a TAGTYPE:TAGVALUE is expected
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Tag { get; set; }

        /// <summary>
        /// A case-insensitive prefix filter for the names of feature toggles
        /// </summary>
        [Newtonsoft.Json.JsonProperty("namePrefix", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NamePrefix { get; set; }

    }

    /// <summary>
    /// An addon parameter definition.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AddonParameterSchema
    {
        /// <summary>
        /// The name of the parameter as it is used in code. References to this parameter should use this value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The name of the parameter as it is shown to the end user in the Admin UI.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DisplayName { get; set; }

        /// <summary>
        /// The type of the parameter. Corresponds roughly to [HTML `input` field types](https://developer.mozilla.org/docs/Web/HTML/Element/Input#input_types). Multi-line inut fields are indicated as `textfield` (equivalent to the HTML `textarea` tag).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }

        /// <summary>
        /// A description of the parameter. This should explain to the end user what the parameter is used for.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// The default value for this parameter. This value is used if no other value is provided.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("placeholder", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Placeholder { get; set; }

        /// <summary>
        /// Whether this parameter is required or not. If a parameter is required, you must give it a value when you create the addon. If it is not required it can be left out. It may receive a default value in those cases.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("required", Required = Newtonsoft.Json.Required.Always)]
        public bool Required { get; set; }

        /// <summary>
        /// Indicates whether this parameter is **sensitive** or not. Unleash will not return sensitive parameters to API requests. It will instead use a number of asterisks to indicate that a value is set, e.g. "******". The number of asterisks does not correlate to the parameter's value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sensitive", Required = Newtonsoft.Json.Required.Always)]
        public bool Sensitive { get; set; }

    }

    /// <summary>
    /// An [addon](https://docs.getunleash.io/reference/addons) instance description. Contains data about what kind of provider it uses, whether it's enabled or not, what events it listens for, and more.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AddonSchema
    {
        /// <summary>
        /// The addon's unique identifier.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1, int.MaxValue)]
        public int Id { get; set; }

        /// <summary>
        /// The addon provider, such as "webhook" or "slack".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provider", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Provider { get; set; }

        /// <summary>
        /// A description of the addon. `null` if no description exists.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.AllowNull)]
        public string Description { get; set; }

        /// <summary>
        /// Whether the addon is enabled or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }

        /// <summary>
        /// Parameters for the addon provider. This object has different required and optional properties depending on the provider you choose.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IDictionary<string, object> Parameters { get; set; } = new System.Collections.Generic.Dictionary<string, object>();

        /// <summary>
        /// The event types that trigger this specific addon.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Events { get; set; } = new System.Collections.Generic.List<string>();

        /// <summary>
        /// The projects that this addon listens to events from. An empty list means it listens to events from **all** projects.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projects", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Projects { get; set; }

        /// <summary>
        /// The list of environments that this addon listens to events from. An empty list means it listens to events from **all** environments.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environments", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Environments { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Data required to create or update an [Unleash addon](https://docs.getunleash.io/reference/addons) instance.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AddonCreateUpdateSchema
    {
        /// <summary>
        /// The addon provider, such as "webhook" or "slack". This string is **case sensitive** and maps to the provider's `name` property.
        /// <br/>
        /// <br/>The list of all supported providers and their parameters for a specific Unleash instance can be found by making a GET request to the `api/admin/addons` endpoint: the `providers` property of that response will contain all available providers.
        /// <br/>
        /// <br/>The default set of providers can be found in the [addons reference documentation](https://docs.getunleash.io/reference/addons). The default supported options are:
        /// <br/>- `datadog` for [Datadog](https://docs.getunleash.io/reference/addons/datadog)
        /// <br/>- `slack` for [Slack](https://docs.getunleash.io/reference/addons/slack)
        /// <br/>- `teams` for [Microsoft Teams](https://docs.getunleash.io/reference/addons/teams)
        /// <br/>- `webhook` for [webhooks](https://docs.getunleash.io/reference/addons/webhook)
        /// <br/>
        /// <br/>The provider you choose for your addon dictates what properties the `parameters` object needs. Refer to the documentation for each provider for more information.
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provider", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Provider { get; set; }

        /// <summary>
        /// A description of the addon.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// Whether the addon should be enabled or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }

        /// <summary>
        /// Parameters for the addon provider. This object has different required and optional properties depending on the provider you choose. Consult the documentation for details.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IDictionary<string, object> Parameters { get; set; } = new System.Collections.Generic.Dictionary<string, object>();

        /// <summary>
        /// The event types that will trigger this specific addon.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Events { get; set; } = new System.Collections.Generic.List<string>();

        /// <summary>
        /// The projects that this addon will listen to events from. An empty list means it will listen to events from **all** projects.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projects", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Projects { get; set; }

        /// <summary>
        /// The list of environments that this addon will listen to events from. An empty list means it will listen to events from **all** environments.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environments", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Environments { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// An object containing two things:
    /// <br/>1. A list of all [addons](https://docs.getunleash.io/reference/addons) defined on this Unleash instance
    /// <br/>2. A list of all addon providers defined on this instance
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AddonsSchema
    {
        /// <summary>
        /// All the addons that exist on this instance of Unleash.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("addons", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<AddonSchema> Addons { get; set; } = new System.Collections.Generic.List<AddonSchema>();

        /// <summary>
        /// A list of  all available addon providers, along with their parameters and descriptions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("providers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<AddonTypeSchema> Providers { get; set; } = new System.Collections.Generic.List<AddonTypeSchema>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// An addon provider. Defines a specific addon type and what the end user must configure when creating a new addon of that type.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AddonTypeSchema
    {
        /// <summary>
        /// The name of the addon type. When creating new addons, this goes in the payload's `type` field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The addon type's name as it should be displayed in the admin UI.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DisplayName { get; set; }

        /// <summary>
        /// A URL to where you can find more information about using this addon type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("documentationUrl", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DocumentationUrl { get; set; }

        /// <summary>
        /// A description of the addon type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        /// <summary>
        /// A list of [Unleash tag types](https://docs.getunleash.io/reference/tags#tag-types) that this addon uses. These tags will be added to the Unleash instance when an addon of this type is created.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tagTypes", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<TagTypeSchema> TagTypes { get; set; }

        /// <summary>
        /// The addon provider's parameters. Use these to configure an addon of this provider type. Items with `required: true` must be provided.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<AddonParameterSchema> Parameters { get; set; }

        /// <summary>
        /// All the [event types](https://docs.getunleash.io/reference/api/legacy/unleash/admin/events#feature-toggle-events) that are available for this addon provider.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Events { get; set; }

        /// <summary>
        /// The installation configuration for this addon type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("installation", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Installation Installation { get; set; }

        /// <summary>
        /// A list of alerts to display to the user when installing addons of this type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("alerts", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Alerts> Alerts { get; set; }

        /// <summary>
        /// This should be used to inform the user that this addon type is deprecated and should not be used. Deprecated addons will show a badge with this information on the UI.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("deprecated", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Deprecated { get; set; }

    }

    /// <summary>
    /// A simplified feature toggle model intended for the Unleash playground.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AdvancedPlaygroundEnvironmentFeatureSchema
    {
        /// <summary>
        /// The feature's name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The feature's environment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Environment { get; set; }

        /// <summary>
        /// The context to use when evaluating toggles
        /// </summary>
        [Newtonsoft.Json.JsonProperty("context", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SdkContextSchema Context { get; set; } = new SdkContextSchema();

        /// <summary>
        /// The ID of the project that contains this feature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projectId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ProjectId { get; set; }

        /// <summary>
        /// Feature's applicable strategies and cumulative results of the strategies
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategies", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Strategies2 Strategies { get; set; } = new Strategies2();

        /// <summary>
        /// Whether the feature is active and would be evaluated in the provided environment in a normal SDK context.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isEnabledInCurrentEnvironment", Required = Newtonsoft.Json.Required.Always)]
        public bool IsEnabledInCurrentEnvironment { get; set; }

        /// <summary>
        /// Whether this feature is enabled or not in the current environment.
        /// <br/>                          If a feature can't be fully evaluated (that is, `strategies.result` is `unknown`),
        /// <br/>                          this will be `false` to align with how client SDKs treat unresolved feature states.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isEnabled", Required = Newtonsoft.Json.Required.Always)]
        public bool IsEnabled { get; set; }

        /// <summary>
        /// The feature variant you receive based on the provided context or the _disabled
        /// <br/>                          variant_. If a feature is disabled or doesn't have any
        /// <br/>                          variants, you would get the _disabled variant_.
        /// <br/>                          Otherwise, you'll get one of the feature's defined variants.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variant", Required = Newtonsoft.Json.Required.AllowNull)]
        public Variant Variant { get; set; }

        /// <summary>
        /// The feature variants.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variants", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<VariantSchema> Variants { get; set; } = new System.Collections.Generic.List<VariantSchema>();

    }

    /// <summary>
    /// A simplified feature toggle model intended for the Unleash playground.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AdvancedPlaygroundFeatureSchema
    {
        /// <summary>
        /// The feature's name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The ID of the project that contains this feature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projectId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ProjectId { get; set; }

        /// <summary>
        /// The lists of features that have been evaluated grouped by environment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environments", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<AdvancedPlaygroundEnvironmentFeatureSchema>> Environments { get; set; } = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.List<AdvancedPlaygroundEnvironmentFeatureSchema>>();

    }

    /// <summary>
    /// Data for the playground API to evaluate toggles in advanced mode with environment and context multi selection
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AdvancedPlaygroundRequestSchema
    {
        /// <summary>
        /// The environments to evaluate toggles in.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environments", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        public System.Collections.Generic.List<string> Environments { get; set; } = new System.Collections.Generic.List<string>();

        /// <summary>
        /// A list of projects to check for toggles in.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projects", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Projects { get; set; }

        [Newtonsoft.Json.JsonProperty("context", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SdkContextSchema Context { get; set; } = new SdkContextSchema();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// The state of all features given the provided input.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AdvancedPlaygroundResponseSchema
    {
        /// <summary>
        /// The given input used to evaluate the features.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("input", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public AdvancedPlaygroundRequestSchema Input { get; set; } = new AdvancedPlaygroundRequestSchema();

        /// <summary>
        /// The list of features that have been evaluated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<AdvancedPlaygroundFeatureSchema> Features { get; set; } = new System.Collections.Generic.List<AdvancedPlaygroundFeatureSchema>();

    }

    /// <summary>
    /// An overview of an [Unleash API token](https://docs.getunleash.io/reference/api-tokens-and-client-keys).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiTokenSchema
    {
        /// <summary>
        /// The token used for authentication.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Secret { get; set; }

        /// <summary>
        /// This property was deprecated in Unleash v5. Prefer the `tokenName` property instead.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.Obsolete]
        public string Username { get; set; }

        /// <summary>
        /// A unique name for this particular token
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokenName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TokenName { get; set; }

        /// <summary>
        /// The type of API token
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApiTokenSchemaType Type { get; set; }

        /// <summary>
        /// The environment the token has access to. `*` if it has access to all environments.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Environment { get; set; }

        /// <summary>
        /// The project this token belongs to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Project { get; set; }

        /// <summary>
        /// The list of projects this token has access to. If the token has access to specific projects they will be listed here. If the token has access to all projects it will be represented as `[*]`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projects", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Projects { get; set; } = new System.Collections.Generic.List<string>();

        /// <summary>
        /// The token's expiration date. NULL if the token doesn't have an expiration set.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expiresAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ExpiresAt { get; set; }

        /// <summary>
        /// When the token was created.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset CreatedAt { get; set; }

        /// <summary>
        /// When the token was last seen/used to authenticate with. NULL if the token has not yet been used for authentication.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seenAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? SeenAt { get; set; }

        /// <summary>
        /// Alias is no longer in active use and will often be NULL. It's kept around as a way of allowing old proxy tokens created with the old metadata format to keep working.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("alias", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Alias { get; set; }

    }

    /// <summary>
    /// An object with [Unleash API tokens](https://docs.getunleash.io/reference/api-tokens-and-client-keys)
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiTokensSchema
    {
        /// <summary>
        /// A list of Unleash API tokens.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokens", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<ApiTokenSchema> Tokens { get; set; } = new System.Collections.Generic.List<ApiTokenSchema>();

    }

    /// <summary>
    /// Data about an application that's connected to Unleash via an SDK.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApplicationSchema
    {
        /// <summary>
        /// Name of the application
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AppName { get; set; }

        /// <summary>
        /// Which SDK and version the application reporting uses. Typically represented as `&lt;identifier&gt;:&lt;version&gt;`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sdkVersion", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SdkVersion { get; set; }

        /// <summary>
        /// Which [strategies](https://docs.getunleash.io/topics/the-anatomy-of-unleash#activation-strategies) the application has loaded. Useful when trying to figure out if your [custom strategy](https://docs.getunleash.io/reference/custom-activation-strategies) has been loaded in the SDK
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategies", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Strategies { get; set; }

        /// <summary>
        /// Extra information added about the application reporting the metrics. Only present if added via the Unleash Admin interface
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// A link to reference the application reporting the metrics. Could for instance be a GitHub link to the repository of the application
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        /// <summary>
        /// The CSS color that is used to color the application's entry in the application list
        /// </summary>
        [Newtonsoft.Json.JsonProperty("color", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Color { get; set; }

        /// <summary>
        /// An URL to an icon file to be used for the applications's entry in the application list
        /// </summary>
        [Newtonsoft.Json.JsonProperty("icon", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Icon { get; set; }

        /// <summary>
        /// The list of projects the application has been using.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("usage", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ApplicationUsageSchema> Usage { get; set; }

    }

    /// <summary>
    /// Data about an project that have been used by applications.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApplicationUsageSchema
    {
        /// <summary>
        /// Name of the project
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Project { get; set; }

        /// <summary>
        /// Which environments have been accessed in this project.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environments", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Environments { get; set; } = new System.Collections.Generic.List<string>();

    }

    /// <summary>
    /// An object containing a list of applications that have connected to Unleash via an SDK.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApplicationsSchema
    {
        /// <summary>
        /// The list of applications that have connected to this Unleash instance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("applications", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ApplicationSchema> Applications { get; set; }

    }

    /// <summary>
    /// A list of feature toggle names for batch operations
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BatchFeaturesSchema
    {
        /// <summary>
        /// List of feature toggle names
        /// </summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Features { get; set; } = new System.Collections.Generic.List<string>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// A list of features to operate on and whether they should be marked as stale or as not stale.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BatchStaleSchema
    {
        /// <summary>
        /// A list of features to mark as (not) stale
        /// </summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Features { get; set; } = new System.Collections.Generic.List<string>();

        /// <summary>
        /// Whether the list of features should be marked as stale or not stale. If `true`, the features will be marked as stale. If `false`, the features will be marked as not stale.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stale", Required = Newtonsoft.Json.Required.Always)]
        public bool Stale { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// An application registration. Defines the format POSTed by our server-side SDKs when they're starting up
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BulkRegistrationSchema
    {
        /// <summary>
        /// A list of applications this app registration has been registered through. If connected directly to Unleash, this is an empty list. 
        /// <br/> This can be used in later visualizations to tell how many levels of proxy or Edge instances our SDKs have connected through
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connectVia", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConnectVia> ConnectVia { get; set; }

        /// <summary>
        /// The name of the application that is evaluating toggles
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AppName { get; set; }

        /// <summary>
        /// Which environment the application is running in
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Environment { get; set; }

        /// <summary>
        /// A [(somewhat) unique identifier](https://docs.getunleash.io/reference/sdks/node#advanced-usage) for the application
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instanceId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string InstanceId { get; set; }

        /// <summary>
        /// How often (in seconds) the application refreshes its features
        /// </summary>
        [Newtonsoft.Json.JsonProperty("interval", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Interval { get; set; }

        /// <summary>
        /// The application started at
        /// </summary>
        [Newtonsoft.Json.JsonProperty("started", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset Started { get; set; }

        /// <summary>
        /// Enabled [strategies](https://docs.getunleash.io/reference/activation-strategies) in the application
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategies", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Strategies { get; set; }

        /// <summary>
        /// The version the sdk is running. Typically &lt;client&gt;:&lt;version&gt;
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sdkVersion", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SdkVersion { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// A batch of metrics accumulated by Edge (or other compatible applications). Includes both application registrations as well usage metrics from clients
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BulkMetricsSchema
    {
        /// <summary>
        /// A list of applications registered by an Unleash SDK
        /// </summary>
        [Newtonsoft.Json.JsonProperty("applications", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<BulkRegistrationSchema> Applications { get; set; } = new System.Collections.Generic.List<BulkRegistrationSchema>();

        /// <summary>
        /// a list of client usage metrics registered by downstream providers. (Typically Unleash Edge)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("metrics", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<ClientMetricsEnvSchema> Metrics { get; set; } = new System.Collections.Generic.List<ClientMetricsEnvSchema>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// The feature list used for bulk toggle operations
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BulkToggleFeaturesSchema
    {
        /// <summary>
        /// The features that we want to bulk toggle
        /// </summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Features { get; set; } = new System.Collections.Generic.List<string>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Change password as long as the token is a valid token
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ChangePasswordSchema
    {
        /// <summary>
        /// A reset token used to validate that the user is allowed to change the password.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Token { get; set; }

        /// <summary>
        /// The new password for the user
        /// </summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }

    }

    /// <summary>
    /// A client application is an instance of one of our SDKs
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClientApplicationSchema
    {
        /// <summary>
        /// An identifier for the app that uses the sdk, should be static across SDK restarts
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AppName { get; set; }

        /// <summary>
        /// A unique identifier identifying the instance of the application running the SDK. Often changes based on execution environment. For instance: two pods in Kubernetes will have two different instanceIds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instanceId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InstanceId { get; set; }

        /// <summary>
        /// An SDK version identifier. Usually formatted as "unleash-client-&lt;language&gt;:&lt;version&gt;"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sdkVersion", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SdkVersion { get; set; }

        /// <summary>
        /// The SDK's configured 'environment' property. Deprecated. This property  does **not** control which Unleash environment the SDK gets toggles for. To control Unleash environments, use the SDKs API key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.Obsolete]
        public string Environment { get; set; }

        /// <summary>
        /// How often (in seconds) does the client refresh its toggles
        /// </summary>
        [Newtonsoft.Json.JsonProperty("interval", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double Interval { get; set; }

        /// <summary>
        /// Either an RFC-3339 timestamp or a unix timestamp in seconds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("started", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Started { get; set; }

        /// <summary>
        /// Which strategies the SDKs runtime knows about
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategies", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Strategies { get; set; } = new System.Collections.Generic.List<string>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Feature toggle configuration used by SDKs to evaluate state of a toggle
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClientFeatureSchema
    {
        /// <summary>
        /// The unique name of a feature toggle. Is validated to be URL safe on creation
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// What kind of feature flag is this. Refer to the documentation on [feature toggle types](https://docs.getunleash.io/reference/feature-toggle-types) for more information
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// A description of the toggle
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// Whether the feature flag is enabled for the current API key or not. This is ANDed with the evaluation results of the strategies list, so if this is false, the evaluation result will always be false
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }

        /// <summary>
        /// If this is true Unleash believes this feature toggle has been active longer than Unleash expects a toggle of this type to be active
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stale", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Stale { get; set; }

        /// <summary>
        /// Set to true if SDKs should trigger [impression events](https://docs.getunleash.io/reference/impression-data) when this toggle is evaluated
        /// </summary>
        [Newtonsoft.Json.JsonProperty("impressionData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ImpressionData { get; set; }

        /// <summary>
        /// Which project this feature toggle belongs to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Project { get; set; }

        /// <summary>
        /// Evaluation strategies for this toggle. Each entry in this list will be evaluated and ORed together
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategies", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<FeatureStrategySchema> Strategies { get; set; }

        /// <summary>
        /// [Variants](https://docs.getunleash.io/reference/feature-toggle-variants#what-are-variants) configured for this toggle
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variants", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<VariantSchema> Variants { get; set; }

    }

    /// <summary>
    /// Query parameters active for a client features request
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClientFeaturesQuerySchema
    {
        /// <summary>
        /// Features tagged with one of these tags are included
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<System.Collections.Generic.List<string>> Tag { get; set; }

        /// <summary>
        /// Features that are part of these projects are included in this response. (DEPRECATED) - Handled by API tokens
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.Obsolete]
        public System.Collections.Generic.List<string> Project { get; set; }

        /// <summary>
        /// Features are filtered to only include features whose name starts with this prefix
        /// </summary>
        [Newtonsoft.Json.JsonProperty("namePrefix", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NamePrefix { get; set; }

        /// <summary>
        /// Strategies for the feature toggle configured for this environment are included. (DEPRECATED) - Handled by API tokens
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.Obsolete]
        public string Environment { get; set; }

        /// <summary>
        /// Set to true if requesting client does not support Unleash-Client-Specification 4.2.2 or newer. Modern SDKs will have this set to false, since they will be able to merge constraints and segments themselves
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inlineSegmentConstraints", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool InlineSegmentConstraints { get; set; }

    }

    /// <summary>
    /// Configuration data for server-side SDKs for evaluating feature flags.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClientFeaturesSchema
    {
        /// <summary>
        /// A version number for the format used in the response. Most Unleash instances now return version 2, which includes segments as a separate array
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double Version { get; set; }

        /// <summary>
        /// A list of feature toggles with their configuration
        /// </summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<ClientFeatureSchema> Features { get; set; } = new System.Collections.Generic.List<ClientFeatureSchema>();

        /// <summary>
        /// A list of [Segments](https://docs.getunleash.io/reference/segments) configured for this Unleash instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("segments", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ClientSegmentSchema> Segments { get; set; }

        /// <summary>
        /// A summary of filters and parameters sent to the endpoint. Used by the server to build the features and segments response
        /// </summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ClientFeaturesQuerySchema Query { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Client usage metrics, accumulated in buckets of hour by hour by default
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClientMetricsSchema
    {
        /// <summary>
        /// The name of the application that is evaluating toggles
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AppName { get; set; }

        /// <summary>
        /// A [(somewhat) unique identifier](https://docs.getunleash.io/reference/sdks/node#advanced-usage) for the application
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instanceId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InstanceId { get; set; }

        /// <summary>
        /// Which environment the application is running in
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Environment { get; set; }

        /// <summary>
        /// Holds all metrics gathered over a window of time. Typically 1 hour wide
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bucket", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Bucket Bucket { get; set; } = new Bucket();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Used for reporting feature evaluation results from SDKs
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClientMetricsEnvSchema
    {
        /// <summary>
        /// Name of the feature checked by the SDK
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FeatureName { get; set; }

        /// <summary>
        /// The name of the application the SDK is being used in
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AppName { get; set; }

        /// <summary>
        /// Which environment the SDK is being used in
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Environment { get; set; }

        /// <summary>
        /// The start of the time window these metrics are valid for. The window is 1 hour wide
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset Timestamp { get; set; }

        /// <summary>
        /// How many times the toggle evaluated to true
        /// </summary>
        [Newtonsoft.Json.JsonProperty("yes", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Yes { get; set; }

        /// <summary>
        /// How many times the toggle evaluated to false
        /// </summary>
        [Newtonsoft.Json.JsonProperty("no", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int No { get; set; }

        /// <summary>
        /// How many times each variant was returned
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variants", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, int> Variants { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Copy of a feature with a new name
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CloneFeatureSchema
    {
        /// <summary>
        /// The name of the new feature
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Whether to use the new feature name as its group ID or not. Group ID is used for calculating [stickiness](https://docs.getunleash.io/reference/stickiness#calculation). Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("replaceGroupId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool ReplaceGroupId { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// A strategy constraint. For more information, refer to [the strategy constraint reference documentation](https://docs.getunleash.io/reference/strategy-constraints)
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConstraintSchema
    {
        /// <summary>
        /// The name of the context field that this constraint should apply to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ContextName { get; set; }

        /// <summary>
        /// The operator to use when evaluating this constraint. For more information about the various operators, refer to [the strategy constraint operator documentation](https://docs.getunleash.io/reference/strategy-constraints#strategy-constraint-operators).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConstraintSchemaOperator Operator { get; set; }

        /// <summary>
        /// Whether the operator should be case sensitive or not. Defaults to `false` (being case sensitive).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("caseInsensitive", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool CaseInsensitive { get; set; } = false;

        /// <summary>
        /// Whether the result should be negated or not. If `true`, will turn a `true` result into a `false` result and vice versa.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inverted", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Inverted { get; set; } = false;

        /// <summary>
        /// The context values that should be used for constraint evaluation. Use this property instead of `value` for properties that accept multiple values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Values { get; set; }

        /// <summary>
        /// The context value that should be used for constraint evaluation. Use this property instead of `values` for properties that only accept single values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

    }

    /// <summary>
    /// A representation of a [context field](https://docs.getunleash.io/reference/unleash-context).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContextFieldSchema
    {
        /// <summary>
        /// The name of the context field
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The description of the context field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// Does this context field support being used for [stickiness](https://docs.getunleash.io/reference/stickiness) calculations
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stickiness", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Stickiness { get; set; }

        /// <summary>
        /// Used when sorting a list of context fields. Is also used as a tiebreaker if a list of context fields is sorted alphabetically.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sortOrder", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int SortOrder { get; set; }

        /// <summary>
        /// When this context field was created
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreatedAt { get; set; }

        /// <summary>
        /// Number of projects where this context field is used in
        /// </summary>
        [Newtonsoft.Json.JsonProperty("usedInFeatures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int? UsedInFeatures { get; set; }

        /// <summary>
        /// Number of projects where this context field is used in
        /// </summary>
        [Newtonsoft.Json.JsonProperty("usedInProjects", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int? UsedInProjects { get; set; }

        /// <summary>
        /// Allowed values for this context field schema. Can be used to narrow down accepted input
        /// </summary>
        [Newtonsoft.Json.JsonProperty("legalValues", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<LegalValueSchema> LegalValues { get; set; }

    }

    /// <summary>
    /// A list of context fields
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContextFieldsSchema : System.Collections.ObjectModel.Collection<ContextFieldSchema>
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateApiTokenSchema : Anonymous2
    {
        /// <summary>
        /// The name of the token.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokenName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TokenName { get; set; }

    }

    /// <summary>
    /// Reported application information from Unleash SDKs
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateApplicationSchema
    {
        /// <summary>
        /// Name of the application
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AppName { get; set; }

        /// <summary>
        /// Which SDK and version the application reporting uses. Typically represented as `&lt;identifier&gt;:&lt;version&gt;`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sdkVersion", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SdkVersion { get; set; }

        /// <summary>
        /// Which [strategies](https://docs.getunleash.io/topics/the-anatomy-of-unleash#activation-strategies) the application has loaded. Useful when trying to figure out if your [custom strategy](https://docs.getunleash.io/reference/custom-activation-strategies) has been loaded in the SDK
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategies", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Strategies { get; set; }

        /// <summary>
        /// A link to reference the application reporting the metrics. Could for instance be a GitHub link to the repository of the application
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        /// <summary>
        /// Css color to be used to color the application's entry in the application list
        /// </summary>
        [Newtonsoft.Json.JsonProperty("color", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Color { get; set; }

        /// <summary>
        /// An URL to an icon file to be used for the applications's entry in the application list
        /// </summary>
        [Newtonsoft.Json.JsonProperty("icon", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Icon { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Data used to create a new feature toggle.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateFeatureSchema
    {
        /// <summary>
        /// Unique feature name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The feature toggle's [type](https://docs.getunleash.io/reference/feature-toggle-types). One of experiment, kill-switch, release, operational, or permission
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// Detailed description of the feature
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// `true` if the impression data collection is enabled for the feature, otherwise `false`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("impressionData", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool ImpressionData { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Create a strategy configuration in a feature
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateFeatureStrategySchema
    {
        /// <summary>
        /// The name of the strategy type
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// A descriptive title for the strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Title { get; set; }

        /// <summary>
        /// A toggle to disable the strategy. defaults to false. Disabled strategies are not evaluated or returned to the SDKs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Disabled { get; set; }

        /// <summary>
        /// The order of the strategy in the list
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sortOrder", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double SortOrder { get; set; }

        /// <summary>
        /// A list of the constraints attached to the strategy. See https://docs.getunleash.io/reference/strategy-constraints
        /// </summary>
        [Newtonsoft.Json.JsonProperty("constraints", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConstraintSchema> Constraints { get; set; }

        /// <summary>
        /// Strategy level variants
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variants", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<CreateStrategyVariantSchema> Variants { get; set; }

        /// <summary>
        /// An object containing the parameters for the strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParametersSchema Parameters { get; set; }

        /// <summary>
        /// Ids of segments to use for this strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("segments", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<double> Segments { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Data used to create a user that has been invited to Unleash.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateInvitedUserSchema
    {
        /// <summary>
        /// The user's username. Must be unique if provided.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Username { get; set; }

        /// <summary>
        /// The invited user's email address
        /// </summary>
        [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Email { get; set; }

        /// <summary>
        /// The user's name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The user's password
        /// </summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }

    }

    /// <summary>
    /// The payload must contain at least one of the name and email properties, though which one is up to you. For the user to be able to log in to the system, the user must have an email.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateUserSchema
    {
        /// <summary>
        /// The user's username. Must be provided if email is not provided.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Username { get; set; }

        /// <summary>
        /// The user's email address. Must be provided if username is not provided.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Email { get; set; }

        /// <summary>
        /// The user's name (not the user's username).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Password for the user
        /// </summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }

        /// <summary>
        /// The role to assign to the user. Can be either the role's ID or its unique name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rootRole", Required = Newtonsoft.Json.Required.Always)]
        public int RootRole { get; set; }

        /// <summary>
        /// Whether to send a welcome email with a login link to the user or not. Defaults to `true`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sendEmail", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool SendEmail { get; set; }

    }

    /// <summary>
    /// An [RFC-3339](https://www.rfc-editor.org/rfc/rfc3339.html)-compliant timestamp.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DateSchema
    {

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// A representation of a client token, limiting access to [CLIENT](https://docs.getunleash.io/reference/api-tokens-and-client-keys#client-tokens) (used by serverside SDKs) or [FRONTEND](https://docs.getunleash.io/reference/api-tokens-and-client-keys#front-end-tokens) (used by proxy SDKs)
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EdgeTokenSchema
    {
        /// <summary>
        /// The list of projects this token has access to. If the token has access to specific projects they will be listed here. If the token has access to all projects it will be represented as [`*`]
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projects", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Projects { get; set; } = new System.Collections.Generic.List<string>();

        /// <summary>
        /// The [API token](https://docs.getunleash.io/reference/api-tokens-and-client-keys#api-tokens)'s **type**. Unleash supports three different types of API tokens ([ADMIN](https://docs.getunleash.io/reference/api-tokens-and-client-keys#admin-tokens), [CLIENT](https://docs.getunleash.io/reference/api-tokens-and-client-keys#client-tokens), [FRONTEND](https://docs.getunleash.io/reference/api-tokens-and-client-keys#front-end-tokens)). They all have varying access, so when validating a token it's important to know what kind you're dealing with
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EdgeTokenSchemaType Type { get; set; }

        /// <summary>
        /// The actual token value. [Unleash API tokens](https://docs.getunleash.io/reference/api-tokens-and-client-keys) are comprised of three parts. &lt;project(s)&gt;:&lt;environment&gt;.randomcharacters
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Token { get; set; }

    }

    /// <summary>
    /// Represents the email of a user. Used to send email communication (reset password, welcome mail etc)
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EmailSchema
    {
        /// <summary>
        /// The email address
        /// </summary>
        [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Email { get; set; }

    }

    /// <summary>
    /// A definition of the project environment
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EnvironmentSchema
    {
        /// <summary>
        /// The name of the environment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The [type of environment](https://docs.getunleash.io/reference/environments#environment-types).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }

        /// <summary>
        /// `true` if the environment is enabled for the project, otherwise `false`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }

        /// <summary>
        /// `true` if the environment is protected, otherwise `false`. A *protected* environment can not be deleted.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protected", Required = Newtonsoft.Json.Required.Always)]
        public bool Protected { get; set; }

        /// <summary>
        /// Priority of the environment in a list of environments, the lower the value, the higher up in the list the environment will appear. Needs to be an integer
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sortOrder", Required = Newtonsoft.Json.Required.Always)]
        public int SortOrder { get; set; }

        /// <summary>
        /// The number of projects with this environment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projectCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int? ProjectCount { get; set; }

        /// <summary>
        /// The number of API tokens for the project environment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiTokenCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int? ApiTokenCount { get; set; }

        /// <summary>
        /// The number of enabled toggles for the project environment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabledToggleCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int? EnabledToggleCount { get; set; }

    }

    /// <summary>
    /// Describes a project's configuration in a given environment.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EnvironmentProjectSchema
    {
        /// <summary>
        /// The name of the environment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The [type of environment](https://docs.getunleash.io/reference/environments#environment-types).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }

        /// <summary>
        /// `true` if the environment is enabled for the project, otherwise `false`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }

        /// <summary>
        /// `true` if the environment is protected, otherwise `false`. A *protected* environment can not be deleted.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protected", Required = Newtonsoft.Json.Required.Always)]
        public bool Protected { get; set; }

        /// <summary>
        /// Priority of the environment in a list of environments, the lower the value, the higher up in the list the environment will appear
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sortOrder", Required = Newtonsoft.Json.Required.Always)]
        public int SortOrder { get; set; }

        /// <summary>
        /// The number of client and front-end API tokens that have access to this project
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projectApiTokenCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int ProjectApiTokenCount { get; set; }

        /// <summary>
        /// The number of features enabled in this environment for this project
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projectEnabledToggleCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int ProjectEnabledToggleCount { get; set; }

        /// <summary>
        /// The strategy configuration to add when enabling a feature environment by default
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultStrategy", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CreateFeatureStrategySchema DefaultStrategy { get; set; }

    }

    /// <summary>
    /// A versioned list of environments
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EnvironmentsSchema
    {
        /// <summary>
        /// Version of the environments schema
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public int Version { get; set; }

        /// <summary>
        /// List of environments
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environments", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<EnvironmentSchema> Environments { get; set; } = new System.Collections.Generic.List<EnvironmentSchema>();

    }

    /// <summary>
    /// Environments defined for a given project
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EnvironmentsProjectSchema
    {
        /// <summary>
        /// Version of the environments schema
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public int Version { get; set; }

        /// <summary>
        /// List of environments
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environments", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<EnvironmentProjectSchema> Environments { get; set; } = new System.Collections.Generic.List<EnvironmentProjectSchema>();

    }

    /// <summary>
    /// An event describing something happening in the system
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventSchema
    {
        /// <summary>
        /// The ID of the event. An increasing natural number.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1, int.MaxValue)]
        public int Id { get; set; }

        /// <summary>
        /// The time the event happened as a RFC 3339-conformant timestamp.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset CreatedAt { get; set; }

        /// <summary>
        /// What [type](https://docs.getunleash.io/reference/api/legacy/unleash/admin/events#event-type-description) of event this is
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EventSchemaType Type { get; set; }

        /// <summary>
        /// Which user created this event
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CreatedBy { get; set; }

        /// <summary>
        /// The feature toggle environment the event relates to, if applicable.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Environment { get; set; }

        /// <summary>
        /// The project the event relates to, if applicable.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Project { get; set; }

        /// <summary>
        /// The name of the feature toggle the event relates to, if applicable.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FeatureName { get; set; }

        /// <summary>
        /// Extra associated data related to the event, such as feature toggle state, segment configuration, etc., if applicable.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Data { get; set; }

        /// <summary>
        /// Data relating to the previous state of the event's subject.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object PreData { get; set; }

        /// <summary>
        /// Any tags related to the event, if applicable.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<TagSchema> Tags { get; set; }

    }

    /// <summary>
    /// A list of events that has happened in the system
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventsSchema
    {
        /// <summary>
        /// The api version of this response. A natural increasing number. Only increases if format changes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1, int.MaxValue)]
        public EventsSchemaVersion Version { get; set; }

        /// <summary>
        /// The list of events
        /// </summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<EventSchema> Events { get; set; } = new System.Collections.Generic.List<EventSchema>();

        /// <summary>
        /// The total count of events
        /// </summary>
        [Newtonsoft.Json.JsonProperty("totalEvents", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int TotalEvents { get; set; }

    }

    /// <summary>
    /// The result of the export operation, providing you with the feature toggle definitions, strategy definitions and the rest of the elements relevant to the features (tags, environments etc.)
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExportResultSchema
    {
        /// <summary>
        /// All the exported features.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<FeatureSchema> Features { get; set; } = new System.Collections.Generic.List<FeatureSchema>();

        /// <summary>
        /// All strategy instances that are used by the exported features in the `features` list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureStrategies", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<FeatureStrategySchema> FeatureStrategies { get; set; } = new System.Collections.Generic.List<FeatureStrategySchema>();

        /// <summary>
        /// Environment-specific configuration for all the features in the `features` list. Includes data such as whether the feature is enabled in the selected export environment, whether there are any variants assigned, etc.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureEnvironments", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<FeatureEnvironmentSchema> FeatureEnvironments { get; set; }

        /// <summary>
        /// A list of all the context fields that are in use by any of the strategies in the `featureStrategies` list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextFields", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ContextFieldSchema> ContextFields { get; set; }

        /// <summary>
        /// A list of all the tags that have been applied to any of the features in the `features` list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureTags", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<FeatureTagSchema> FeatureTags { get; set; }

        /// <summary>
        /// A list of all the segments that are used by the strategies in the `featureStrategies` list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("segments", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Segments> Segments { get; set; }

        /// <summary>
        /// A list of all of the tag types that are used in the `featureTags` list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tagTypes", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<TagTypeSchema> TagTypes { get; set; } = new System.Collections.Generic.List<TagTypeSchema>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExportQuerySchema
    {
        /// <summary>
        /// Selects features to export by name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Features { get; set; } = new System.Collections.Generic.List<string>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// How many times `feautreName` was evaluated to `true` (yes) and `false` (no) for `appName` in `environmnet`
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeatureEnvironmentMetricsSchema
    {
        /// <summary>
        /// The name of the feature
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FeatureName { get; set; }

        /// <summary>
        /// The name of the application the SDK is being used in
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AppName { get; set; }

        /// <summary>
        /// Which environment the SDK is being used in
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Environment { get; set; }

        /// <summary>
        /// The start of the time window these metrics are valid for. The window is usually 1 hour wide
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Timestamp { get; set; }

        /// <summary>
        /// How many times the toggle evaluated to true
        /// </summary>
        [Newtonsoft.Json.JsonProperty("yes", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Yes { get; set; }

        /// <summary>
        /// How many times the toggle evaluated to false
        /// </summary>
        [Newtonsoft.Json.JsonProperty("no", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int No { get; set; }

        /// <summary>
        /// How many times each variant was returned
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variants", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, int> Variants { get; set; }

    }

    /// <summary>
    /// A detailed description of the feature environment
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeatureEnvironmentSchema
    {
        /// <summary>
        /// The name of the environment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The name of the feature
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FeatureName { get; set; }

        /// <summary>
        /// The name of the environment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Environment { get; set; }

        /// <summary>
        /// The type of the environment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// `true` if the feature is enabled for the environment, otherwise `false`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }

        /// <summary>
        /// The sort order of the feature environment in the feature environments list
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sortOrder", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double SortOrder { get; set; }

        /// <summary>
        /// The number of defined variants
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variantCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double VariantCount { get; set; }

        /// <summary>
        /// A list of activation strategies for the feature environment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategies", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<FeatureStrategySchema> Strategies { get; set; }

        /// <summary>
        /// A list of variants for the feature environment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variants", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<VariantSchema> Variants { get; set; }

        /// <summary>
        /// The date when metrics where last collected for the feature environment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastSeenAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? LastSeenAt { get; set; }

    }

    /// <summary>
    /// One or more events happening to a specific feature toggle
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeatureEventsSchema
    {
        /// <summary>
        /// An API versioning number
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1, int.MaxValue)]
        public FeatureEventsSchemaVersion Version { get; set; }

        /// <summary>
        /// The name of the feature toggle these events relate to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("toggleName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ToggleName { get; set; }

        /// <summary>
        /// The list of events
        /// </summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<EventSchema> Events { get; set; } = new System.Collections.Generic.List<EventSchema>();

        /// <summary>
        /// How many events are there for this feature toggle
        /// </summary>
        [Newtonsoft.Json.JsonProperty("totalEvents", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int TotalEvents { get; set; }

    }

    /// <summary>
    /// A batch of feature metrics
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeatureMetricsSchema
    {
        /// <summary>
        /// The version of this schema
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1, int.MaxValue)]
        public int Version { get; set; }

        /// <summary>
        /// The maturity level of this API (alpha, beta, stable, deprecated)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maturity", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Maturity { get; set; }

        /// <summary>
        /// Metrics gathered per environment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<FeatureEnvironmentMetricsSchema> Data { get; set; } = new System.Collections.Generic.List<FeatureEnvironmentMetricsSchema>();

    }

    /// <summary>
    /// A feature toggle definition
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeatureSchema
    {
        /// <summary>
        /// Unique feature name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Type of the toggle e.g. experiment, kill-switch, release, operational, permission
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// Detailed description of the feature
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// `true` if the feature is archived
        /// </summary>
        [Newtonsoft.Json.JsonProperty("archived", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Archived { get; set; }

        /// <summary>
        /// Name of the project the feature belongs to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Project { get; set; }

        /// <summary>
        /// `true` if the feature is enabled, otherwise `false`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Enabled { get; set; }

        /// <summary>
        /// `true` if the feature is stale based on the age and feature type, otherwise `false`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stale", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Stale { get; set; }

        /// <summary>
        /// `true` if the feature was favorited, otherwise `false`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("favorite", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Favorite { get; set; }

        /// <summary>
        /// `true` if the impression data collection is enabled for the feature, otherwise `false`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("impressionData", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool ImpressionData { get; set; }

        /// <summary>
        /// The date the feature was created
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreatedAt { get; set; }

        /// <summary>
        /// The date the feature was archived
        /// </summary>
        [Newtonsoft.Json.JsonProperty("archivedAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ArchivedAt { get; set; }

        /// <summary>
        /// The date when metrics where last collected for the feature. This field is deprecated, use the one in featureEnvironmentSchema
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastSeenAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.Obsolete]
        public System.DateTimeOffset? LastSeenAt { get; set; }

        /// <summary>
        /// The list of environments where the feature can be used
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environments", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<FeatureEnvironmentSchema> Environments { get; set; }

        /// <summary>
        /// The list of feature variants
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variants", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.Obsolete]
        public System.Collections.Generic.List<VariantSchema> Variants { get; set; }

        /// <summary>
        /// This is a legacy field that will be deprecated
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategies", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.Obsolete]
        public System.Collections.Generic.List<object> Strategies { get; set; }

        /// <summary>
        /// The list of feature tags
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<TagSchema> Tags { get; set; }

    }

    /// <summary>
    /// A list of features
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    [System.Obsolete]
    public partial class FeaturesSchema
    {
        /// <summary>
        /// The version of the feature's schema
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public int Version { get; set; }

        /// <summary>
        /// A list of features
        /// </summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<FeatureSchema> Features { get; set; } = new System.Collections.Generic.List<FeatureSchema>();

    }

    /// <summary>
    /// A single activation strategy configuration schema for a feature
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeatureStrategySchema
    {
        /// <summary>
        /// A uuid for the feature strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// The name or type of strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// A descriptive title for the strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Title { get; set; }

        /// <summary>
        /// A toggle to disable the strategy. defaults to false. Disabled strategies are not evaluated or returned to the SDKs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Disabled { get; set; }

        /// <summary>
        /// The name or feature the strategy is attached to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FeatureName { get; set; }

        /// <summary>
        /// The order of the strategy in the list
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sortOrder", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double SortOrder { get; set; }

        /// <summary>
        /// A list of segment ids attached to the strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("segments", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<double> Segments { get; set; }

        /// <summary>
        /// A list of the constraints attached to the strategy. See https://docs.getunleash.io/reference/strategy-constraints
        /// </summary>
        [Newtonsoft.Json.JsonProperty("constraints", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConstraintSchema> Constraints { get; set; }

        /// <summary>
        /// Strategy level variants
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variants", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<StrategyVariantSchema> Variants { get; set; }

        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParametersSchema Parameters { get; set; }

    }

    /// <summary>
    /// An object containing a segment identifier and a strategy identifier.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeatureStrategySegmentSchema
    {
        /// <summary>
        /// The ID of the segment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("segmentId", Required = Newtonsoft.Json.Required.Always)]
        public int SegmentId { get; set; }

        /// <summary>
        /// The ID of the strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureStrategyId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FeatureStrategyId { get; set; }

    }

    /// <summary>
    /// Describes a tag applied to a feature
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeatureTagSchema
    {
        /// <summary>
        /// The name of the feature this tag is applied to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FeatureName { get; set; }

        /// <summary>
        /// The [type](https://docs.getunleash.io/reference/tags#tag-types tag types) of the tag
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tagType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TagType { get; set; }

        /// <summary>
        /// The value of the tag
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tagValue", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TagValue { get; set; }

        /// <summary>
        /// The [type](https://docs.getunleash.io/reference/tags#tag-types tag types) of the tag. This property is deprecated and will be removed in a future version of Unleash. Superseded by the `tagType` property.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.Obsolete]
        public string Type { get; set; }

        /// <summary>
        /// The value of the tag. This property is deprecated and will be removed in a future version of Unleash. Superseded by the `tagValue` property.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.Obsolete]
        public string Value { get; set; }

    }

    /// <summary>
    /// A [feature toggle type](https://docs.getunleash.io/reference/feature-toggle-types).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeatureTypeSchema
    {
        /// <summary>
        /// The identifier of this feature toggle type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The display name of this feature toggle type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// A description of what this feature toggle type is intended to be used for.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        /// <summary>
        /// How many days it takes before a feature toggle of this typed is flagged as [potentially stale](https://docs.getunleash.io/reference/technical-debt#stale-and-potentially-stale-toggles) by Unleash. If this value is `null`, Unleash will never mark it as potentially stale.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lifetimeDays", Required = Newtonsoft.Json.Required.AllowNull)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int? LifetimeDays { get; set; }

    }

    /// <summary>
    /// A list of [feature toggle types](https://docs.getunleash.io/reference/feature-toggle-types) and the schema version used to represent those feature types.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeatureTypesSchema
    {
        /// <summary>
        /// The schema version used to describe the feature toggle types listed in the `types` property.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public FeatureTypesSchemaVersion Version { get; set; }

        /// <summary>
        /// The list of feature toggle types.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("types", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<FeatureTypeSchema> Types { get; set; } = new System.Collections.Generic.List<FeatureTypeSchema>();

    }

    /// <summary>
    /// How many applications have seen this feature toggle, as well as how this feature was evaluated the last hour
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeatureUsageSchema
    {
        /// <summary>
        /// The version of this schema
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(1, int.MaxValue)]
        public int Version { get; set; }

        /// <summary>
        /// The maturity level of this API (alpha, beta, stable, deprecated)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maturity", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Maturity { get; set; }

        /// <summary>
        /// The name of the feature
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FeatureName { get; set; }

        /// <summary>
        /// Last hour statistics. Accumulated per feature per environment. Contains counts for evaluations to true (yes) and to false (no)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastHourUsage", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<FeatureEnvironmentMetricsSchema> LastHourUsage { get; set; } = new System.Collections.Generic.List<FeatureEnvironmentMetricsSchema>();

        /// <summary>
        /// A list of applications seen using this feature
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seenApplications", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> SeenApplications { get; set; } = new System.Collections.Generic.List<string>();

    }

    /// <summary>
    /// A versioned collection of feature toggle variants.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeatureVariantsSchema
    {
        /// <summary>
        /// The version of the feature variants schema.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public int Version { get; set; }

        /// <summary>
        /// All variants defined for a specific feature toggle.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variants", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<VariantSchema> Variants { get; set; } = new System.Collections.Generic.List<VariantSchema>();

    }

    /// <summary>
    /// User feedback information to be created.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeedbackCreateSchema
    {
        /// <summary>
        /// `true` if the user has asked never to see this feedback questionnaire again. Defaults to `false`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("neverShow", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool NeverShow { get; set; }

        /// <summary>
        /// The name of the feedback session
        /// </summary>
        [Newtonsoft.Json.JsonProperty("feedbackId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FeedbackId { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// User feedback information to be updated.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeedbackUpdateSchema
    {
        /// <summary>
        /// The ID of the user that gave the feedback.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("userId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int UserId { get; set; }

        /// <summary>
        /// `true` if the user has asked never to see this feedback questionnaire again.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("neverShow", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool NeverShow { get; set; }

        /// <summary>
        /// When this feedback was given
        /// </summary>
        [Newtonsoft.Json.JsonProperty("given", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Given { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// User feedback information about a particular feedback item.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeedbackResponseSchema
    {
        /// <summary>
        /// The ID of the user that gave the feedback.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("userId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int UserId { get; set; }

        /// <summary>
        /// `true` if the user has asked never to see this feedback questionnaire again.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("neverShow", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool NeverShow { get; set; }

        /// <summary>
        /// When this feedback was given
        /// </summary>
        [Newtonsoft.Json.JsonProperty("given", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Given { get; set; }

        /// <summary>
        /// The name of the feedback session
        /// </summary>
        [Newtonsoft.Json.JsonProperty("feedbackId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FeedbackId { get; set; }

    }

    /// <summary>
    /// A detailed information about a user group
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GroupSchema
    {
        /// <summary>
        /// The group id
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Id { get; set; }

        /// <summary>
        /// The name of the group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// A custom description of the group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// A list of SSO groups that should map to this Unleash group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mappingsSSO", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> MappingsSSO { get; set; }

        /// <summary>
        /// A role id that is used as the root role for all users in this group. This can be either the id of the Viewer, Editor or Admin role.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rootRole", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? RootRole { get; set; }

        /// <summary>
        /// A user who created this group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CreatedBy { get; set; }

        /// <summary>
        /// When was this group created
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreatedAt { get; set; }

        /// <summary>
        /// A list of users belonging to this group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("users", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<GroupUserModelSchema> Users { get; set; }

        /// <summary>
        /// A list of projects where this group is used
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projects", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Projects { get; set; }

        /// <summary>
        /// The number of users that belong to this group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("userCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int UserCount { get; set; }

    }

    /// <summary>
    /// A list of [user groups](https://docs.getunleash.io/reference/rbac#user-groups)
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GroupsSchema
    {
        /// <summary>
        /// A list of groups
        /// </summary>
        [Newtonsoft.Json.JsonProperty("groups", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<GroupSchema> Groups { get; set; }

    }

    /// <summary>
    /// Details for a single user belonging to a group
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GroupUserModelSchema
    {
        /// <summary>
        /// The date when the user joined the group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("joinedAt", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset JoinedAt { get; set; }

        /// <summary>
        /// The username of the user who added this user to this group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CreatedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public UserSchema User { get; set; } = new UserSchema();

    }

    /// <summary>
    /// Used by service orchestrators to decide whether this Unleash instance should be marked as healthy or unhealthy
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HealthCheckSchema
    {
        /// <summary>
        /// The state this Unleash instance is in. GOOD if everything is ok, BAD if the instance should be restarted
        /// </summary>
        [Newtonsoft.Json.JsonProperty("health", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public HealthCheckSchemaHealth Health { get; set; }

    }

    /// <summary>
    /// An overview of a project's stats and its health as described in the documentation on [technical debt](https://docs.getunleash.io/reference/technical-debt)
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HealthOverviewSchema
    {
        /// <summary>
        /// The project overview version.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public int Version { get; set; }

        /// <summary>
        /// The project's name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The project's description
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// A default stickiness for the project affecting the default stickiness value for variants and Gradual Rollout strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultStickiness", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DefaultStickiness { get; set; }

        /// <summary>
        /// The project's [collaboration mode](https://docs.getunleash.io/reference/project-collaboration-mode). Determines whether non-project members can submit change requests or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public HealthOverviewSchemaMode Mode { get; set; }

        /// <summary>
        /// A limit on the number of features allowed in the project. Null if no limit.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureLimit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FeatureLimit { get; set; }

        /// <summary>
        /// The number of users/members in the project.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("members", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Members { get; set; }

        /// <summary>
        /// The overall [health rating](https://docs.getunleash.io/reference/technical-debt#health-rating) of the project.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("health", Required = Newtonsoft.Json.Required.Always)]
        public int Health { get; set; }

        /// <summary>
        /// An array containing the names of all the environments configured for the project.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environments", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<ProjectEnvironmentSchema> Environments { get; set; } = new System.Collections.Generic.List<ProjectEnvironmentSchema>();

        /// <summary>
        /// An array containing an overview of all the features of the project and their individual status
        /// </summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<FeatureSchema> Features { get; set; } = new System.Collections.Generic.List<FeatureSchema>();

        /// <summary>
        /// When the project was last updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("updatedAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? UpdatedAt { get; set; }

        /// <summary>
        /// When the project was last updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreatedAt { get; set; }

        /// <summary>
        /// Indicates if the project has been marked as a favorite by the current user requesting the project health overview.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("favorite", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Favorite { get; set; }

        /// <summary>
        /// Project statistics
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stats", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProjectStatsSchema Stats { get; set; }

    }

    /// <summary>
    /// A report of the current health of the requested project, with datapoints like counters of currently active, stale, and potentially stale feature toggles.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HealthReportSchema
    {
        /// <summary>
        /// The project overview version.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public int Version { get; set; }

        /// <summary>
        /// The project's name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The project's description
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// A default stickiness for the project affecting the default stickiness value for variants and Gradual Rollout strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultStickiness", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DefaultStickiness { get; set; }

        /// <summary>
        /// The project's [collaboration mode](https://docs.getunleash.io/reference/project-collaboration-mode). Determines whether non-project members can submit change requests or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public HealthReportSchemaMode Mode { get; set; }

        /// <summary>
        /// A limit on the number of features allowed in the project. Null if no limit.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureLimit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FeatureLimit { get; set; }

        /// <summary>
        /// The number of users/members in the project.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("members", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Members { get; set; }

        /// <summary>
        /// The overall [health rating](https://docs.getunleash.io/reference/technical-debt#health-rating) of the project.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("health", Required = Newtonsoft.Json.Required.Always)]
        public int Health { get; set; }

        /// <summary>
        /// An array containing the names of all the environments configured for the project.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environments", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<ProjectEnvironmentSchema> Environments { get; set; } = new System.Collections.Generic.List<ProjectEnvironmentSchema>();

        /// <summary>
        /// An array containing an overview of all the features of the project and their individual status
        /// </summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<FeatureSchema> Features { get; set; } = new System.Collections.Generic.List<FeatureSchema>();

        /// <summary>
        /// When the project was last updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("updatedAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? UpdatedAt { get; set; }

        /// <summary>
        /// When the project was last updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreatedAt { get; set; }

        /// <summary>
        /// Indicates if the project has been marked as a favorite by the current user requesting the project health overview.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("favorite", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Favorite { get; set; }

        /// <summary>
        /// Project statistics
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stats", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProjectStatsSchema Stats { get; set; }

        /// <summary>
        /// The number of potentially stale feature toggles.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("potentiallyStaleCount", Required = Newtonsoft.Json.Required.Always)]
        public double PotentiallyStaleCount { get; set; }

        /// <summary>
        /// The number of active feature toggles.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("activeCount", Required = Newtonsoft.Json.Required.Always)]
        public double ActiveCount { get; set; }

        /// <summary>
        /// The number of stale feature toggles.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("staleCount", Required = Newtonsoft.Json.Required.Always)]
        public double StaleCount { get; set; }

    }

    /// <summary>
    /// Email id used for password reset
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IdSchema
    {
        /// <summary>
        /// User email
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

    }

    /// <summary>
    /// Information about an instance and statistics about usage of various features of Unleash
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InstanceAdminStatsSchema
    {
        /// <summary>
        /// A unique identifier for this instance. Generated by the database migration scripts at first run. Typically a UUID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instanceId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string InstanceId { get; set; }

        /// <summary>
        /// When these statistics were produced
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Timestamp { get; set; }

        /// <summary>
        /// The version of Unleash OSS that is bundled in this instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("versionOSS", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VersionOSS { get; set; }

        /// <summary>
        /// The version of Unleash Enterprise that is bundled in this instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("versionEnterprise", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VersionEnterprise { get; set; }

        /// <summary>
        /// The number of users this instance has
        /// </summary>
        [Newtonsoft.Json.JsonProperty("users", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double Users { get; set; }

        /// <summary>
        /// The number of feature-toggles this instance has
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureToggles", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double FeatureToggles { get; set; }

        /// <summary>
        /// The number of projects defined in this instance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projects", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double Projects { get; set; }

        /// <summary>
        /// The number of context fields defined in this instance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextFields", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double ContextFields { get; set; }

        /// <summary>
        /// The number of roles defined in this instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("roles", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double Roles { get; set; }

        /// <summary>
        /// The number of groups defined in this instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("groups", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double Groups { get; set; }

        /// <summary>
        /// The number of environments defined in this instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environments", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double Environments { get; set; }

        /// <summary>
        /// The number of segments defined in this instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("segments", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double Segments { get; set; }

        /// <summary>
        /// The number of strategies defined in this instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategies", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double Strategies { get; set; }

        /// <summary>
        /// Whether or not SAML authentication is enabled for this instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("SAMLenabled", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool SAMLenabled { get; set; }

        /// <summary>
        /// Whether or not OIDC authentication is enabled for this instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("OIDCenabled", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool OIDCenabled { get; set; }

        /// <summary>
        /// A count of connected applications in the last week, last month and all time since last restart
        /// </summary>
        [Newtonsoft.Json.JsonProperty("clientApps", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ClientApps> ClientApps { get; set; }

        /// <summary>
        /// A SHA-256 checksum of the instance statistics to be used to verify that the data in this object has not been tampered with
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sum", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sum { get; set; }

    }

    /// <summary>
    /// Describes a legal value. Typically used to limit possible values for contextFields or strategy properties
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LegalValueSchema
    {
        /// <summary>
        /// The valid value
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

        /// <summary>
        /// Describes this specific legal value
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

    }

    /// <summary>
    /// A username/password login request
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LoginSchema
    {
        /// <summary>
        /// The username trying to log in
        /// </summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Username { get; set; }

        /// <summary>
        /// The password of the user trying to log in
        /// </summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }

    }

    /// <summary>
    /// The current state of Unleash's maintenance mode feature.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class MaintenanceSchema
    {
        /// <summary>
        /// Whether maintenance mode is enabled or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }

    }

    /// <summary>
    /// Data used when to activate or deactivate maintenance mode for Unleash.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ToggleMaintenanceSchema
    {
        /// <summary>
        /// `true` if you want to activate maintenance mode, `false` if you want to deactivate it.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Detailed user information
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class MeSchema
    {
        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public UserSchema User { get; set; } = new UserSchema();

        /// <summary>
        /// User permissions for projects and environments
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<PermissionSchema> Permissions { get; set; } = new System.Collections.Generic.List<PermissionSchema>();

        /// <summary>
        /// User feedback information
        /// </summary>
        [Newtonsoft.Json.JsonProperty("feedback", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<FeedbackResponseSchema> Feedback { get; set; } = new System.Collections.Generic.List<FeedbackResponseSchema>();

        /// <summary>
        /// Splash screen configuration
        /// </summary>
        [Newtonsoft.Json.JsonProperty("splash", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IDictionary<string, bool> Splash { get; set; } = new System.Collections.Generic.Dictionary<string, bool>();

    }

    /// <summary>
    /// An object with a name
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NameSchema
    {
        /// <summary>
        /// The name of the represented object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

    }

    /// <summary>
    /// An override for deciding which variant should be assigned to a user based on the context name
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OverrideSchema
    {
        /// <summary>
        /// The name of the context field used to determine overrides
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ContextName { get; set; }

        /// <summary>
        /// Which values that should be overriden
        /// </summary>
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Values { get; set; } = new System.Collections.Generic.List<string>();

    }

    /// <summary>
    /// A list of parameters for a strategy
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ParametersSchema : System.Collections.Generic.Dictionary<string, string>
    {

    }

    /// <summary>
    /// Fields used to create new password or update old password
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PasswordSchema
    {
        /// <summary>
        /// The new password to change or validate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }

        /// <summary>
        /// The old password the user is changing. This field is for the non-admin users changing their own password.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oldPassword", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OldPassword { get; set; }

        /// <summary>
        /// The confirmation of the new password. This field is for the non-admin users changing their own password.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("confirmPassword", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfirmPassword { get; set; }

    }

    /// <summary>
    /// A list of patches
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PatchesSchema : System.Collections.ObjectModel.Collection<PatchSchema>
    {

    }

    /// <summary>
    /// A [JSON patch](https://www.rfc-editor.org/rfc/rfc6902) operation description
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PatchSchema
    {
        /// <summary>
        /// The path to the property to operate on
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path { get; set; }

        /// <summary>
        /// The kind of operation to perform
        /// </summary>
        [Newtonsoft.Json.JsonProperty("op", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PatchSchemaOp Op { get; set; }

        /// <summary>
        /// The target to move or copy from, if performing one of those operations
        /// </summary>
        [Newtonsoft.Json.JsonProperty("from", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string From { get; set; }

        /// <summary>
        /// The value to add or replace, if performing one of those operations
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Value { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// An overview of a [Personal Access Token](https://docs.getunleash.io/how-to/how-to-create-personal-access-tokens).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PatSchema
    {
        /// <summary>
        /// The unique identification number for this Personal Access Token. (This property is set by Unleash when the token is created and cannot be set manually: if you provide a value when creating a PAT, Unleash will ignore it.)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1, int.MaxValue)]
        public int Id { get; set; }

        /// <summary>
        /// The token used for authentication. (This property is set by Unleash when the token is created and cannot be set manually: if you provide a value when creating a PAT, Unleash will ignore it.)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Secret { get; set; }

        /// <summary>
        /// The token's expiration date.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expiresAt", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset ExpiresAt { get; set; }

        /// <summary>
        /// When the token was created. (This property is set by Unleash when the token is created and cannot be set manually: if you provide a value when creating a PAT, Unleash will ignore it.)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset CreatedAt { get; set; }

        /// <summary>
        /// When the token was last seen/used to authenticate with. `null` if it has not been used yet. (This property is set by Unleash when the token is created and cannot be set manually: if you provide a value when creating a PAT, Unleash will ignore it.)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seenAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? SeenAt { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Contains a collection of [Personal Access Tokens](https://docs.getunleash.io/how-to/how-to-create-personal-access-tokens).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PatsSchema
    {
        /// <summary>
        /// A collection of Personal Access Tokens
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pats", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<PatSchema> Pats { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Project and environment permissions
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PermissionSchema
    {
        /// <summary>
        /// [Project](https://docs.getunleash.io/reference/rbac#project-permissions) or [environment](https://docs.getunleash.io/reference/rbac#environment-permissions) permission name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permission", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Permission { get; set; }

        /// <summary>
        /// The project this permission applies to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Project { get; set; }

        /// <summary>
        /// The environment this permission applies to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Environment { get; set; }

    }

    /// <summary>
    /// A strategy constraint. For more information, refer to [the strategy constraint reference documentation](https://docs.getunleash.io/reference/strategy-constraints)
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PlaygroundConstraintSchema
    {
        /// <summary>
        /// The name of the context field that this constraint should apply to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ContextName { get; set; }

        /// <summary>
        /// The operator to use when evaluating this constraint. For more information about the various operators, refer to [the strategy constraint operator documentation](https://docs.getunleash.io/reference/strategy-constraints#strategy-constraint-operators).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PlaygroundConstraintSchemaOperator Operator { get; set; }

        /// <summary>
        /// Whether the operator should be case sensitive or not. Defaults to `false` (being case sensitive).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("caseInsensitive", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool CaseInsensitive { get; set; } = false;

        /// <summary>
        /// Whether the result should be negated or not. If `true`, will turn a `true` result into a `false` result and vice versa.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inverted", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Inverted { get; set; } = false;

        /// <summary>
        /// The context values that should be used for constraint evaluation. Use this property instead of `value` for properties that accept multiple values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Values { get; set; }

        /// <summary>
        /// The context value that should be used for constraint evaluation. Use this property instead of `values` for properties that only accept single values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

        /// <summary>
        /// Whether this was evaluated as true or false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Always)]
        public bool Result { get; set; }

    }

    /// <summary>
    /// A simplified feature toggle model intended for the Unleash playground.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PlaygroundFeatureSchema
    {
        /// <summary>
        /// The feature's name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The ID of the project that contains this feature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projectId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ProjectId { get; set; }

        /// <summary>
        /// The feature's applicable strategies and cumulative results of the strategies
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategies", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Strategies3 Strategies { get; set; } = new Strategies3();

        /// <summary>
        /// Whether the feature is active and would be evaluated in the provided environment in a normal SDK context.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isEnabledInCurrentEnvironment", Required = Newtonsoft.Json.Required.Always)]
        public bool IsEnabledInCurrentEnvironment { get; set; }

        /// <summary>
        /// Whether this feature is enabled or not in the current environment.
        /// <br/>                          If a feature can't be fully evaluated (that is, `strategies.result` is `unknown`),
        /// <br/>                          this will be `false` to align with how client SDKs treat unresolved feature states.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isEnabled", Required = Newtonsoft.Json.Required.Always)]
        public bool IsEnabled { get; set; }

        /// <summary>
        /// The feature variant you receive based on the provided context or the _disabled
        /// <br/>                          variant_. If a feature is disabled or doesn't have any
        /// <br/>                          variants, you would get the _disabled variant_.
        /// <br/>                          Otherwise, you'll get one of thefeature's defined variants.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variant", Required = Newtonsoft.Json.Required.AllowNull)]
        public Variant2 Variant { get; set; }

        /// <summary>
        /// The feature variants.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variants", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<VariantSchema> Variants { get; set; } = new System.Collections.Generic.List<VariantSchema>();

    }

    /// <summary>
    /// Data for the playground API to evaluate toggles
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PlaygroundRequestSchema
    {
        /// <summary>
        /// The environment to evaluate toggles in.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Environment { get; set; }

        /// <summary>
        /// A list of projects to check for toggles in.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projects", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Projects { get; set; }

        [Newtonsoft.Json.JsonProperty("context", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SdkContextSchema Context { get; set; } = new SdkContextSchema();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// The state of all features given the provided input.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PlaygroundResponseSchema
    {
        /// <summary>
        /// The given input used to evaluate the features.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("input", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PlaygroundRequestSchema Input { get; set; } = new PlaygroundRequestSchema();

        /// <summary>
        /// The list of features that have been evaluated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<PlaygroundFeatureSchema> Features { get; set; } = new System.Collections.Generic.List<PlaygroundFeatureSchema>();

    }

    /// <summary>
    /// The evaluated result of a segment as used by the Playground.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PlaygroundSegmentSchema
    {
        /// <summary>
        /// The segment's id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        public int Id { get; set; }

        /// <summary>
        /// The name of the segment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Whether this was evaluated as true or false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Always)]
        public bool Result { get; set; }

        /// <summary>
        /// The list of constraints in this segment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("constraints", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<PlaygroundConstraintSchema> Constraints { get; set; } = new System.Collections.Generic.List<PlaygroundConstraintSchema>();

    }

    /// <summary>
    /// An evaluated feature toggle strategy as used by the Playground
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PlaygroundStrategySchema
    {
        /// <summary>
        /// The strategy's name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Description of the feature's purpose.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Title { get; set; }

        /// <summary>
        /// The strategy's id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The strategy's evaluation result. If the strategy is a custom strategy that Unleash can't evaluate, `evaluationStatus` will be `unknown`. Otherwise, it will be `true` or `false`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Always)]
        public Result Result { get; set; }

        /// <summary>
        /// The strategy's status. Disabled strategies are not evaluated
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disabled", Required = Newtonsoft.Json.Required.AllowNull)]
        public bool? Disabled { get; set; }

        /// <summary>
        /// The strategy's segments and their evaluation results.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("segments", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<PlaygroundSegmentSchema> Segments { get; set; } = new System.Collections.Generic.List<PlaygroundSegmentSchema>();

        /// <summary>
        /// The strategy's constraints and their evaluation results.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("constraints", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<PlaygroundConstraintSchema> Constraints { get; set; } = new System.Collections.Generic.List<PlaygroundConstraintSchema>();

        /// <summary>
        /// The strategy's constraints and their evaluation results.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ParametersSchema Parameters { get; set; } = new ParametersSchema();

        /// <summary>
        /// A set of links to actions you can perform on this strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("links", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Links Links { get; set; } = new Links();

    }

    /// <summary>
    /// User profile overview
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProfileSchema
    {
        [Newtonsoft.Json.JsonProperty("rootRole", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public RoleSchema RootRole { get; set; } = new RoleSchema();

        /// <summary>
        /// Which projects this user is a member of
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projects", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Projects { get; set; } = new System.Collections.Generic.List<string>();

        /// <summary>
        /// Deprecated, always returns empty array
        /// </summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<FeatureSchema> Features { get; set; } = new System.Collections.Generic.List<FeatureSchema>();

    }

    /// <summary>
    /// Add an environment to a project, optionally also sets if change requests are enabled for this environment on the project
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProjectEnvironmentSchema
    {
        /// <summary>
        /// The environment to add to the project
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Environment { get; set; }

        /// <summary>
        /// Whether change requests should be enabled or for this environment on the project or not
        /// </summary>
        [Newtonsoft.Json.JsonProperty("changeRequestsEnabled", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool ChangeRequestsEnabled { get; set; }

        /// <summary>
        /// A default strategy to create for this environment on the project.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultStrategy", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CreateFeatureStrategySchema DefaultStrategy { get; set; }

    }

    /// <summary>
    /// A definition of the project used for projects listing purposes
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProjectSchema
    {
        /// <summary>
        /// The id of this project
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The name of this project
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Additional information about the project
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// An indicator of the [project's health](https://docs.getunleash.io/reference/technical-debt#health-rating) on a scale from 0 to 100
        /// </summary>
        [Newtonsoft.Json.JsonProperty("health", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Health { get; set; }

        /// <summary>
        /// The number of features this project has
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double FeatureCount { get; set; }

        /// <summary>
        /// The number of members this project has
        /// </summary>
        [Newtonsoft.Json.JsonProperty("memberCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double MemberCount { get; set; }

        /// <summary>
        /// When this project was created.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset CreatedAt { get; set; }

        /// <summary>
        /// When this project was last updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("updatedAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? UpdatedAt { get; set; }

        /// <summary>
        /// `true` if the project was favorited, otherwise `false`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("favorite", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Favorite { get; set; }

        /// <summary>
        /// The project's [collaboration mode](https://docs.getunleash.io/reference/project-collaboration-mode). Determines whether non-project members can submit change requests or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProjectSchemaMode Mode { get; set; }

        /// <summary>
        /// A default stickiness for the project affecting the default stickiness value for variants and Gradual Rollout strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultStickiness", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DefaultStickiness { get; set; }

    }

    /// <summary>
    /// An overview of all the projects in the Unleash instance
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProjectsSchema
    {
        /// <summary>
        /// The schema version used to represent the project data.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public int Version { get; set; }

        /// <summary>
        /// A list of projects in the Unleash instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projects", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<ProjectSchema> Projects { get; set; } = new System.Collections.Generic.List<ProjectSchema>();

    }

    /// <summary>
    /// Frontend SDK client registration information
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProxyClientSchema
    {
        /// <summary>
        /// Name of the application using Unleash
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AppName { get; set; }

        /// <summary>
        /// Instance id for this application (typically hostname, podId or similar)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instanceId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InstanceId { get; set; }

        /// <summary>
        /// Optional field that describes the sdk version (name:version)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sdkVersion", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SdkVersion { get; set; }

        /// <summary>
        /// deprecated
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.Obsolete]
        public string Environment { get; set; }

        /// <summary>
        /// At which interval, in milliseconds, will this client be expected to send metrics
        /// </summary>
        [Newtonsoft.Json.JsonProperty("interval", Required = Newtonsoft.Json.Required.Always)]
        public double Interval { get; set; }

        /// <summary>
        /// When this client started. Should be reported as ISO8601 time.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("started", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Started { get; set; }

        /// <summary>
        /// List of strategies implemented by this application
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategies", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Strategies { get; set; } = new System.Collections.Generic.List<string>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Frontend API feature
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProxyFeatureSchema
    {
        /// <summary>
        /// Unique feature name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Always set to `true`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }

        /// <summary>
        /// `true` if the impression data collection is enabled for the feature, otherwise `false`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("impressionData", Required = Newtonsoft.Json.Required.Always)]
        public bool ImpressionData { get; set; }

        /// <summary>
        /// Variant details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variant", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Variant3 Variant { get; set; }

    }

    /// <summary>
    /// Frontend SDK features list
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProxyFeaturesSchema
    {
        /// <summary>
        /// The actual features returned to the Frontend SDK
        /// </summary>
        [Newtonsoft.Json.JsonProperty("toggles", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<ProxyFeatureSchema> Toggles { get; set; } = new System.Collections.Generic.List<ProxyFeatureSchema>();

    }

    /// <summary>
    /// Used for creating a [public invite link](https://docs.getunleash.io/reference/public-signup#public-sign-up-tokens)
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PublicSignupTokenCreateSchema
    {
        /// <summary>
        /// The token's name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The token's expiration date.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expiresAt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ExpiresAt { get; set; }

    }

    /// <summary>
    /// Used for transporting a [public invite link](https://docs.getunleash.io/reference/public-signup#public-sign-up-tokens)
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PublicSignupTokenSchema
    {
        /// <summary>
        /// The actual value of the token. This is the part that is used by Unleash to create an invite link
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Secret { get; set; }

        /// <summary>
        /// The public signup link for the token. Users who follow this link will be taken to a signup page where they can create an Unleash user.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.AllowNull)]
        public string Url { get; set; }

        /// <summary>
        /// The token's name. Only for displaying in the UI
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Whether the token is active. This property will always be `false` for a token that has expired.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }

        /// <summary>
        /// The time when the token will expire.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expiresAt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ExpiresAt { get; set; }

        /// <summary>
        /// When the token was created.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset CreatedAt { get; set; }

        /// <summary>
        /// The creator's email or username
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.AllowNull)]
        public string CreatedBy { get; set; }

        /// <summary>
        /// Array of users that have signed up using the token.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("users", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<UserSchema> Users { get; set; }

        /// <summary>
        /// Users who sign up using this token will be given this role.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public RoleSchema Role { get; set; } = new RoleSchema();

    }

    /// <summary>
    /// A wrapper object containing all the public signup tokens
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PublicSignupTokensSchema
    {
        /// <summary>
        /// An array of all the public signup tokens
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokens", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<PublicSignupTokenSchema> Tokens { get; set; } = new System.Collections.Generic.List<PublicSignupTokenSchema>();

    }

    /// <summary>
    /// Used by Unleash for updating a token's expiration date or, when deleting the invite link, it's status
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PublicSignupTokenUpdateSchema
    {
        /// <summary>
        /// The token's expiration date.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expiresAt", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset ExpiresAt { get; set; }

        /// <summary>
        /// Whether the token is active or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Enabled { get; set; }

    }

    /// <summary>
    /// Data used when copying variants into a new environment.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PushVariantsSchema
    {
        /// <summary>
        /// The variants to write to the provided environments
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variants", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<VariantSchema> Variants { get; set; }

        /// <summary>
        /// The enviromnents to write the provided variants to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environments", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Environments { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Statistics for a project, including the average time to production, number of features created, the project activity and more.
    /// <br/>
    /// <br/>Stats are divided into current and previous **windows**.
    /// <br/>- The **current window** is the past 30 days.
    /// <br/>- The **previous window** is the 30 days **before** the current window (from 60 to 30 days ago)
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProjectStatsSchema
    {
        /// <summary>
        /// The average time from when a feature was created to when it was enabled in the "production" environment during the current window
        /// </summary>
        [Newtonsoft.Json.JsonProperty("avgTimeToProdCurrentWindow", Required = Newtonsoft.Json.Required.Always)]
        public double AvgTimeToProdCurrentWindow { get; set; }

        /// <summary>
        /// The number of feature toggles created during the current window
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdCurrentWindow", Required = Newtonsoft.Json.Required.Always)]
        public double CreatedCurrentWindow { get; set; }

        /// <summary>
        /// The number of feature toggles created during the previous window
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdPastWindow", Required = Newtonsoft.Json.Required.Always)]
        public double CreatedPastWindow { get; set; }

        /// <summary>
        /// The number of feature toggles that were archived during the current window
        /// </summary>
        [Newtonsoft.Json.JsonProperty("archivedCurrentWindow", Required = Newtonsoft.Json.Required.Always)]
        public double ArchivedCurrentWindow { get; set; }

        /// <summary>
        /// The number of feature toggles that were archived during the previous window
        /// </summary>
        [Newtonsoft.Json.JsonProperty("archivedPastWindow", Required = Newtonsoft.Json.Required.Always)]
        public double ArchivedPastWindow { get; set; }

        /// <summary>
        /// The number of project events that occurred during the current window
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projectActivityCurrentWindow", Required = Newtonsoft.Json.Required.Always)]
        public double ProjectActivityCurrentWindow { get; set; }

        /// <summary>
        /// The number of project events that occurred during the previous window
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projectActivityPastWindow", Required = Newtonsoft.Json.Required.Always)]
        public double ProjectActivityPastWindow { get; set; }

        /// <summary>
        /// The number of members that were added to the project during the current window
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projectMembersAddedCurrentWindow", Required = Newtonsoft.Json.Required.Always)]
        public double ProjectMembersAddedCurrentWindow { get; set; }

    }

    /// <summary>
    /// Data used to provide users a way to reset their passwords.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResetPasswordSchema
    {
        /// <summary>
        /// A URL pointing to a location where the user can reset their password
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resetPasswordUrl", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri ResetPasswordUrl { get; set; }

    }

    /// <summary>
    /// Statistics for usage of Unleash, formatted so it can easily be used in a graph
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RequestsPerSecondSchema
    {
        /// <summary>
        /// Whether the query against prometheus succeeded or failed
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RequestsPerSecondSchemaStatus Status { get; set; }

        /// <summary>
        /// The query result from prometheus
        /// </summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Data Data { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Get usage metrics separated by client and admin paths
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RequestsPerSecondSegmentedSchema
    {
        [Newtonsoft.Json.JsonProperty("clientMetrics", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RequestsPerSecondSchema ClientMetrics { get; set; }

        [Newtonsoft.Json.JsonProperty("adminMetrics", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RequestsPerSecondSchema AdminMetrics { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// A role holds permissions to allow Unleash to decide what actions a role holder is allowed to perform
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RoleSchema
    {
        /// <summary>
        /// The role id
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Id { get; set; }

        /// <summary>
        /// A role can either be a global root role (applies to all projects) or a project role
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }

        /// <summary>
        /// The name of the role
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// A more detailed description of the role and what use it's intended for
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

    }

    /// <summary>
    /// The Unleash context as modeled in client SDKs
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SdkContextSchema
    {
        /// <summary>
        /// The name of the application.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public string AppName { get; set; }

        /// <summary>
        /// A DateTime (or similar) data class instance or a string in an RFC3339-compatible format. Defaults to the current time if not set by the user.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("currentTime", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset CurrentTime { get; set; }

        /// <summary>
        /// The environment the app is running in.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.Obsolete]
        public string Environment { get; set; }

        /// <summary>
        /// Additional Unleash context properties
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Properties { get; set; }

        /// <summary>
        /// The app's IP address
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remoteAddress", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RemoteAddress { get; set; }

        /// <summary>
        /// An identifier for the current session
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sessionId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SessionId { get; set; }

        /// <summary>
        /// An identifier for the current user
        /// </summary>
        [Newtonsoft.Json.JsonProperty("userId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UserId { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// 
    /// <br/>        Search for events by type, project, feature, free-text query,
    /// <br/>        or a combination thereof. Pass an empty object to fetch all events.
    /// <br/>    
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchEventsSchema
    {
        /// <summary>
        /// Find events by event type (case-sensitive).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SearchEventsSchemaType Type { get; set; }

        /// <summary>
        /// Find events by project ID (case-sensitive).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Project { get; set; }

        /// <summary>
        /// Find events by feature toggle name (case-sensitive).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("feature", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Feature { get; set; }

        /// <summary>
        /// Find events by a free-text search query. The query will be matched against the event type, the username or email that created the event (if any), and the event data payload (if any).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Query { get; set; }

        /// <summary>
        /// The maximum amount of events to return in the search result
        /// </summary>
        [Newtonsoft.Json.JsonProperty("limit", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1, 100)]
        public int Limit { get; set; } = 100;

        /// <summary>
        /// Which event id to start listing from
        /// </summary>
        [Newtonsoft.Json.JsonProperty("offset", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Offset { get; set; } = 0;

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Represents a segment of users defined by a set of constraints.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SegmentSchema
    {
        /// <summary>
        /// The segment's id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        public double Id { get; set; }

        /// <summary>
        /// The name of the segment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// List of constraints that determine which users are part of the segment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("constraints", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<ConstraintSchema> Constraints { get; set; } = new System.Collections.Generic.List<ConstraintSchema>();

        /// <summary>
        /// The description of the segment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// The time the segment was created as a RFC 3339-conformant timestamp.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset CreatedAt { get; set; }

        /// <summary>
        /// Which user created this segment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CreatedBy { get; set; }

        /// <summary>
        /// The project the segment relates to, if applicable.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Project { get; set; }

    }

    /// <summary>
    /// An array of strategies with their new sort order
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SetStrategySortOrderSchema : System.Collections.ObjectModel.Collection<Anonymous>
    {

    }

    /// <summary>
    /// Unleash configuration settings affect the admin UI.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SetUiConfigSchema
    {
        /// <summary>
        /// Settings related to the front-end API.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("frontendSettings", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FrontendSettings FrontendSettings { get; set; }

    }

    /// <summary>
    /// A map of object IDs and their corresponding sort orders.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SortOrderSchema : System.Collections.Generic.Dictionary<string, int>
    {

    }

    /// <summary>
    /// Data related to a user having seen a splash screen.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SplashRequestSchema
    {
        /// <summary>
        /// The ID of the user that was shown the splash screen.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("userId", Required = Newtonsoft.Json.Required.Always)]
        public int UserId { get; set; }

        /// <summary>
        /// The ID of the splash screen that was shown.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("splashId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SplashId { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Data related to a user having seen a splash screen.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SplashResponseSchema
    {
        /// <summary>
        /// The ID of the user that was shown the splash screen.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("userId", Required = Newtonsoft.Json.Required.Always)]
        public int UserId { get; set; }

        /// <summary>
        /// The ID of the splash screen that was shown.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("splashId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SplashId { get; set; }

        /// <summary>
        /// Indicates whether the user has seen the splash screen or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seen", Required = Newtonsoft.Json.Required.Always)]
        public bool Seen { get; set; }

    }

    /// <summary>
    /// The application state as used by the deprecated export/import APIs.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    [System.Obsolete]
    public partial class StateSchema
    {
        /// <summary>
        /// The version of the schema used to describe the state
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public int Version { get; set; }

        /// <summary>
        /// A list of features
        /// </summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<FeatureSchema> Features { get; set; }

        /// <summary>
        /// A list of strategies
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategies", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<StrategySchema> Strategies { get; set; }

        /// <summary>
        /// A list of tags
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<TagSchema> Tags { get; set; }

        /// <summary>
        /// A list of tag types
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tagTypes", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<TagTypeSchema> TagTypes { get; set; }

        /// <summary>
        /// A list of tags applied to features
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureTags", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<FeatureTagSchema> FeatureTags { get; set; }

        /// <summary>
        /// A list of projects
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projects", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ProjectSchema> Projects { get; set; }

        /// <summary>
        /// A list of feature strategies as applied to features
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureStrategies", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<FeatureStrategySchema> FeatureStrategies { get; set; }

        /// <summary>
        /// A list of feature environment configurations
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureEnvironments", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<FeatureEnvironmentSchema> FeatureEnvironments { get; set; }

        /// <summary>
        /// A list of environments
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environments", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<EnvironmentSchema> Environments { get; set; }

        /// <summary>
        /// A list of segments
        /// </summary>
        [Newtonsoft.Json.JsonProperty("segments", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SegmentSchema> Segments { get; set; }

        /// <summary>
        /// A list of segment/strategy pairings
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureStrategySegments", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<FeatureStrategySegmentSchema> FeatureStrategySegments { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// List of strategies
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StrategiesSchema
    {
        /// <summary>
        /// Version of the strategies schema
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public StrategiesSchemaVersion Version { get; set; }

        /// <summary>
        /// List of strategies
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategies", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<StrategySchema> Strategies { get; set; } = new System.Collections.Generic.List<StrategySchema>();

    }

    /// <summary>
    /// The [activation strategy](https://docs.getunleash.io/reference/activation-strategies) schema
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StrategySchema
    {
        /// <summary>
        /// An optional title for the strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Title { get; set; }

        /// <summary>
        /// The name (type) of the strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// A human friendly name for the strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.AllowNull)]
        public string DisplayName { get; set; }

        /// <summary>
        /// A short description of the strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.AllowNull)]
        public string Description { get; set; }

        /// <summary>
        /// Whether the strategy can be edited or not. Strategies bundled with Unleash cannot be edited.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("editable", Required = Newtonsoft.Json.Required.Always)]
        public bool Editable { get; set; }

        [Newtonsoft.Json.JsonProperty("deprecated", Required = Newtonsoft.Json.Required.Always)]
        public bool Deprecated { get; set; }

        /// <summary>
        /// A list of relevant parameters for each strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<Parameters> Parameters { get; set; } = new System.Collections.Generic.List<Parameters>();

    }

    /// <summary>
    /// Represents tag changes to be applied to a list of features.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TagsBulkAddSchema
    {
        /// <summary>
        /// The list of features that will be affected by the tag changes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Features { get; set; } = new System.Collections.Generic.List<string>();

        /// <summary>
        /// The tag changes to be applied to the features.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public UpdateTagsSchema Tags { get; set; } = new UpdateTagsSchema();

    }

    /// <summary>
    /// Representation of a [tag](https://docs.getunleash.io/reference/tags)
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TagSchema
    {
        /// <summary>
        /// The value of the tag
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(50, MinimumLength = 2)]
        public string Value { get; set; }

        /// <summary>
        /// The [type](https://docs.getunleash.io/reference/tags#tag-types) of the tag
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(50, MinimumLength = 2)]
        public string Type { get; set; } = "simple";

    }

    /// <summary>
    /// A list of tags with a version number
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TagsSchema
    {
        /// <summary>
        /// The version of the schema used to model the tags.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public int Version { get; set; }

        /// <summary>
        /// A list of tags.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<TagSchema> Tags { get; set; } = new System.Collections.Generic.List<TagSchema>();

    }

    /// <summary>
    /// A tag type.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TagTypeSchema
    {
        /// <summary>
        /// The name of the tag type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The description of the tag type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// The icon of the tag type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("icon", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Icon { get; set; }

    }

    /// <summary>
    /// A list of tag types with a version number representing the schema used to model the tag types.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TagTypesSchema
    {
        /// <summary>
        /// The version of the schema used to model the tag types.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public int Version { get; set; }

        /// <summary>
        /// The list of tag types.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tagTypes", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<TagTypeSchema> TagTypes { get; set; } = new System.Collections.Generic.List<TagTypeSchema>();

    }

    /// <summary>
    /// A tag with a version number representing the schema used to model the tag.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TagWithVersionSchema
    {
        /// <summary>
        /// The version of the schema used to model the tag.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public int Version { get; set; }

        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public TagSchema Tag { get; set; } = new TagSchema();

    }

    /// <summary>
    /// A user identified by a token
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TokenUserSchema
    {
        /// <summary>
        /// The user id
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        public int Id { get; set; }

        /// <summary>
        /// The name of the user
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The email of the user
        /// </summary>
        [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Email { get; set; }

        /// <summary>
        /// A token uniquely identifying a user
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Token { get; set; }

        /// <summary>
        /// A username or email identifying which user created this token
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.AllowNull)]
        public string CreatedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public RoleSchema Role { get; set; } = new RoleSchema();

    }

    /// <summary>
    /// A list of unleash tokens to validate against known tokens
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TokenStringListSchema
    {
        /// <summary>
        /// Tokens that we want to get access information about
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokens", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Tokens { get; set; } = new System.Collections.Generic.List<string>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// A collection of properties used to configure the Unleash Admin UI.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UiConfigSchema
    {
        /// <summary>
        /// The slogan to display in the UI footer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slogan", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Slogan { get; set; }

        /// <summary>
        /// The name of this Unleash instance. Used to build the text in the footer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The current version of Unleash
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Version { get; set; }

        /// <summary>
        /// What kind of Unleash instance it is: Enterprise, Pro, or Open source
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Environment { get; set; }

        /// <summary>
        /// The URL of the Unleash instance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unleashUrl", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string UnleashUrl { get; set; }

        /// <summary>
        /// The base URI path at which this Unleash instance is listening.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("baseUriPath", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string BaseUriPath { get; set; }

        /// <summary>
        /// Whether password authentication should be disabled or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disablePasswordAuth", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool DisablePasswordAuth { get; set; }

        /// <summary>
        /// Whether this instance can send out emails or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("emailEnabled", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool EmailEnabled { get; set; }

        /// <summary>
        /// Whether maintenance mode is currently active or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maintenanceMode", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool MaintenanceMode { get; set; }

        /// <summary>
        /// The maximum number of values that can be used in a single segment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("segmentValuesLimit", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double SegmentValuesLimit { get; set; }

        /// <summary>
        /// The maximum number of segments that can be applied to a single strategy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategySegmentsLimit", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double StrategySegmentsLimit { get; set; }

        /// <summary>
        /// Whether to enable the Unleash network view or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("networkViewEnabled", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool NetworkViewEnabled { get; set; }

        /// <summary>
        /// The list of origins that the front-end API should accept requests from.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("frontendApiOrigins", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> FrontendApiOrigins { get; set; }

        /// <summary>
        /// Additional (largely experimental) features that are enabled in this Unleash instance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("flags", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, Anonymous3> Flags { get; set; }

        /// <summary>
        /// Relevant links to use in the UI.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("links", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<object> Links { get; set; }

        /// <summary>
        /// The type of authentication enabled for this Unleash instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authenticationType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public UiConfigSchemaAuthenticationType AuthenticationType { get; set; }

        [Newtonsoft.Json.JsonProperty("versionInfo", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public VersionSchema VersionInfo { get; set; } = new VersionSchema();

    }

    /// <summary>
    /// An object with fields to updated for a given API token.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpdateApiTokenSchema
    {
        /// <summary>
        /// The new time when this token should expire.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expiresAt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ExpiresAt { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Data used for updating a feature toggle
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpdateFeatureSchema
    {
        /// <summary>
        /// Detailed description of the feature
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// Type of the toggle e.g. experiment, kill-switch, release, operational, permission
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// `true` if the feature is archived
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stale", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Stale { get; set; }

        /// <summary>
        /// If `true` the feature toggle will be moved to the [archive](https://docs.getunleash.io/reference/archived-toggles) with a property `archivedAt` set to current time
        /// </summary>
        [Newtonsoft.Json.JsonProperty("archived", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Archived { get; set; }

        /// <summary>
        /// `true` if the impression data collection is enabled for the feature
        /// </summary>
        [Newtonsoft.Json.JsonProperty("impressionData", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool ImpressionData { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Update a strategy configuration in a feature
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpdateFeatureStrategySchema
    {
        /// <summary>
        /// The name of the strategy type
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The order of the strategy in the list in feature environment configuration
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sortOrder", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double SortOrder { get; set; }

        /// <summary>
        /// A list of the constraints attached to the strategy. See https://docs.getunleash.io/reference/strategy-constraints
        /// </summary>
        [Newtonsoft.Json.JsonProperty("constraints", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConstraintSchema> Constraints { get; set; }

        /// <summary>
        /// A descriptive title for the strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Title { get; set; }

        /// <summary>
        /// A toggle to disable the strategy. defaults to true. Disabled strategies are not evaluated or returned to the SDKs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Disabled { get; set; }

        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParametersSchema Parameters { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// The request body for updating a tag type.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpdateTagTypeSchema
    {
        /// <summary>
        /// The description of the tag type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// The icon of the tag type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("icon", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Icon { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// All fields that can be directly changed for the user
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpdateUserSchema
    {
        /// <summary>
        /// The user's email address. Must be provided if username is not provided.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Email { get; set; }

        /// <summary>
        /// The user's name (not the user's username).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The role to assign to the user. Can be either the role's ID or its unique name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rootRole", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int RootRole { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Represents a set of changes to a feature's tags, such as adding or removing tags.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpdateTagsSchema
    {
        /// <summary>
        /// Tags to add to the feature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("addedTags", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<TagSchema> AddedTags { get; set; } = new System.Collections.Generic.List<TagSchema>();

        /// <summary>
        /// Tags to remove from the feature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("removedTags", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<TagSchema> RemovedTags { get; set; } = new System.Collections.Generic.List<TagSchema>();

    }

    /// <summary>
    /// Data used to create a context field configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateContextFieldSchema
    {
        /// <summary>
        /// A description of the context field
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// `true` if this field should be available for use with [custom stickiness](https://docs.getunleash.io/reference/stickiness#custom-stickiness), otherwise `false`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stickiness", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Stickiness { get; set; }

        /// <summary>
        /// How this context field should be sorted if no other sort order is selected
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sortOrder", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int SortOrder { get; set; }

        /// <summary>
        /// A list of allowed values for this context field
        /// </summary>
        [Newtonsoft.Json.JsonProperty("legalValues", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<LegalValueSchema> LegalValues { get; set; }

        /// <summary>
        /// The name of the context field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Data to update an existing context field configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpdateContextFieldSchema
    {
        /// <summary>
        /// A description of the context field
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// `true` if this field should be available for use with [custom stickiness](https://docs.getunleash.io/reference/stickiness#custom-stickiness), otherwise `false`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stickiness", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Stickiness { get; set; }

        /// <summary>
        /// How this context field should be sorted if no other sort order is selected
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sortOrder", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int SortOrder { get; set; }

        /// <summary>
        /// A list of allowed values for this context field
        /// </summary>
        [Newtonsoft.Json.JsonProperty("legalValues", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<LegalValueSchema> LegalValues { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Represents a segment of users defined by a set of constraints.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpsertSegmentSchema
    {
        /// <summary>
        /// The name of the segment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The description of the segment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// Project from where this segment will be accessible. If none is defined the segment will be global (i.e. accessible from any project).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Project { get; set; }

        /// <summary>
        /// List of constraints that determine which users will be part of the segment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("constraints", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<ConstraintSchema> Constraints { get; set; } = new System.Collections.Generic.List<ConstraintSchema>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// The data required to create a strategy type. Refer to the docs on [custom strategy types](https://docs.getunleash.io/reference/custom-activation-strategies) for more information.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateStrategySchema
    {
        /// <summary>
        /// The name of the strategy type. Must be unique.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// A description of the strategy type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// The parameter list lets you pass arguments to your custom activation strategy. These will be made available to your custom strategy implementation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<Parameters2> Parameters { get; set; } = new System.Collections.Generic.List<Parameters2>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// The data required to update a strategy type.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpdateStrategySchema
    {
        /// <summary>
        /// A description of the strategy type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// The parameter list lets you pass arguments to your custom activation strategy. These will be made available to your custom strategy implementation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<Parameters3> Parameters { get; set; } = new System.Collections.Generic.List<Parameters3>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Data used when updating the lifetime of a [feature toggle type](https://docs.getunleash.io/reference/feature-toggle-types).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpdateFeatureTypeLifetimeSchema
    {
        /// <summary>
        /// The new lifetime (in days) that you want to assign to the feature toggle type. If the value is `null` or `0`, then the feature toggles of that type will never be marked as potentially stale. Otherwise, they will be considered potentially stale after the number of days indicated by this property.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lifetimeDays", Required = Newtonsoft.Json.Required.AllowNull)]
        [System.ComponentModel.DataAnnotations.Range(0, 2147483647)]
        public int? LifetimeDays { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// An Unleash user
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UserSchema
    {
        /// <summary>
        /// The user id
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Id { get; set; }

        /// <summary>
        /// (Deprecated): Used internally to know which operations the user should be allowed to perform
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isAPI", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.Obsolete]
        public bool IsAPI { get; set; }

        /// <summary>
        /// Name of the user
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Email of the user
        /// </summary>
        [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Email { get; set; }

        /// <summary>
        /// A unique username for the user
        /// </summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Username { get; set; }

        /// <summary>
        /// URL used for the userprofile image
        /// </summary>
        [Newtonsoft.Json.JsonProperty("imageUrl", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImageUrl { get; set; }

        /// <summary>
        /// If the user is actively inviting other users, this is the link that can be shared with other users
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inviteLink", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InviteLink { get; set; }

        /// <summary>
        /// How many unsuccessful attempts at logging in has the user made
        /// </summary>
        [Newtonsoft.Json.JsonProperty("loginAttempts", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int LoginAttempts { get; set; }

        /// <summary>
        /// Is the welcome email sent to the user or not
        /// </summary>
        [Newtonsoft.Json.JsonProperty("emailSent", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool EmailSent { get; set; }

        /// <summary>
        /// Which [root role](https://docs.getunleash.io/reference/rbac#predefined-roles) this user is assigned
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rootRole", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int RootRole { get; set; }

        /// <summary>
        /// The last time this user logged in
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seenAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? SeenAt { get; set; }

        /// <summary>
        /// The user was created at this time
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset CreatedAt { get; set; }

        /// <summary>
        /// A user is either an actual User or a Service Account
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accountType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AccountType { get; set; }

        /// <summary>
        /// Deprecated
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Permissions { get; set; }

    }

    /// <summary>
    /// An Unleash user after creation
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateUserResponseSchema
    {
        /// <summary>
        /// The user id
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Id { get; set; }

        /// <summary>
        /// (Deprecated): Used internally to know which operations the user should be allowed to perform
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isAPI", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.Obsolete]
        public bool IsAPI { get; set; }

        /// <summary>
        /// Name of the user
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Email of the user
        /// </summary>
        [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Email { get; set; }

        /// <summary>
        /// A unique username for the user
        /// </summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Username { get; set; }

        /// <summary>
        /// URL used for the userprofile image
        /// </summary>
        [Newtonsoft.Json.JsonProperty("imageUrl", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImageUrl { get; set; }

        /// <summary>
        /// If the user is actively inviting other users, this is the link that can be shared with other users
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inviteLink", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InviteLink { get; set; }

        /// <summary>
        /// How many unsuccessful attempts at logging in has the user made
        /// </summary>
        [Newtonsoft.Json.JsonProperty("loginAttempts", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int LoginAttempts { get; set; }

        /// <summary>
        /// Is the welcome email sent to the user or not
        /// </summary>
        [Newtonsoft.Json.JsonProperty("emailSent", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool EmailSent { get; set; }

        /// <summary>
        /// Which [root role](https://docs.getunleash.io/reference/rbac#predefined-roles) this user is assigned. Usually a numeric role ID, but can be a string when returning newly created user with an explicit string role.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rootRole", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int RootRole { get; set; }

        /// <summary>
        /// The last time this user logged in
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seenAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? SeenAt { get; set; }

        /// <summary>
        /// The user was created at this time
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset CreatedAt { get; set; }

        /// <summary>
        /// A user is either an actual User or a Service Account
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accountType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AccountType { get; set; }

        /// <summary>
        /// Deprecated
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Permissions { get; set; }

    }

    /// <summary>
    /// An overview of user groups and users.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UsersGroupsBaseSchema
    {
        /// <summary>
        /// A list of user groups and their configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("groups", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<GroupSchema> Groups { get; set; }

        /// <summary>
        /// A list of users.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("users", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<UserSchema> Users { get; set; }

    }

    /// <summary>
    /// Users and root roles
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UsersSchema
    {
        /// <summary>
        /// A list of users in the Unleash instance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("users", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<UserSchema> Users { get; set; } = new System.Collections.Generic.List<UserSchema>();

        /// <summary>
        /// A list of [root roles](https://docs.getunleash.io/reference/rbac#predefined-roles) in the Unleash instance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rootRoles", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<RoleSchema> RootRoles { get; set; }

    }

    /// <summary>
    /// A list of users
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UsersSearchSchema : System.Collections.ObjectModel.Collection<UserSchema>
    {

    }

    /// <summary>
    /// A object containing a list of valid Unleash tokens.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ValidatedEdgeTokensSchema
    {
        /// <summary>
        /// The list of Unleash token objects. Each object contains the token itself and some additional metadata.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokens", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<EdgeTokenSchema> Tokens { get; set; } = new System.Collections.Generic.List<EdgeTokenSchema>();

    }

    /// <summary>
    /// Data used to validate a feature toggle's name.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ValidateFeatureSchema
    {
        /// <summary>
        /// The feature name to validate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Used to validate passwords obeying [Unleash password guidelines](https://docs.getunleash.io/reference/deploy/securing-unleash#password-requirements)
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ValidatePasswordSchema
    {
        /// <summary>
        /// The password to validate
        /// </summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }

    }

    /// <summary>
    /// The result of validating a tag type.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ValidateTagTypeSchema
    {
        /// <summary>
        /// Whether or not the tag type is valid.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("valid", Required = Newtonsoft.Json.Required.Always)]
        public bool Valid { get; set; }

        [Newtonsoft.Json.JsonProperty("tagType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public TagTypeSchema TagType { get; set; } = new TagTypeSchema();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// A variant allows for further separation of users into segments. See [our excellent documentation](https://docs.getunleash.io/reference/feature-toggle-variants#what-are-variants) for a more detailed description
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VariantSchema
    {
        /// <summary>
        /// The variants name. Is unique for this feature toggle
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The weight is the likelihood of any one user getting this variant. It is a number between 0 and 1000. See the section on [variant weights](https://docs.getunleash.io/reference/feature-toggle-variants#variant-weight) for more information
        /// </summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0D, 1000D)]
        public double Weight { get; set; }

        /// <summary>
        /// Set to fix if this variant must have exactly the weight allocated to it. If the type is variable, the weight will adjust so that the total weight of all variants adds up to 1000
        /// </summary>
        [Newtonsoft.Json.JsonProperty("weightType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public VariantSchemaWeightType WeightType { get; set; }

        /// <summary>
        /// [Stickiness](https://docs.getunleash.io/reference/feature-toggle-variants#variant-stickiness) is how Unleash guarantees that the same user gets the same variant every time
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stickiness", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stickiness { get; set; }

        /// <summary>
        /// Extra data configured for this variant
        /// </summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Payload Payload { get; set; }

        /// <summary>
        /// Overrides assigning specific variants to specific users. The weighting system automatically assigns users to specific groups for you, but any overrides in this list will take precedence.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overrides", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<OverrideSchema> Overrides { get; set; }

    }

    /// <summary>
    /// A representation of an evaluated Unleash feature variant.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VariantFlagSchema
    {
        /// <summary>
        /// The name of the variant. Will always be disabled if `enabled` is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Whether the variant is enabled or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Enabled { get; set; }

        /// <summary>
        /// Additional data associated with this variant.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Payload2 Payload { get; set; }

    }

    /// <summary>
    /// A list of variants
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VariantsSchema : System.Collections.ObjectModel.Collection<VariantSchema>
    {

    }

    /// <summary>
    /// Detailed information about an Unleash version
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VersionSchema
    {
        /// <summary>
        /// The current version of Unleash.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("current", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Current Current { get; set; } = new Current();

        /// <summary>
        /// Information about the latest available Unleash releases. Will be an empty object if no data is available.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("latest", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Latest Latest { get; set; } = new Latest();

        /// <summary>
        /// Whether the Unleash server is running the latest release (`true`) or if there are updates available (`false`)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isLatest", Required = Newtonsoft.Json.Required.Always)]
        public bool IsLatest { get; set; }

        /// <summary>
        /// The instance identifier of the Unleash instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instanceId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InstanceId { get; set; }

    }

    /// <summary>
    /// A high-level overview of a project. It contains information such as project statistics, the name of the project, what members and what features it contains, etc.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProjectOverviewSchema
    {
        /// <summary>
        /// Project statistics
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stats", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProjectStatsSchema Stats { get; set; }

        /// <summary>
        /// The schema version used to describe the project overview
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public int Version { get; set; }

        /// <summary>
        /// The name of this project
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Additional information about the project
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// A default stickiness for the project affecting the default stickiness value for variants and Gradual Rollout strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultStickiness", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DefaultStickiness { get; set; }

        /// <summary>
        /// The project's [collaboration mode](https://docs.getunleash.io/reference/project-collaboration-mode). Determines whether non-project members can submit change requests or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProjectOverviewSchemaMode Mode { get; set; }

        /// <summary>
        /// A limit on the number of features allowed in the project. Null if no limit.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureLimit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FeatureLimit { get; set; }

        /// <summary>
        /// The number of members this project has
        /// </summary>
        [Newtonsoft.Json.JsonProperty("members", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Members { get; set; }

        /// <summary>
        /// An indicator of the [project's health](https://docs.getunleash.io/reference/technical-debt#health-rating) on a scale from 0 to 100
        /// </summary>
        [Newtonsoft.Json.JsonProperty("health", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Health { get; set; }

        /// <summary>
        /// The environments that are enabled for this project
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environments", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ProjectEnvironmentSchema> Environments { get; set; }

        /// <summary>
        /// The full list of features in this project (excluding archived features)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<FeatureSchema> Features { get; set; }

        /// <summary>
        /// When the project was last updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("updatedAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? UpdatedAt { get; set; }

        /// <summary>
        /// When the project was created.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreatedAt { get; set; }

        /// <summary>
        /// `true` if the project was favorited, otherwise `false`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("favorite", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Favorite { get; set; }

    }

    /// <summary>
    /// The result of the export operation for a project and environment, used at import
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ImportTogglesSchema
    {
        /// <summary>
        /// The exported [project](https://docs.getunleash.io/reference/projects)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Project { get; set; }

        /// <summary>
        /// The exported [environment](https://docs.getunleash.io/reference/environments)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Environment { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ExportResultSchema Data { get; set; } = new ExportResultSchema();

    }

    /// <summary>
    /// An object containing [feature import](https://docs.getunleash.io/reference/deploy/environment-import-export) validation results.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ImportTogglesValidateSchema
    {
        /// <summary>
        /// A list of errors that prevent the provided data from being successfully imported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("errors", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<ImportTogglesValidateItemSchema> Errors { get; set; } = new System.Collections.Generic.List<ImportTogglesValidateItemSchema>();

        /// <summary>
        /// A list of warnings related to the provided data.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("warnings", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<ImportTogglesValidateItemSchema> Warnings { get; set; } = new System.Collections.Generic.List<ImportTogglesValidateItemSchema>();

        /// <summary>
        /// Any additional permissions required to import the data. If the list is empty, you require no additional permissions beyond what your user already has.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ImportTogglesValidateItemSchema> Permissions { get; set; }

    }

    /// <summary>
    /// A description of an error or warning pertaining to a feature toggle import job.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ImportTogglesValidateItemSchema
    {
        /// <summary>
        /// The validation error message
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Message { get; set; }

        /// <summary>
        /// The items affected by this error message 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("affectedItems", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> AffectedItems { get; set; } = new System.Collections.Generic.List<string>();

    }

    /// <summary>
    /// A wrapper object containing all strategies that use a specific context field
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContextFieldStrategiesSchema
    {
        /// <summary>
        /// List of strategies using the context field
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategies", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<Strategies4> Strategies { get; set; } = new System.Collections.Generic.List<Strategies4>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Contains information about which settings are configured for version info collection and feature usage collection.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TelemetrySettingsSchema
    {
        /// <summary>
        /// Whether collection of version info is enabled/active.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("versionInfoCollectionEnabled", Required = Newtonsoft.Json.Required.Always)]
        public bool VersionInfoCollectionEnabled { get; set; }

        /// <summary>
        /// Whether collection of feature usage metrics is enabled/active.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureInfoCollectionEnabled", Required = Newtonsoft.Json.Required.Always)]
        public bool FeatureInfoCollectionEnabled { get; set; }

    }

    /// <summary>
    /// This is an experimental property. It may change or be removed as we work on it. Please don't depend on it yet. A strategy variant allows you to attach any data to strategies instead of only returning `true`/`false`. Strategy variants take precedence over feature variants.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StrategyVariantSchema
    {
        /// <summary>
        /// The variant name. Must be unique for this feature toggle
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The weight is the likelihood of any one user getting this variant. It is an integer between 0 and 1000. See the section on [variant weights](https://docs.getunleash.io/reference/feature-toggle-variants#variant-weight) for more information
        /// </summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 1000)]
        public int Weight { get; set; }

        /// <summary>
        /// Set to `fix` if this variant must have exactly the weight allocated to it. If the type is `variable`, the weight will adjust so that the total weight of all variants adds up to 1000. Refer to the [variant weight documentation](https://docs.getunleash.io/reference/feature-toggle-variants#variant-weight).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("weightType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public StrategyVariantSchemaWeightType WeightType { get; set; }

        /// <summary>
        /// The [stickiness](https://docs.getunleash.io/reference/feature-toggle-variants#variant-stickiness) to use for distribution of this variant. Stickiness is how Unleash guarantees that the same user gets the same variant every time
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stickiness", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Stickiness { get; set; }

        /// <summary>
        /// Extra data configured for this variant
        /// </summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Payload3 Payload { get; set; }

    }

    /// <summary>
    /// This is an experimental property. It may change or be removed as we work on it. Please don't depend on it yet. A strategy variant allows you to attach any data to strategies instead of only returning `true`/`false`. Strategy variants take precedence over feature variants.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateStrategyVariantSchema
    {
        /// <summary>
        /// The variant name. Must be unique for this feature toggle
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The weight is the likelihood of any one user getting this variant. It is an integer between 0 and 1000. See the section on [variant weights](https://docs.getunleash.io/reference/feature-toggle-variants#variant-weight) for more information
        /// </summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 1000)]
        public int Weight { get; set; }

        /// <summary>
        /// Set to `fix` if this variant must have exactly the weight allocated to it. If the type is `variable`, the weight will adjust so that the total weight of all variants adds up to 1000. Refer to the [variant weight documentation](https://docs.getunleash.io/reference/feature-toggle-variants#variant-weight).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("weightType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CreateStrategyVariantSchemaWeightType WeightType { get; set; }

        /// <summary>
        /// The [stickiness](https://docs.getunleash.io/reference/feature-toggle-variants#variant-stickiness) to use for distribution of this variant. Stickiness is how Unleash guarantees that the same user gets the same variant every time
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stickiness", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Stickiness { get; set; }

        /// <summary>
        /// Extra data configured for this variant
        /// </summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Payload4 Payload { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Represents a client API segment of users defined by a set of constraints.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClientSegmentSchema
    {
        /// <summary>
        /// The segment's id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        public double Id { get; set; }

        /// <summary>
        /// The name of the segment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// List of constraints that determine which users are part of the segment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("constraints", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<ConstraintSchema> Constraints { get; set; } = new System.Collections.Generic.List<ConstraintSchema>();

    }

    /// <summary>
    /// A detailed information about a user group
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateGroupSchema
    {
        /// <summary>
        /// The name of the group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// A custom description of the group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// A list of SSO groups that should map to this Unleash group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mappingsSSO", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> MappingsSSO { get; set; }

        /// <summary>
        /// A role id that is used as the root role for all users in this group. This can be either the id of the Viewer, Editor or Admin role.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rootRole", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? RootRole { get; set; }

        /// <summary>
        /// A list of users belonging to this group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("users", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Users> Users { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Format
    {

        [System.Runtime.Serialization.EnumMember(Value = @"json")]
        Json = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"yaml")]
        Yaml = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Download
    {

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Strategies
    {

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FeatureToggles
    {

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Projects
    {

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Tags
    {

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Environments
    {

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// A strategy with its new sort order
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Anonymous
    {
        /// <summary>
        /// The ID of the strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The new sort order of the strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sortOrder", Required = Newtonsoft.Json.Required.Always)]
        public double SortOrder { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Installation
    {
        /// <summary>
        /// A URL to where the addon configuration should redirect to install addons of this type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Url { get; set; }

        /// <summary>
        /// The title of the installation configuration. This will be displayed to the user when installing addons of this type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Title { get; set; }

        /// <summary>
        /// The help text of the installation configuration. This will be displayed to the user when installing addons of this type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("helpText", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HelpText { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Alerts
    {
        /// <summary>
        /// The type of alert. This determines the color of the alert.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AlertsType Type { get; set; }

        /// <summary>
        /// The text of the alert. This is what will be displayed to the user.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Text { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Strategies2
    {
        /// <summary>
        /// The cumulative results of all the feature's strategies. Can be `true`,
        /// <br/>                                  `false`, or `unknown`.
        /// <br/>                                  This property will only be `unknown`
        /// <br/>                                  if one or more of the strategies can't be fully evaluated and the rest of the strategies
        /// <br/>                                  all resolve to `false`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Always)]
        public Result2 Result { get; set; }

        /// <summary>
        /// The strategies that apply to this feature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<PlaygroundStrategySchema> Data { get; set; } = new System.Collections.Generic.List<PlaygroundStrategySchema>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Variant
    {
        /// <summary>
        /// The variant's name. If there is no variant or if the toggle is disabled, this will be `disabled`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Whether the variant is enabled or not. If the feature is disabled or if it doesn't have variants, this property will be `false`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }

        /// <summary>
        /// An optional payload attached to the variant.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Payload5 Payload { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ApiTokenSchemaType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"client")]
        Client = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"admin")]
        Admin = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"frontend")]
        Frontend = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectVia
    {
        [Newtonsoft.Json.JsonProperty("appName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AppName { get; set; }

        [Newtonsoft.Json.JsonProperty("instanceId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string InstanceId { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Bucket
    {
        /// <summary>
        /// The start of the time window these metrics are valid for. The window is usually 1 hour wide
        /// </summary>
        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Start { get; set; }

        /// <summary>
        /// The end of the time window these metrics are valid for. The window is 1 hour wide
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stop", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Stop { get; set; }

        /// <summary>
        /// an object containing feature names with yes/no plus variant usage
        /// </summary>
        [Newtonsoft.Json.JsonProperty("toggles", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IDictionary<string, Anonymous4> Toggles { get; set; } = new System.Collections.Generic.Dictionary<string, Anonymous4>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConstraintSchemaOperator
    {

        [System.Runtime.Serialization.EnumMember(Value = @"NOT_IN")]
        NOT_IN = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"IN")]
        IN = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"STR_ENDS_WITH")]
        STR_ENDS_WITH = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"STR_STARTS_WITH")]
        STR_STARTS_WITH = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"STR_CONTAINS")]
        STR_CONTAINS = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"NUM_EQ")]
        NUM_EQ = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"NUM_GT")]
        NUM_GT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"NUM_GTE")]
        NUM_GTE = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"NUM_LT")]
        NUM_LT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"NUM_LTE")]
        NUM_LTE = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"DATE_AFTER")]
        DATE_AFTER = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"DATE_BEFORE")]
        DATE_BEFORE = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"SEMVER_EQ")]
        SEMVER_EQ = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"SEMVER_GT")]
        SEMVER_GT = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"SEMVER_LT")]
        SEMVER_LT = 14,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Anonymous2
    {
        /// <summary>
        /// An admin token. Must be the string "admin" (not case sensitive).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[Aa][Dd][Mm][Ii][Nn]$")]
        public string Type { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EdgeTokenSchemaType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"client")]
        Client = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"admin")]
        Admin = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"frontend")]
        Frontend = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EventSchemaType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"application-created")]
        ApplicationCreated = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-created")]
        FeatureCreated = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-deleted")]
        FeatureDeleted = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-updated")]
        FeatureUpdated = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-metadata-updated")]
        FeatureMetadataUpdated = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-variants-updated")]
        FeatureVariantsUpdated = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-environment-variants-updated")]
        FeatureEnvironmentVariantsUpdated = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-project-change")]
        FeatureProjectChange = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-archived")]
        FeatureArchived = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-revived")]
        FeatureRevived = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-import")]
        FeatureImport = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-tagged")]
        FeatureTagged = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-tag-import")]
        FeatureTagImport = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-strategy-update")]
        FeatureStrategyUpdate = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-strategy-add")]
        FeatureStrategyAdd = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-strategy-remove")]
        FeatureStrategyRemove = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"strategy-order-changed")]
        StrategyOrderChanged = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"drop-feature-tags")]
        DropFeatureTags = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-untagged")]
        FeatureUntagged = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-stale-on")]
        FeatureStaleOn = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-stale-off")]
        FeatureStaleOff = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"drop-features")]
        DropFeatures = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-environment-enabled")]
        FeatureEnvironmentEnabled = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-environment-disabled")]
        FeatureEnvironmentDisabled = 23,

        [System.Runtime.Serialization.EnumMember(Value = @"strategy-created")]
        StrategyCreated = 24,

        [System.Runtime.Serialization.EnumMember(Value = @"strategy-deleted")]
        StrategyDeleted = 25,

        [System.Runtime.Serialization.EnumMember(Value = @"strategy-deprecated")]
        StrategyDeprecated = 26,

        [System.Runtime.Serialization.EnumMember(Value = @"strategy-reactivated")]
        StrategyReactivated = 27,

        [System.Runtime.Serialization.EnumMember(Value = @"strategy-updated")]
        StrategyUpdated = 28,

        [System.Runtime.Serialization.EnumMember(Value = @"strategy-import")]
        StrategyImport = 29,

        [System.Runtime.Serialization.EnumMember(Value = @"drop-strategies")]
        DropStrategies = 30,

        [System.Runtime.Serialization.EnumMember(Value = @"context-field-created")]
        ContextFieldCreated = 31,

        [System.Runtime.Serialization.EnumMember(Value = @"context-field-updated")]
        ContextFieldUpdated = 32,

        [System.Runtime.Serialization.EnumMember(Value = @"context-field-deleted")]
        ContextFieldDeleted = 33,

        [System.Runtime.Serialization.EnumMember(Value = @"project-access-added")]
        ProjectAccessAdded = 34,

        [System.Runtime.Serialization.EnumMember(Value = @"project-created")]
        ProjectCreated = 35,

        [System.Runtime.Serialization.EnumMember(Value = @"project-updated")]
        ProjectUpdated = 36,

        [System.Runtime.Serialization.EnumMember(Value = @"project-deleted")]
        ProjectDeleted = 37,

        [System.Runtime.Serialization.EnumMember(Value = @"project-import")]
        ProjectImport = 38,

        [System.Runtime.Serialization.EnumMember(Value = @"project-user-added")]
        ProjectUserAdded = 39,

        [System.Runtime.Serialization.EnumMember(Value = @"project-user-removed")]
        ProjectUserRemoved = 40,

        [System.Runtime.Serialization.EnumMember(Value = @"project-user-role-changed")]
        ProjectUserRoleChanged = 41,

        [System.Runtime.Serialization.EnumMember(Value = @"project-group-role-changed")]
        ProjectGroupRoleChanged = 42,

        [System.Runtime.Serialization.EnumMember(Value = @"project-group-added")]
        ProjectGroupAdded = 43,

        [System.Runtime.Serialization.EnumMember(Value = @"project-group-removed")]
        ProjectGroupRemoved = 44,

        [System.Runtime.Serialization.EnumMember(Value = @"drop-projects")]
        DropProjects = 45,

        [System.Runtime.Serialization.EnumMember(Value = @"tag-created")]
        TagCreated = 46,

        [System.Runtime.Serialization.EnumMember(Value = @"tag-deleted")]
        TagDeleted = 47,

        [System.Runtime.Serialization.EnumMember(Value = @"tag-import")]
        TagImport = 48,

        [System.Runtime.Serialization.EnumMember(Value = @"drop-tags")]
        DropTags = 49,

        [System.Runtime.Serialization.EnumMember(Value = @"tag-type-created")]
        TagTypeCreated = 50,

        [System.Runtime.Serialization.EnumMember(Value = @"tag-type-deleted")]
        TagTypeDeleted = 51,

        [System.Runtime.Serialization.EnumMember(Value = @"tag-type-updated")]
        TagTypeUpdated = 52,

        [System.Runtime.Serialization.EnumMember(Value = @"tag-type-import")]
        TagTypeImport = 53,

        [System.Runtime.Serialization.EnumMember(Value = @"drop-tag-types")]
        DropTagTypes = 54,

        [System.Runtime.Serialization.EnumMember(Value = @"addon-config-created")]
        AddonConfigCreated = 55,

        [System.Runtime.Serialization.EnumMember(Value = @"addon-config-updated")]
        AddonConfigUpdated = 56,

        [System.Runtime.Serialization.EnumMember(Value = @"addon-config-deleted")]
        AddonConfigDeleted = 57,

        [System.Runtime.Serialization.EnumMember(Value = @"db-pool-update")]
        DbPoolUpdate = 58,

        [System.Runtime.Serialization.EnumMember(Value = @"user-created")]
        UserCreated = 59,

        [System.Runtime.Serialization.EnumMember(Value = @"user-updated")]
        UserUpdated = 60,

        [System.Runtime.Serialization.EnumMember(Value = @"user-deleted")]
        UserDeleted = 61,

        [System.Runtime.Serialization.EnumMember(Value = @"drop-environments")]
        DropEnvironments = 62,

        [System.Runtime.Serialization.EnumMember(Value = @"environment-import")]
        EnvironmentImport = 63,

        [System.Runtime.Serialization.EnumMember(Value = @"segment-created")]
        SegmentCreated = 64,

        [System.Runtime.Serialization.EnumMember(Value = @"segment-updated")]
        SegmentUpdated = 65,

        [System.Runtime.Serialization.EnumMember(Value = @"segment-deleted")]
        SegmentDeleted = 66,

        [System.Runtime.Serialization.EnumMember(Value = @"group-created")]
        GroupCreated = 67,

        [System.Runtime.Serialization.EnumMember(Value = @"group-updated")]
        GroupUpdated = 68,

        [System.Runtime.Serialization.EnumMember(Value = @"setting-created")]
        SettingCreated = 69,

        [System.Runtime.Serialization.EnumMember(Value = @"setting-updated")]
        SettingUpdated = 70,

        [System.Runtime.Serialization.EnumMember(Value = @"setting-deleted")]
        SettingDeleted = 71,

        [System.Runtime.Serialization.EnumMember(Value = @"client-metrics")]
        ClientMetrics = 72,

        [System.Runtime.Serialization.EnumMember(Value = @"client-register")]
        ClientRegister = 73,

        [System.Runtime.Serialization.EnumMember(Value = @"pat-created")]
        PatCreated = 74,

        [System.Runtime.Serialization.EnumMember(Value = @"pat-deleted")]
        PatDeleted = 75,

        [System.Runtime.Serialization.EnumMember(Value = @"public-signup-token-created")]
        PublicSignupTokenCreated = 76,

        [System.Runtime.Serialization.EnumMember(Value = @"public-signup-token-user-added")]
        PublicSignupTokenUserAdded = 77,

        [System.Runtime.Serialization.EnumMember(Value = @"public-signup-token-updated")]
        PublicSignupTokenUpdated = 78,

        [System.Runtime.Serialization.EnumMember(Value = @"change-request-created")]
        ChangeRequestCreated = 79,

        [System.Runtime.Serialization.EnumMember(Value = @"change-request-discarded")]
        ChangeRequestDiscarded = 80,

        [System.Runtime.Serialization.EnumMember(Value = @"change-added")]
        ChangeAdded = 81,

        [System.Runtime.Serialization.EnumMember(Value = @"change-discarded")]
        ChangeDiscarded = 82,

        [System.Runtime.Serialization.EnumMember(Value = @"change-edited")]
        ChangeEdited = 83,

        [System.Runtime.Serialization.EnumMember(Value = @"change-request-rejected")]
        ChangeRequestRejected = 84,

        [System.Runtime.Serialization.EnumMember(Value = @"change-request-approved")]
        ChangeRequestApproved = 85,

        [System.Runtime.Serialization.EnumMember(Value = @"change-request-approval-added")]
        ChangeRequestApprovalAdded = 86,

        [System.Runtime.Serialization.EnumMember(Value = @"change-request-cancelled")]
        ChangeRequestCancelled = 87,

        [System.Runtime.Serialization.EnumMember(Value = @"change-request-sent-to-review")]
        ChangeRequestSentToReview = 88,

        [System.Runtime.Serialization.EnumMember(Value = @"change-request-applied")]
        ChangeRequestApplied = 89,

        [System.Runtime.Serialization.EnumMember(Value = @"api-token-created")]
        ApiTokenCreated = 90,

        [System.Runtime.Serialization.EnumMember(Value = @"api-token-updated")]
        ApiTokenUpdated = 91,

        [System.Runtime.Serialization.EnumMember(Value = @"api-token-deleted")]
        ApiTokenDeleted = 92,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-favorited")]
        FeatureFavorited = 93,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-unfavorited")]
        FeatureUnfavorited = 94,

        [System.Runtime.Serialization.EnumMember(Value = @"project-favorited")]
        ProjectFavorited = 95,

        [System.Runtime.Serialization.EnumMember(Value = @"project-unfavorited")]
        ProjectUnfavorited = 96,

        [System.Runtime.Serialization.EnumMember(Value = @"features-exported")]
        FeaturesExported = 97,

        [System.Runtime.Serialization.EnumMember(Value = @"features-imported")]
        FeaturesImported = 98,

        [System.Runtime.Serialization.EnumMember(Value = @"service-account-created")]
        ServiceAccountCreated = 99,

        [System.Runtime.Serialization.EnumMember(Value = @"service-account-deleted")]
        ServiceAccountDeleted = 100,

        [System.Runtime.Serialization.EnumMember(Value = @"service-account-updated")]
        ServiceAccountUpdated = 101,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-potentially-stale-on")]
        FeaturePotentiallyStaleOn = 102,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EventsSchemaVersion
    {

        _1 = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Segments
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        public double Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum FeatureEventsSchemaVersion
    {

        _1 = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum FeatureTypesSchemaVersion
    {

        _1 = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum HealthCheckSchemaHealth
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOOD")]
        GOOD = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"BAD")]
        BAD = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum HealthOverviewSchemaMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"open")]
        Open = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"protected")]
        Protected = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum HealthReportSchemaMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"open")]
        Open = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"protected")]
        Protected = 1,

    }

    /// <summary>
    /// An entry describing how many client applications has been observed over the defined range
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClientApps
    {
        /// <summary>
        /// A description of a time range
        /// </summary>
        [Newtonsoft.Json.JsonProperty("range", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ClientAppsRange Range { get; set; }

        /// <summary>
        /// The number of client applications that have been observed in this period
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Count { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PatchSchemaOp
    {

        [System.Runtime.Serialization.EnumMember(Value = @"add")]
        Add = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"remove")]
        Remove = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"replace")]
        Replace = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"copy")]
        Copy = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"move")]
        Move = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PlaygroundConstraintSchemaOperator
    {

        [System.Runtime.Serialization.EnumMember(Value = @"NOT_IN")]
        NOT_IN = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"IN")]
        IN = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"STR_ENDS_WITH")]
        STR_ENDS_WITH = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"STR_STARTS_WITH")]
        STR_STARTS_WITH = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"STR_CONTAINS")]
        STR_CONTAINS = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"NUM_EQ")]
        NUM_EQ = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"NUM_GT")]
        NUM_GT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"NUM_GTE")]
        NUM_GTE = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"NUM_LT")]
        NUM_LT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"NUM_LTE")]
        NUM_LTE = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"DATE_AFTER")]
        DATE_AFTER = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"DATE_BEFORE")]
        DATE_BEFORE = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"SEMVER_EQ")]
        SEMVER_EQ = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"SEMVER_GT")]
        SEMVER_GT = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"SEMVER_LT")]
        SEMVER_LT = 14,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Strategies3
    {
        /// <summary>
        /// The cumulative results of all the feature's strategies. Can be `true`,
        /// <br/>                                  `false`, or `unknown`.
        /// <br/>                                  This property will only be `unknown`
        /// <br/>                                  if one or more of the strategies can't be fully evaluated and the rest of the strategies
        /// <br/>                                  all resolve to `false`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Always)]
        public Result3 Result { get; set; }

        /// <summary>
        /// The strategies that apply to this feature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<PlaygroundStrategySchema> Data { get; set; } = new System.Collections.Generic.List<PlaygroundStrategySchema>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Variant2
    {
        /// <summary>
        /// The variant's name. If there is no variant or if the toggle is disabled, this will be `disabled`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Whether the variant is enabled or not. If the feature is disabled or if it doesn't have variants, this property will be `false`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }

        /// <summary>
        /// An optional payload attached to the variant.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Payload6 Payload { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Result
    {

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Links
    {
        [Newtonsoft.Json.JsonProperty("edit", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Edit { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ProjectSchemaMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"open")]
        Open = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"protected")]
        Protected = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Variant3
    {
        /// <summary>
        /// The variants name. Is unique for this feature toggle
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Whether the variant is enabled or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }

        /// <summary>
        /// Extra data configured for this variant
        /// </summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Payload7 Payload { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RequestsPerSecondSchemaStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"success")]
        Success = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"failure")]
        Failure = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Data
    {
        /// <summary>
        /// Prometheus compatible result type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resultType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DataResultType ResultType { get; set; }

        /// <summary>
        /// An array of values per metric. Each one represents a line in the graph labeled by its metric name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Result4> Result { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SearchEventsSchemaType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"application-created")]
        ApplicationCreated = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-created")]
        FeatureCreated = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-deleted")]
        FeatureDeleted = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-updated")]
        FeatureUpdated = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-metadata-updated")]
        FeatureMetadataUpdated = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-variants-updated")]
        FeatureVariantsUpdated = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-environment-variants-updated")]
        FeatureEnvironmentVariantsUpdated = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-project-change")]
        FeatureProjectChange = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-archived")]
        FeatureArchived = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-revived")]
        FeatureRevived = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-import")]
        FeatureImport = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-tagged")]
        FeatureTagged = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-tag-import")]
        FeatureTagImport = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-strategy-update")]
        FeatureStrategyUpdate = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-strategy-add")]
        FeatureStrategyAdd = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-strategy-remove")]
        FeatureStrategyRemove = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"strategy-order-changed")]
        StrategyOrderChanged = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"drop-feature-tags")]
        DropFeatureTags = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-untagged")]
        FeatureUntagged = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-stale-on")]
        FeatureStaleOn = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-stale-off")]
        FeatureStaleOff = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"drop-features")]
        DropFeatures = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-environment-enabled")]
        FeatureEnvironmentEnabled = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-environment-disabled")]
        FeatureEnvironmentDisabled = 23,

        [System.Runtime.Serialization.EnumMember(Value = @"strategy-created")]
        StrategyCreated = 24,

        [System.Runtime.Serialization.EnumMember(Value = @"strategy-deleted")]
        StrategyDeleted = 25,

        [System.Runtime.Serialization.EnumMember(Value = @"strategy-deprecated")]
        StrategyDeprecated = 26,

        [System.Runtime.Serialization.EnumMember(Value = @"strategy-reactivated")]
        StrategyReactivated = 27,

        [System.Runtime.Serialization.EnumMember(Value = @"strategy-updated")]
        StrategyUpdated = 28,

        [System.Runtime.Serialization.EnumMember(Value = @"strategy-import")]
        StrategyImport = 29,

        [System.Runtime.Serialization.EnumMember(Value = @"drop-strategies")]
        DropStrategies = 30,

        [System.Runtime.Serialization.EnumMember(Value = @"context-field-created")]
        ContextFieldCreated = 31,

        [System.Runtime.Serialization.EnumMember(Value = @"context-field-updated")]
        ContextFieldUpdated = 32,

        [System.Runtime.Serialization.EnumMember(Value = @"context-field-deleted")]
        ContextFieldDeleted = 33,

        [System.Runtime.Serialization.EnumMember(Value = @"project-access-added")]
        ProjectAccessAdded = 34,

        [System.Runtime.Serialization.EnumMember(Value = @"project-created")]
        ProjectCreated = 35,

        [System.Runtime.Serialization.EnumMember(Value = @"project-updated")]
        ProjectUpdated = 36,

        [System.Runtime.Serialization.EnumMember(Value = @"project-deleted")]
        ProjectDeleted = 37,

        [System.Runtime.Serialization.EnumMember(Value = @"project-import")]
        ProjectImport = 38,

        [System.Runtime.Serialization.EnumMember(Value = @"project-user-added")]
        ProjectUserAdded = 39,

        [System.Runtime.Serialization.EnumMember(Value = @"project-user-removed")]
        ProjectUserRemoved = 40,

        [System.Runtime.Serialization.EnumMember(Value = @"project-user-role-changed")]
        ProjectUserRoleChanged = 41,

        [System.Runtime.Serialization.EnumMember(Value = @"project-group-role-changed")]
        ProjectGroupRoleChanged = 42,

        [System.Runtime.Serialization.EnumMember(Value = @"project-group-added")]
        ProjectGroupAdded = 43,

        [System.Runtime.Serialization.EnumMember(Value = @"project-group-removed")]
        ProjectGroupRemoved = 44,

        [System.Runtime.Serialization.EnumMember(Value = @"drop-projects")]
        DropProjects = 45,

        [System.Runtime.Serialization.EnumMember(Value = @"tag-created")]
        TagCreated = 46,

        [System.Runtime.Serialization.EnumMember(Value = @"tag-deleted")]
        TagDeleted = 47,

        [System.Runtime.Serialization.EnumMember(Value = @"tag-import")]
        TagImport = 48,

        [System.Runtime.Serialization.EnumMember(Value = @"drop-tags")]
        DropTags = 49,

        [System.Runtime.Serialization.EnumMember(Value = @"tag-type-created")]
        TagTypeCreated = 50,

        [System.Runtime.Serialization.EnumMember(Value = @"tag-type-deleted")]
        TagTypeDeleted = 51,

        [System.Runtime.Serialization.EnumMember(Value = @"tag-type-updated")]
        TagTypeUpdated = 52,

        [System.Runtime.Serialization.EnumMember(Value = @"tag-type-import")]
        TagTypeImport = 53,

        [System.Runtime.Serialization.EnumMember(Value = @"drop-tag-types")]
        DropTagTypes = 54,

        [System.Runtime.Serialization.EnumMember(Value = @"addon-config-created")]
        AddonConfigCreated = 55,

        [System.Runtime.Serialization.EnumMember(Value = @"addon-config-updated")]
        AddonConfigUpdated = 56,

        [System.Runtime.Serialization.EnumMember(Value = @"addon-config-deleted")]
        AddonConfigDeleted = 57,

        [System.Runtime.Serialization.EnumMember(Value = @"db-pool-update")]
        DbPoolUpdate = 58,

        [System.Runtime.Serialization.EnumMember(Value = @"user-created")]
        UserCreated = 59,

        [System.Runtime.Serialization.EnumMember(Value = @"user-updated")]
        UserUpdated = 60,

        [System.Runtime.Serialization.EnumMember(Value = @"user-deleted")]
        UserDeleted = 61,

        [System.Runtime.Serialization.EnumMember(Value = @"drop-environments")]
        DropEnvironments = 62,

        [System.Runtime.Serialization.EnumMember(Value = @"environment-import")]
        EnvironmentImport = 63,

        [System.Runtime.Serialization.EnumMember(Value = @"segment-created")]
        SegmentCreated = 64,

        [System.Runtime.Serialization.EnumMember(Value = @"segment-updated")]
        SegmentUpdated = 65,

        [System.Runtime.Serialization.EnumMember(Value = @"segment-deleted")]
        SegmentDeleted = 66,

        [System.Runtime.Serialization.EnumMember(Value = @"group-created")]
        GroupCreated = 67,

        [System.Runtime.Serialization.EnumMember(Value = @"group-updated")]
        GroupUpdated = 68,

        [System.Runtime.Serialization.EnumMember(Value = @"setting-created")]
        SettingCreated = 69,

        [System.Runtime.Serialization.EnumMember(Value = @"setting-updated")]
        SettingUpdated = 70,

        [System.Runtime.Serialization.EnumMember(Value = @"setting-deleted")]
        SettingDeleted = 71,

        [System.Runtime.Serialization.EnumMember(Value = @"client-metrics")]
        ClientMetrics = 72,

        [System.Runtime.Serialization.EnumMember(Value = @"client-register")]
        ClientRegister = 73,

        [System.Runtime.Serialization.EnumMember(Value = @"pat-created")]
        PatCreated = 74,

        [System.Runtime.Serialization.EnumMember(Value = @"pat-deleted")]
        PatDeleted = 75,

        [System.Runtime.Serialization.EnumMember(Value = @"public-signup-token-created")]
        PublicSignupTokenCreated = 76,

        [System.Runtime.Serialization.EnumMember(Value = @"public-signup-token-user-added")]
        PublicSignupTokenUserAdded = 77,

        [System.Runtime.Serialization.EnumMember(Value = @"public-signup-token-updated")]
        PublicSignupTokenUpdated = 78,

        [System.Runtime.Serialization.EnumMember(Value = @"change-request-created")]
        ChangeRequestCreated = 79,

        [System.Runtime.Serialization.EnumMember(Value = @"change-request-discarded")]
        ChangeRequestDiscarded = 80,

        [System.Runtime.Serialization.EnumMember(Value = @"change-added")]
        ChangeAdded = 81,

        [System.Runtime.Serialization.EnumMember(Value = @"change-discarded")]
        ChangeDiscarded = 82,

        [System.Runtime.Serialization.EnumMember(Value = @"change-edited")]
        ChangeEdited = 83,

        [System.Runtime.Serialization.EnumMember(Value = @"change-request-rejected")]
        ChangeRequestRejected = 84,

        [System.Runtime.Serialization.EnumMember(Value = @"change-request-approved")]
        ChangeRequestApproved = 85,

        [System.Runtime.Serialization.EnumMember(Value = @"change-request-approval-added")]
        ChangeRequestApprovalAdded = 86,

        [System.Runtime.Serialization.EnumMember(Value = @"change-request-cancelled")]
        ChangeRequestCancelled = 87,

        [System.Runtime.Serialization.EnumMember(Value = @"change-request-sent-to-review")]
        ChangeRequestSentToReview = 88,

        [System.Runtime.Serialization.EnumMember(Value = @"change-request-applied")]
        ChangeRequestApplied = 89,

        [System.Runtime.Serialization.EnumMember(Value = @"api-token-created")]
        ApiTokenCreated = 90,

        [System.Runtime.Serialization.EnumMember(Value = @"api-token-updated")]
        ApiTokenUpdated = 91,

        [System.Runtime.Serialization.EnumMember(Value = @"api-token-deleted")]
        ApiTokenDeleted = 92,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-favorited")]
        FeatureFavorited = 93,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-unfavorited")]
        FeatureUnfavorited = 94,

        [System.Runtime.Serialization.EnumMember(Value = @"project-favorited")]
        ProjectFavorited = 95,

        [System.Runtime.Serialization.EnumMember(Value = @"project-unfavorited")]
        ProjectUnfavorited = 96,

        [System.Runtime.Serialization.EnumMember(Value = @"features-exported")]
        FeaturesExported = 97,

        [System.Runtime.Serialization.EnumMember(Value = @"features-imported")]
        FeaturesImported = 98,

        [System.Runtime.Serialization.EnumMember(Value = @"service-account-created")]
        ServiceAccountCreated = 99,

        [System.Runtime.Serialization.EnumMember(Value = @"service-account-deleted")]
        ServiceAccountDeleted = 100,

        [System.Runtime.Serialization.EnumMember(Value = @"service-account-updated")]
        ServiceAccountUpdated = 101,

        [System.Runtime.Serialization.EnumMember(Value = @"feature-potentially-stale-on")]
        FeaturePotentiallyStaleOn = 102,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FrontendSettings
    {
        /// <summary>
        /// The list of origins that the front-end API should accept requests from.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("frontendApiOrigins", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> FrontendApiOrigins { get; set; } = new System.Collections.Generic.List<string>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum StrategiesSchemaVersion
    {

        _1 = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Parameters
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        [Newtonsoft.Json.JsonProperty("required", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Required { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Anonymous3
    {

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum UiConfigSchemaAuthenticationType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"open-source")]
        OpenSource = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"demo")]
        Demo = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"enterprise")]
        Enterprise = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"hosted")]
        Hosted = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"custom")]
        Custom = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"none")]
        None = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Parameters2
    {
        /// <summary>
        /// The name of the parameter
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The [type of the parameter](https://docs.getunleash.io/reference/custom-activation-strategies#parameter-types)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Parameters2Type Type { get; set; }

        /// <summary>
        /// A description of this strategy parameter. Use this to indicate to the users what the parameter does.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// Whether this parameter must be configured when using the strategy. Defaults to `false`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("required", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Required { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Parameters3
    {
        /// <summary>
        /// The name of the parameter
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The [type of the parameter](https://docs.getunleash.io/reference/custom-activation-strategies#parameter-types)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Parameters3Type Type { get; set; }

        /// <summary>
        /// A description of this strategy parameter. Use this to indicate to the users what the parameter does.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// Whether this parameter must be configured when using the strategy. Defaults to `false`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("required", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Required { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum VariantSchemaWeightType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"variable")]
        Variable = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"fix")]
        Fix = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Payload
    {
        /// <summary>
        /// The type of the value. Commonly used types are string, json and csv.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PayloadType Type { get; set; }

        /// <summary>
        /// The actual value of payload
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Payload2
    {
        /// <summary>
        /// The type of data contained.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Payload2Type Type { get; set; }

        /// <summary>
        /// The actual associated data
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Current
    {
        /// <summary>
        /// The OSS version used when building this Unleash instance, represented as a git revision belonging to the [main Unleash git repo](https://github.com/Unleash/unleash/)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oss", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Oss { get; set; }

        /// <summary>
        /// The Enterpris version of Unleash used to build this instance, represented as a git revision belonging to the [Unleash Enterprise](https://github.com/ivarconr/unleash-enterprise) repository. Will be an empty string if no enterprise version was used,
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enterprise", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enterprise { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Latest
    {
        /// <summary>
        /// The latest available OSS version of Unleash
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oss", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Oss { get; set; }

        /// <summary>
        /// The latest available Enterprise version of Unleash
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enterprise", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Enterprise { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ProjectOverviewSchemaMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"open")]
        Open = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"protected")]
        Protected = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Strategies4
    {
        /// <summary>
        /// The ID of the strategy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The name of the feature that contains this strategy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("featureName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FeatureName { get; set; }

        /// <summary>
        /// The ID of the project that contains this feature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projectId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ProjectId { get; set; }

        /// <summary>
        /// The ID of the environment where this strategy is in.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("environment", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Environment { get; set; }

        /// <summary>
        /// The name of the strategy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategyName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string StrategyName { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum StrategyVariantSchemaWeightType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"variable")]
        Variable = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"fix")]
        Fix = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Payload3
    {
        /// <summary>
        /// The type of the value. Commonly used types are string, json and csv.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Payload3Type Type { get; set; }

        /// <summary>
        /// The actual value of payload
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CreateStrategyVariantSchemaWeightType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"variable")]
        Variable = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"fix")]
        Fix = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Payload4
    {
        /// <summary>
        /// The type of the value. Commonly used types are string, json and csv.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Payload4Type Type { get; set; }

        /// <summary>
        /// The actual value of payload
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// A minimal user object
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Users
    {
        /// <summary>
        /// A minimal user object
        /// </summary>
        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public User User { get; set; } = new User();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AlertsType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"success")]
        Success = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"info")]
        Info = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"warning")]
        Warning = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"error")]
        Error = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Result2
    {

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Payload5
    {
        /// <summary>
        /// The format of the payload.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }

        /// <summary>
        /// The payload value stringified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Anonymous4
    {
        /// <summary>
        /// How many times the toggle evaluated to true
        /// </summary>
        [Newtonsoft.Json.JsonProperty("yes", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double Yes { get; set; }

        /// <summary>
        /// How many times the toggle evaluated to false
        /// </summary>
        [Newtonsoft.Json.JsonProperty("no", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int No { get; set; }

        /// <summary>
        /// An object describing how many times each variant was returned. Variant names are used as properties, and the number of times they were exposed is the corresponding value (i.e. `{ [variantName]: number }`).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("variants", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, int> Variants { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ClientAppsRange
    {

        [System.Runtime.Serialization.EnumMember(Value = @"allTime")]
        AllTime = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"30d")]
        _30d = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"7d")]
        _7d = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Result3
    {

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Payload6
    {
        /// <summary>
        /// The format of the payload.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }

        /// <summary>
        /// The payload value stringified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Payload7
    {
        /// <summary>
        /// The format of the payload.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Payload7Type Type { get; set; }

        /// <summary>
        /// The payload value stringified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum DataResultType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"matrix")]
        Matrix = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"vector")]
        Vector = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"scalar")]
        Scalar = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"string")]
        String = 3,

    }

    /// <summary>
    /// A representation of a single metric to build a line in a graph
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Result4
    {
        /// <summary>
        /// A key value set representing the metric
        /// </summary>
        [Newtonsoft.Json.JsonProperty("metric", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Metric Metric { get; set; }

        /// <summary>
        /// An array of arrays. Each element of the array is an array of size 2 consisting of the 2 axis for the graph: in position zero the x axis represented as a number and position one the y axis represented as string
        /// </summary>
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<System.Collections.Generic.List<Anonymous5>> Values { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Parameters2Type
    {

        [System.Runtime.Serialization.EnumMember(Value = @"string")]
        String = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"percentage")]
        Percentage = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"list")]
        List = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"number")]
        Number = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"boolean")]
        Boolean = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Parameters3Type
    {

        [System.Runtime.Serialization.EnumMember(Value = @"string")]
        String = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"percentage")]
        Percentage = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"list")]
        List = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"number")]
        Number = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"boolean")]
        Boolean = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PayloadType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"json")]
        Json = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"csv")]
        Csv = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"string")]
        String = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Payload2Type
    {

        [System.Runtime.Serialization.EnumMember(Value = @"string")]
        String = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"json")]
        Json = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"csv")]
        Csv = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Payload3Type
    {

        [System.Runtime.Serialization.EnumMember(Value = @"json")]
        Json = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"csv")]
        Csv = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"string")]
        String = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Payload4Type
    {

        [System.Runtime.Serialization.EnumMember(Value = @"json")]
        Json = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"csv")]
        Csv = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"string")]
        String = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class User
    {
        /// <summary>
        /// The user id
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Payload7Type
    {

        [System.Runtime.Serialization.EnumMember(Value = @"json")]
        Json = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"csv")]
        Csv = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"string")]
        String = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Metric
    {
        /// <summary>
        /// Name of the application this metric relates to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AppName { get; set; }

        /// <summary>
        /// Which endpoint has been accessed
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endpoint", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Endpoint { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Anonymous5
    {

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }


}

#pragma warning restore 108
#pragma warning restore 114
#pragma warning restore 472
#pragma warning restore 612
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8603
#pragma warning restore 8604