---
title: Managing feature flags in your codebase
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The choices you make when implementing and organizing feature flags in your codebase significantly impact your application's performance, testability, and long-term maintainability.
When not managed with discipline, flags can introduce technical debt, making code harder to understand and riskier to change.

This guide explores key considerations for managing flags in your code. We offer detailed recommendations and practical examples to help you build reliable, scalable, and flexible systems.

Good software design practices, like modularity and a clear separation of concerns, make integrating feature flags easier. Before diving into specifics, let's establish some guiding principles:

  - **Clarity**: Feature flag logic should be easy to locate, understand, and reason about. Any developer should be able to quickly grasp what a flag does and how it affects system behavior.
  - **Maintainability**: Adding new flags, modifying existing ones, and—most importantly—removing flags when they are no longer needed should be a straightforward and low-risk process.
  - **Testability**: Code controlled by feature flags must be easily and reliably testable, ideally without a combinatorial explosion of test cases.
  - **Scalability**: Your approach must accommodate a growing number of flags and developers without leading to a tangled, unmanageable codebase.

-----

## Defining and storing flag names

The first step is to decide how to represent and store flag names. These identifiers link your code to the flag configurations in the Unleash Admin UI. A disorganized approach here can quickly lead to typos, inconsistencies, and difficulty in tracking down where a flag is used.

**We recommend centralizing your flag name definitions using constants or enums.**

This approach establishes a single source of truth for all flag names in your application.

**Why centralize definitions?**

  * **Avoids errors**: Using constants or enums prevents typos and inconsistencies that arise from scattering string literals (`"my-new-feature"`) throughout the application. Your compiler or linter can catch errors for you.
  * **Improves discoverability**: A central file acts as a manifest of all flags used in the application, making it easy for developers to see what's available and how flags are named.
  * **Simplifies refactoring**: If you need to change a flag's name in your code (for example, to fix a typo), you only need to update it in one place.

For languages with strong type systems like TypeScript, you can create even safer and more expressive definitions. This pattern, used within the Unleash codebase itself, combines union types and mapped types for excellent compile-time checking.

```typescript
// src/feature-flags.ts

// 1. Define all possible flag keys as a type-safe union.
export type AppFeatureKey =
  | 'newUserProfilePage'
  | 'darkModeTheme'
  | 'advancedReportingEngine';

// 2. (Optional) Define a more complex structure for flags with variants.
export interface AppFlagVariant {
  name: string; // Corresponds to the variant name in Unleash
  enabled: boolean;
  payload?: {
    type: string; // e.g., 'string', 'json'
    value: string;
  };
}

// 3. Define a type for the object that holds all flag states.
//    This allows flags to be simple booleans or more complex objects.
export type AppFeatures = Partial<{
  [key in AppFeatureKey]: boolean | AppFlagVariant;
}>;

// 4. (Optional) Provide default values.
export const initialAppFeatureFlags: AppFeatures = {
  newUserProfilePage: false,
  darkModeTheme: { name: 'disabled', enabled: false },
};

```

**Avoid dynamic flag names.** Constructing flag names at runtime (e.g., `"feature_" + sectionName`) prevents static analysis, making it nearly impossible to find all references to a flag automatically.


## Architecting flag evaluation

How and where you check a flag's state is one of the most important architectural decisions you'll make. A well-designed evaluation strategy keeps your code clean and your system's behavior predictable.

### Use an abstraction layer

Directly calling the Unleash SDK (e.g., `unleash.isEnabled()`) throughout your codebase tightly couples your application to the specific SDK implementation. This can create problems down the line.

**We recommend implementing an abstraction layer, often called a "Feature Service" or "wrapper," to encapsulate all interactions with the Unleash SDK.**

This service becomes the single entry point for all feature flag checks in your application.

```typescript
// src/services/feature-service.ts
import { Unleash, Context as UnleashContext } from 'unleash-client';
import { AppFeatureKey } from '../feature-flags'; // Import from your central definitions

// Define your application's context structure
export interface AppUserContext {
  userId?: string;
  sessionId?: string;
  remoteAddress?: string;
  properties?: {
    [key: string]: string;
  };
}

class FeatureService {
  private unleash: Unleash;

  constructor(unleashInstance: Unleash) {
    this.unleash = unleashInstance;
  }

  private buildUnleashContext(appContext?: AppUserContext): UnleashContext {
    if (!appContext) return {};
    return { ...appContext };
  }

  public isEnabled(flagName: AppFeatureKey, appContext?: AppUserContext): boolean {
    // Always provide a safe, default value (usually `false`)
    const defaultValue = false;
    try {
      const unleashContext = this.buildUnleashContext(appContext);
      return this.unleash.isEnabled(flagName, unleashContext, defaultValue);
    } catch (error) {
      // Log the error for observability
      console.error(`Error evaluating flag "${flagName}":`, error);
      // Fallback to the safe default
      return defaultValue;
    }
  }

  // You can also create more semantic, business-language methods
  public canUserSeeNewProfilePage(userContext?: AppUserContext): boolean {
    return this.isEnabled('newUserProfilePage', userContext);
  }
}

// Initialize and export a singleton instance for your app to use
// const unleash = initializeUnleashClient(); // Your Unleash setup
// export const featureService = new FeatureService(unleash);
```

**Benefits of an abstraction layer:**

  - **Vendor abstraction**: If you ever switch feature flagging providers, you only need to update the Feature Service instead of hunting for SDK calls across the entire codebase.
  - **Centralized control**: It provides a single place to implement cross-cutting concerns like logging, performance monitoring, and consistent error handling for all flag evaluations.
  - **Simplified cleanup**: To find all usages of a flag, you can search for its name within your centralized definitions file, which is far more reliable than searching for a string literal.
  - **Improved readability**: Methods with business-friendly names (`canUserSeeNewProfilePage()`) make the code's intent clearer than a generic `isEnabled("newUserProfilePage")`.

### Evaluate flags at the right level and time

**For a given user request, evaluate a feature flag once at the highest practical level of your application stack.** Propagate the *result* (the decision) of that evaluation downstream to other components or functions.

For example, when toggling a new checkout flow, evaluate the flag in the controller or top-level component that orchestrates that user experience. That component then decides whether to render the `NewCheckoutFlow` or the `OldCheckoutFlow`. The child components within the flow don't need to know the flag exists; they just receive props and do their job.

```javascript
// src/controllers/checkoutController.js
// import { featureService } from '../services/featureService';

export function handleCheckoutRequest(req, res) {
  const userContext = { userId: req.user.id };

  // 1. Evaluate ONCE at the highest level.
  const useNewCheckout = featureService.isEnabled('new-checkout-process', userContext);

  // 2. Propagate the DECISION, not the flag check.
  if (useNewCheckout) {
    renderNewCheckoutPage(req, res); // This component tree uses the new logic
  } else {
    renderOldCheckoutPage(req, res); // This component tree uses the old logic
  }
}
```

**Why evaluate once?**

  - **Consistency**: It ensures a user sees the same feature state throughout their interaction. Evaluating the same flag multiple times during a single request could yield different results if the flag's configuration is changed mid-request, leading to a broken or confusing user experience.
  - **Performance**: It minimizes redundant calls to the evaluation logic.
  - **Simplicity**: It prevents "flag-aware" logic from spreading deep into your application's components, making them simpler and easier to test.


## Structuring conditional logic

As features become more complex than a simple on/off toggle, relying on scattered `if/else` statements can lead to code that is difficult to read, test, and clean up.

### The anti-pattern: Scattered `if/else` statements

While intuitive for simple cases, this pattern becomes a major source of technical debt at scale.

```java
// Anti-Pattern: Scattered conditional logic
public void processPayment(PaymentDetails details, UserContext user) {
    // This logic gets duplicated wherever a payment is processed.
    if (featureService.isNewPaymentGatewayEnabled(user)) {
        newPaymentService.charge(details);
    } else {
        legacyPaymentService.charge(details);
    }
}
```

Cleaning this up requires hunting down every `if` block, carefully removing the `else` branch, and then removing the conditional itself. This is tedious, error-prone, and a key reason why "temporary" flags become permanent fixtures in the code.

### The solution: The strategy design pattern

For managing complex behavioral changes, the **Strategy pattern** is a superior approach. Instead of using a flag to select a *code path* inside a method, you use the flag to select a concrete *implementation* of a shared interface at runtime.

This encapsulates the different behaviors into distinct, interchangeable classes. The core application logic remains clean and agnostic of the feature flag itself.

The primary benefit of this pattern is the **radical simplification of cleanup**. When the feature is fully rolled out, you simply delete the old strategy's file and update the factory to only provide the new one. This is a safe, atomic operation.

#### Java example (with Spring)

Spring's dependency injection and conditional properties make implementing this pattern elegant.

**1. Define the strategy interface**

```java
public interface PaymentProcessor {
    PaymentResult process(Payment payment);
}
```

**2. Create concrete strategy implementations**

Each class implements the behavior for one branch of the feature flag. `@ConditionalOnProperty` tells Spring which bean to create.

```java
// Old implementation
@Component
@ConditionalOnProperty(name = "features.new-payment-gateway.enabled", havingValue = "false", matchIfMissing = true)
public class LegacyPaymentProcessor implements PaymentProcessor {
    @Override
    public PaymentResult process(Payment payment) {
        // ... logic for the old payment gateway
        return new PaymentResult("SUCCESS_LEGACY");
    }
}

// New implementation
@Component
@ConditionalOnProperty(name = "features.new-payment-gateway.enabled", havingValue = "true")
public class StripePaymentProcessor implements PaymentProcessor {
    @Override
    public PaymentResult process(Payment payment) {
        // ... logic for the new Stripe gateway
        return new PaymentResult("SUCCESS_STRIPE");
    }
}
```

**3. Inject the strategy into your service**

The `CheckoutService` has no idea which implementation it will receive. It is decoupled from the flagging logic.

```java
@Service
public class CheckoutService {
    private final PaymentProcessor paymentProcessor;

    @Autowired
    public CheckoutService(PaymentProcessor paymentProcessor) {
        this.paymentProcessor = paymentProcessor;
    }

    public void finalizePurchase(Order order) {
        // The service doesn't contain any if/else logic for the flag.
        PaymentResult result = this.paymentProcessor.process(order.getPayment());
        // ... handle result
    }
}
```

**Cleanup:**

1.  Set `features.new-payment-gateway.enabled=true` permanently.
2.  Delete the `LegacyPaymentProcessor.java` file.
3.  Remove the `@ConditionalOnProperty` annotations.

#### Python example

In Python, the same pattern can be achieved with classes or, more idiomatically, with first-class functions.

**1. Define the strategies and a factory**

```python
# In payment_strategies.py
from abc import ABC, abstractmethod

class PaymentStrategy(ABC):
    @abstractmethod
    def process(self, amount: float) -> str:
        pass

class LegacyGatewayStrategy(PaymentStrategy):
    def process(self, amount: float) -> str:
        print(f"Processing ${amount} through LEGACY gateway.")
        return "success_legacy"

class NewGatewayStrategy(PaymentStrategy):
    def process(self, amount: float) -> str:
        print(f"Processing ${amount} through NEW gateway.")
        return "success_new"

# The Factory encapsulates the decision logic.
def get_payment_strategy(feature_service, user_context) -> PaymentStrategy:
    """Selects the appropriate payment strategy based on a feature flag."""
    if feature_service.is_enabled("new-payment-gateway", user_context):
        return NewGatewayStrategy()
    else:
        return LegacyGatewayStrategy()
```

**2. Use the strategy in your service**

```python
# In checkout_service.py
from payment_strategies import get_payment_strategy

class CheckoutService:
    def __init__(self, feature_service):
        self._feature_service = feature_service

    def finalize_purchase(self, amount: float, user_context):
        # The factory provides the correct strategy object.
        strategy = get_payment_strategy(self._feature_service, user_context)

        # The service is clean of conditional logic.
        result = strategy.process(amount)
        # ...
```

#### TypeScript/React example

In a frontend framework like React, you can apply the Strategy pattern to conditionally render different components.

**1. Create components for each strategy**

```tsx
// src/components/OldUserProfile.tsx
const OldUserProfile = () => <div>Legacy Profile View</div>;
export default OldUserProfile;

// src/components/NewUserProfile.tsx
const NewUserProfile = () => <div>New Redesigned Profile View</div>;
export default NewUserProfile;
```

**2. Use a "selector" component**

This component uses the flag to decide which strategy (component) to render.

```tsx
// src/components/UserProfile.tsx
import { useFeature } from '../hooks/useFeature'; // Your custom hook wrapping the Feature Service
import OldUserProfile from './OldUserProfile';
import NewUserProfile from './NewUserProfile';

const UserProfile = () => {
    const isNewProfileEnabled = useFeature('newUserProfilePage');

    // The strategy pattern selects which component to use.
    const ProfileComponent = isNewProfileEnabled ? NewUserProfile : OldUserProfile;

    return <ProfileComponent />;
};

export default UserProfile;
```

**Cleanup:**

1.  Once the `newUserProfilePage` flag is fully rolled out, change the `UserProfile` component to render `NewUserProfile` directly.
2.  Delete the `OldUserProfile.tsx` file.


## Managing flags in microservices

In a microservices environment, a single user action can trigger calls across multiple services. This introduces a significant challenge: **consistency**.

Imagine a `new-pricing-model` flag. A user requests a product page.

1.  The `edge-service` receives the request, sees the flag is **on**, and passes the call to the `product-service`.
2.  The `product-service` also sees the flag is **on** and prepares to show a promotional banner. It calls the `pricing-service`.
3.  In the milliseconds between these calls, an operator disables the flag due to an issue.
4.  The `pricing-service` now evaluates the flag, sees it as **off**, and returns the standard price.

The user is now in an inconsistent state: they see a promotion but get the old price.

### The principle: Evaluate once, pass the decision

The solution is to evaluate a feature flag's state **exactly one time** at the "edge" of your system—typically in the API Gateway or the first service that receives the external request. The *result* of that evaluation (e.g., `true` or `false`), not the flag itself, must then be propagated downstream to all other services in the call chain.

### Propagating context and decisions

To make this work, downstream services need the initial flag decisions and the user context (ID, location, etc.) used to make them. The standard, most robust way to achieve this is with **OpenTelemetry Baggage**.

While OpenTelemetry is known for distributed tracing, its Baggage specification is purpose-built to carry application-defined key-value pairs across process boundaries. It's the ideal mechanism for this use case.

Here's how it works:

1.  The **edge service** receives a request, authenticates the user, and evaluates all necessary flags.
2.  It uses the OpenTelemetry SDK to add the user context and the flag *decisions* to the current baggage.
3.  When the edge service makes an HTTP call to a downstream service, the OpenTelemetry instrumentation automatically serializes the baggage into the `baggage` HTTP header and sends it.
4.  The downstream service's instrumentation automatically receives this header, deserializes it, and makes the baggage available to your application code.


```java
// Example in Java (Edge Service) using OpenTelemetry SDK
Baggage.current()
   .toBuilder()
   .put("user.id", "user-123")
   .put("user.tier", "premium")
   // Propagate the DECISION, not the flag name.
   .put("decision.new-checkout.enabled", "true")
   .build()
   .makeCurrent(); // This context is now active and will be propagated.
```

```python
# Example in Python (Downstream Service)
from opentelemetry import baggage

def handle_request():
    # Retrieve the propagated context.
    all_baggage = baggage.get_all()
    user_id = all_baggage.get('user.id')
    new_checkout_is_enabled = all_baggage.get('decision.new-checkout.enabled') == 'true'

    # Use the consistent, propagated decision.
    if new_checkout_is_enabled:
        # ...
    else:
        # ...
```

Adopting OpenTelemetry Baggage solves the context propagation problem at a platform level, providing a consistent mechanism for flags, tracing, A/B testing, and more.

## Minimizing code clutter and managing the flag lifecycle

Without discipline, your codebase will accumulate "flag debt"—a backlog of stale, forgotten, and risky flags. A rigorous governance and lifecycle management process is the only way to conquer this debt.

### Start with clear naming and metadata

The first line of defense is clarity. A flag named `temp_fix_v2` is a mystery waiting to happen.
**Enforce a strict naming convention** that encodes key information. A highly effective pattern is: `[team-owner]_[flag-type]_[description]`.

  - `checkout_release_multistep-payment-flow`
  - `search_experiment_new-ranking-algorithm`
  - `platform_ops_database-failover-enabled`

Furthermore, **every flag check in the code should have a comment** containing essential metadata:

  - **Ticket ID**: A link to the Jira, Asana, or GitHub issue.
  - **Owner**: The team responsible for the flag's lifecycle.
  - **Lifecycle**: The flag's purpose (e.g., Release, Experiment) and its expected removal date.


```javascript
// JIRA-451: Enable new dashboard for beta users.
// Owner: Team Phoenix
// Type: Release Flag. To be removed by end of Q3 2025.
if (featureService.isEnabled('phoenix_release_new-user-dashboard', userContext)) {
  // ... new dashboard logic
}
```

### The process for safe removal

All temporary flags must eventually be removed. Follow a clear, repeatable process:

1.  **Verify Status in Unleash**: Confirm the flag is either 100% rolled out and stable or permanently disabled.
2.  **Solidify the Winning Path**: Remove the conditional logic (`if/else`) and all code associated with the "losing" path. This is the most critical step for avoiding dead code.
3.  **Delete Flag Definition**: Remove the flag's name from your central constants or enums file. This will cause a compile-time or linter error if any references still exist.
4.  **Clean Up the Abstraction Layer**: If you created a specific semantic method (e.g., `canUserSeeNewDashboard()`), remove it.
5.  **Archive the Flag in Unleash**: Archive (don't delete) the flag in the Unleash UI. This preserves its history for auditing purposes.
6.  **Test and Deploy**: Thoroughly test that the application behaves as expected with the flag's logic removed and deploy the changes.

### Automate cleanup to conquer flag debt

Relying on manual discipline for cleanup is a strategy destined for failure. **Automate your governance process.**

  - **Automated Ticketing**: Use webhooks or integrations to automatically create a "Remove Flag" ticket in your project management tool when a flag has been at 100% rollout for a set period (e.g., two weeks).
  - **Stale Flag Detection**: Use tools that can scan your codebase and the Unleash API to find "zombie flags"—flags that exist in Unleash but have no references in your code.
  - **Scheduled Reviews**: Institute a regular, recurring meeting (e.g., "Flag Friday") where teams must review their active flags and justify their existence or schedule them for removal.
  - **Update "Definition of Done"**: A feature isn't "done" until its associated feature flag has been removed from the code and archived in Unleash.


## Testing with feature flags

A common fear is the "combinatorial explosion" of tests—if you have 10 flags, you have 2¹⁰ = 1024 possible combinations. This fear is a myth. You don't need to test every permutation. A pragmatic and effective strategy focuses on a few critical states:

1.  **The Production Default State**: A test suite that runs with all *new* feature flags turned **off**. This is your most important suite, as it verifies that adding new, dormant code has not caused regressions in existing functionality.
2.  **The New Feature State**: For each new feature, a dedicated test run is executed with *that specific flag turned on* and all others off. This isolates the new feature and validates its functionality without interference.
3.  **The Fallback State**: Test how your application behaves if the feature flagging service is unavailable. Your abstraction layer should handle this gracefully, falling back to safe default values.

### Testing in production safely

The most powerful testing practice enabled by feature flags is **testing in production**. This doesn't mean exposing bugs to your customers. It means using targeting rules to enable a feature *only for your internal teams* in the live production environment.

For example, you can configure a flag to be "on" only for users with an `@your-company.com` email address. This allows your QA team and developers to interact with the new feature on the actual production infrastructure, connected to real production services—a context that is impossible to replicate perfectly in a staging environment. If a bug is found, it has zero impact on real users and can be fixed before a public release.

-----

## Frequently asked questions (FAQs)

**Q: Where should I define my feature flag names in the code?**
A: Centralize them in a dedicated file using constants or enums. This creates a single source of truth and prevents typos.

**Q: Should I call the Unleash SDK directly everywhere or build a helper service?**
A: Always build a helper service (an abstraction layer). It decouples your app from the SDK, centralizes logic like error handling, and dramatically simplifies maintenance and future migrations.

**Q: How do I cleanly handle code for complex features controlled by flags?**
A: Use design patterns like the Strategy pattern to encapsulate the different behaviors in separate classes or modules. This avoids messy `if/else` blocks and makes cleanup trivial.

**Q: How do we avoid "flag debt" (a messy codebase full of old flags)?**
A: Enforce strict naming conventions, document flags with metadata in code comments, conduct regular audits, and automate the cleanup process as much as possible.

**Q: When and how should I remove a feature flag from the code?**
A: Remove a flag once it is fully rolled out and stable, or an experiment has concluded. The process involves removing the conditional logic, deleting the old code path, removing the flag's definition, and finally archiving it in the Unleash UI.

**Q: What's the best way to evaluate a a feature flag in code?**
A: Evaluate it **once per user request** at the highest practical entry point of your application. Propagate the *decision* (the boolean result) to downstream components to ensure a consistent experience.