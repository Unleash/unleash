---
title: Managing feature flags in your codebase
toc_max_heading_level: 2
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

How you manage feature flags in code directly impacts the performance, testability, and long-term maintainability of your applications.
Without the right processes and structure, flags quickly become [tech debt](/reference/technical-debt), making your code harder to understand and risky to change.

In this guide, we explore hands-on strategies for managing feature flags in your code effectively. We'll give you practical recommendations and code examples to help you build a system that's reliable, scalable, and easy to maintain.

We'll cover how to:
- [Define and store flag names](#defining-and-storing-flag-names) in code.
- [Architect flag evaluations](#architecting-flag-evaluation) with an abstraction layer to keep your code clean.
- [Structure conditional logic](#structuring-conditional-logic) to simplify flag cleanup.
- [Manage flags in microservices](#managing-flags-in-microservices).
- [Minimize tech debt and manage the flag lifecycle](#minimizing-tech-debt-and-managing-the-flag-lifecycle) to prevent technical debt.

## Building on a foundation of clean code

Before we dive into specifics, remember that good software design practices make everything easier. Principles like modularity and a clear separation of concerns are your best friends when integrating feature flags.

Here are the goals we're aiming for:
  - **Clarity**: Your feature flag logic should be easy to find and understand. Any developer on your team should be able to quickly grasp what a flag does and how it affects the system.
  - **Maintainability**: Adding, changing, and removing flags should be a simple and low-risk process.
  - **Testability**: Your code under a flag should be easily and reliably testable.
  - **Scalability**: Your approach needs to handle a growing number of flags and developers without increasing code complexity.

## Defining and storing flag names

Your first step is deciding how to represent and store flag names in code. These identifiers are the critical link between your application and your feature flag configurations in the Unleash Admin UI. A disorganized approach here can quickly lead to typos, inconsistencies, and difficulty in tracking down where a flag is used.

We recommend centralizing your flag name definitions using constants or enums. This approach establishes a single source of truth for all flag names in your application.

**Why centralize definitions?**

  - **Avoids inconsistencies or errors**: Using constants or enums prevents typos and inconsistencies that arise from scattering string literals (`"my-new-feature"`) throughout the application. Your compiler or linter can catch errors for you.
  - **Improves discoverability**: A central file acts as a manifest of all flags used in the application, making it easy for developers to see what's available and how flags are named.
  - **Simplifies refactoring and cleanup**: If you need to change a flag's name in your code (for example, to fix a typo), you only need to update it in one place.

Here is a simple and highly effective pattern using TypeScript's `as const` feature. It's robust, type-safe, and easy to understand.

```typescript
// src/feature-flags.ts

// A simple, effective way to centralize flags
export const FeatureFlags = {
  NEW_USER_PROFILE_PAGE: 'newUserProfilePage',
  DARK_MODE_THEME: 'darkModeTheme',
  ADVANCED_REPORTING: 'advancedReportingEngine',
} as const; // 'as const' makes values read-only and types specific

// This automatically creates a type for all possible flag keys.
export type AppFlag = typeof FeatureFlags[keyof typeof FeatureFlags];
```

For applications that need even stricter type safety or rely heavily on flag variants, you can use a more advanced pattern. This approach, used within the [Unleash codebase itself](https://github.com/Unleash/unleash/blob/main/src/lib/types/experimental.ts), combines union and mapped types for maximum compile-time checking.

```typescript
// An alternative approach in: src/feature-flags.ts
import { type Variant, PayloadType } from 'unleash-client';

// 1. Define all possible flag names as a type-safe union
export type AppFlagKey =
  | 'newUserProfilePage'
  | 'darkModeTheme'
  | 'advancedReportingEngine';

// 2. Define a type for the flags object using the official `Variant` type
export type AppFlags = Partial<{
  [key in AppFlagKey]: boolean | Variant;
}>;

// 3. Provide explicit default values for each flag
export const defaultFlags: AppFlags = {
  // Simple boolean defaults
  newUserProfilePage: false,
  darkModeTheme: true,
  
  // A complex variant with a payload, defaulted to off
  advancedReportingEngine: {
    name: 'disabled',
    enabled: false,
    payload: {
      type: PayloadType.JSON,
      value: '{}',
    },
  },
};
```

Finally, no matter which pattern you choose, you should avoid dynamic flag names. Constructing flag names at runtime (such as, `{domain} + "_feature"`) prevents static analysis, making it nearly impossible to find all references to a flag automatically. It makes [clean-up with automated tools](https://www.getunleash.io/blog/ai-flag-cleanup) more difficult.

## Architecting flag evaluation

How and where you check a flag's state is one of the most important architectural decisions you'll make. A well-designed evaluation strategy keeps your code clean and your system's behavior predictable.

### Use an abstraction layer

Directly calling the Unleash SDK's `unleash.isEnabled()` throughout your codebase tightly couples your application to the specific SDK implementation.

Instead, we recommend implementing an abstraction layer, often called a "wrapper," to encapsulate all interactions with the Unleash SDK. This service becomes the single entry point for all feature flag checks in your application.

```typescript
// src/services/feature-service.ts
import { Unleash, Context as UnleashContext } from 'unleash-client';
import { AppFlag, FeatureFlags } from '../feature-flags'; // Import both the type and the constants

// Define your application's context structure
export interface AppUserContext {
  userId?: string;
  sessionId?: string;
  properties?: {
    [key: string]: string;
  };
}

class FeatureService {
  private unleash: Unleash;

  constructor(unleashInstance: Unleash) {
    this.unleash = unleashInstance;
  }

  private buildUnleashContext(appContext?: AppUserContext): UnleashContext {
    if (!appContext) return {};
    return { ...appContext };
  }

  public isEnabled(flagName: AppFlag, appContext?: AppUserContext): boolean {
    // Always provide a safe, default value (usually `false`)
    const defaultValue = false;
    try {
      const unleashContext = this.buildUnleashContext(appContext);
      return this.unleash.isEnabled(flagName, unleashContext, defaultValue);
    } catch (error) {
      // Log the error for observability
      console.error(`Error evaluating flag "${flagName}":`, error);
      // Fallback to the safe default
      return defaultValue;
    }
  }

  // You can also create more semantic, business-language methods
  public canUserSeeNewProfilePage(userContext?: AppUserContext): boolean {
    return this.isEnabled(FeatureFlags.NEW_USER_PROFILE_PAGE, userContext);
  }
}

// Initialize and export a singleton instance for your app to use
const unleash = initializeUnleashClient(); // ← replace with your real init
export const featureService = new FeatureService(unleash);
```

**Why build an abstraction layer?**

  - **Vendor abstraction**: If you ever switch feature flagging providers, you only need to update your wrapper instead of hunting for SDK calls across the entire codebase.
  - **Centralized control**: It gives you a single place to manage logging, performance monitoring, and robust error handling for all flag checks.
  - **Improved readability**: Methods with business-friendly names (`canUserSeeNewProfilePage()`) make the code's intent clearer than a generic `isEnabled("newUserProfilePage")`.

### Handling variant payloads inside your wrapper

This wrapper is also a good place to validate any feature flag payload you receive from Unleash.

While using [variant payloads](/reference/strategy-variants#variant-payload) for dynamic configuration enables flexibility and rapid iteration, it also introduces risk. Since the variant payload is managed in a UI, a change can have unintended consequences on the application's behavior or appearance, even if the JSON itself is syntactically valid.

If you decide to use variant payloads, we recommend enforcing a [four-eyes approval](/reference/change-requests) process, so any change must be reviewed and approved by a second team member before it can be saved. In addition, you should test payloads with internal users first before exposing them to real users.

Then, implement additional guardrails in your wrapper to validate the payload structure and return a safe default value if the data is invalid.

### Evaluate flags at the right level and time

For a given user request, evaluate a feature flag once at the highest practical level of your application stack. Propagate the result of that evaluation (the true/false value or the feature flag variant) downstream to other components or functions.

For example, when toggling a new checkout flow, evaluate the flag in the controller or top-level component that orchestrates that user experience. That component then decides whether to render the `NewCheckoutFlow` or the `OldCheckoutFlow`. The child components within the flow don't need to know the flag exists; they just receive props and do their job.

[more code examples]

```javascript
// src/controllers/checkoutController.js
import { featureService } from '../services/featureService';
import { FeatureFlags } from '../feature-flags'; // Import the centralized flag names

export function handleCheckoutRequest(req, res) {
  const userContext = { userId: req.user.id };

  // 1. Evaluate once at the highest level
  const useNewCheckout = featureService.isEnabled(FeatureFlags.NEW_CHECKOUT_PROCESS, userContext);

  // 2. Propagate the result, not the flag check
  if (useNewCheckout) {
    renderNewCheckoutPage(req, res); // This component tree uses the new logic
  } else {
    renderOldCheckoutPage(req, res); // This component tree uses the old logic
  }
}
```

**Why evaluate once?**

  - **Consistency**: It ensures a user sees the same feature state throughout their interaction. Evaluating the same flag multiple times during a single request could yield different results if the flag's configuration is changed mid-request, leading to a broken or confusing user experience.
  - **Performance**: It minimizes redundant calls to the evaluation logic.
  - **Simplicity**: It prevents "flag-aware" logic from spreading deep into your application's components, making them simpler and easier to test.


## Structuring conditional logic

The way you structure your conditional logic for your flags has a major impact on readability and, most importantly, on how easy it is to clean up later.

For the vast majority of cases, a simple if/else statement is the best approach. It's direct, easy to understand, and straightforward to remove.

[more code examples]

```java
// A simple, clean conditional statement
public void processPayment(PaymentDetails details, UserContext user) {
    if (featureService.isNewPaymentGatewayEnabled(user)) {
        newPaymentService.charge(details);
    } else {
        legacyPaymentService.charge(details);
    }
}
```

The primary goal is to keep the conditional logic localized and simple. When it's time for cleanup, the task is trivial: delete the if and the else block, and the new code path remains.

### Using design patterns

Design patterns like the [Strategy pattern](https://www.digitalocean.com/community/tutorials/strategy-design-pattern-in-java-example-tutorial) or the [Factory pattern](https://hackernoon.com/understanding-the-factory-pattern-in-c-with-examples) are sometimes used in place of direct conditional logic. For example, the strategy pattern uses a flag to select a concrete implementation of a shared interface at runtime, encapsulating different behaviors into distinct classes.

This makes it particularly well-suited for certain [Permission](/what-is-a-feature-flag#permission-flags) flags that grant premium users access to an advanced feature, or for long-term [Kill switches](/what-is-a-feature-flag#kill-switches) that toggle a core system component. For these complex, multi-faceted features with distinct and interchangeable behaviors, the pattern can be a powerful tool for maintaining a clean, scalable, and testable codebase. 

However, the majority of feature flags control small, temporary changes. For most [Release](/what-is-a-feature-flag#release-flags), [Experiment](/what-is-a-feature-flag#experiment-flags), and [Operational](/what-is-a-feature-flag#operational-flags) flags, the strategy pattern introduces unnecessary overhead. It makes the eventual cleanup process far more complex than removing a simple if/else block. Furthermore, because the pattern scales poorly when multiple flags interact, a direct conditional statement is almost always the cleaner and more maintainable choice for these temporary flags.

## Managing flags in microservices

Microservices introduce a tough challenge for feature flags: consistency. A single click from a user can trigger a chain reaction across multiple services. Each service checking the flag state on its own can result in an inconsistent state.

Imagine a `new-pricing-model` flag is active:

1.  The `gateway-service` receives the request, sees the flag is *on*, and calls the `product-service`.
2.  The `product-service` also sees the flag is *on* and prepares to show a promotional banner. It calls the `pricing-service`.
3.  In the milliseconds between these calls, someone turns off the flag due to an issue.
4.  The `pricing-service` now evaluates the flag, sees it as *off*, and returns the standard price.

The result? A confused user who sees a promotional banner but gets charged the old price.

The solution is to evaluate a feature flag's state exactly one time at the "edge" of your system—typically in an API Gateway or the first service that receives the external request. 
Then, you must propagate the result of that evaluation—the true/false or a specific variant—downstream to all other services.

[diagram?]

To make this work, downstream services need the initial flag evaluation result and the user context (ID, location, etc.) used to make them. The standard, most robust way to achieve this is with [OpenTelemetry Baggage](https://opentelemetry.io/docs/concepts/signals/baggage/).

While OpenTelemetry is known for distributed tracing, its Baggage specification is purpose-built to carry application-defined key-value pairs across process boundaries. It's the ideal mechanism for this use case.

Here's how it works:

1.  The `gateway-service` receives a request, authenticates the user, and evaluates all necessary flags.
2.  It uses the OpenTelemetry SDK to add the user context and the flag evaluation result to the current baggage.
3.  When the `gateway-service` makes an HTTP call to a downstream service, the OpenTelemetry instrumentation automatically serializes the baggage into the `baggage` HTTP header and sends it.
4.  The downstream service's instrumentation automatically receives this header, deserializes it, and makes the baggage available to your application code.

<Tabs groupId="microservices">
<TabItem value="microservices-java" label="Java">

```java
// Example in Java (`gateway-service`) using OpenTelemetry SDK
import io.opentelemetry.api.baggage.Baggage;

Baggage.current()
   .toBuilder()
   .put("user.id", "user-123")
   .put("user.tier", "premium")
   // Propagate the evaluation result, not the flag name
   .put("flag.new-checkout.enabled", "true")
   .build()
   .makeCurrent(); // This context is now active and will be propagated.
```
</TabItem>

<TabItem value="microservices-python" label="Python">
```python

# Example in Python (Downstream Service)
from opentelemetry import baggage

def handle_request():
    # Retrieve the propagated context
    all_baggage = baggage.get_all()
    user_id = all_baggage.get('user.id')
    new_checkout_is_enabled = all_baggage.get('flag.new-checkout.enabled') == 'true'

    # Use the consistent, propagated result
    if new_checkout_is_enabled:
        # ...
    else:
        # ...
```
</TabItem>
</Tabs>

## Minimizing tech debt and managing the flag lifecycle

Let's face it: stale flags are [tech debt](/reference/technical-debt). Without a plan, your codebase will fill up with forgotten and risky flags. The only way to win is with a clear process for managing their entire [lifecycle](/reference/feature-toggles#feature-flag-lifecycle).

The first line of defense is clarity. A flag named `temp_fix_v2` is a mystery waiting to happen.
Enforce a strict [naming convention](/reference/feature-toggles#set-a-naming-pattern) that encodes key information. A highly effective pattern is: `[team]_[feature-name]_[issue-number]`. For example: `checkout_multistep-payment-flow_jira-376`.

You can also use code comments to share additional information and use the description and [external links](/reference/feature-toggles#external-links) features in Unleash to tie the flag back to the work that created it.

### Flag cleanup best practices

You can use a flag's [lifecycle data](/reference/feature-toggles#feature-flag-lifecycle) and automated reminders to ensure flags are removed from your code once they have served their purpose.

Here's our recommended workflow for flag cleanup:

- **Update the flag's lifecycle status**: Once a feature is stable and fully rolled out, mark it as *Completed* in Unleash. If you forget, Unleash will prompt you to update the status for stale flags that are no longer sending metrics. This moves the flag to the Cleanup lifecycle stage, creating a clear backlog for removal.

- **Clean up the code**: Remove the conditional logic, any old code paths, the flag's definition from your central file, and any helper methods from your wrapper. This ensures you remove dead code and reduce complexity.

- **Test and deploy**: Run your tests to ensure everything still works as expected, then deploy your changes.

- **Archive the flag in Unleash**: Finally, archive the flag in the Unleash UI. Don't delete it—archiving preserves its history for auditing and analysis.

Just hoping that people remember to clean up is not a sustainable strategy. You need to automate your governance process.

Here are some practical tips:
- **Automated ticketing**: Use webhooks or integrations to automatically create "Remove Flag" tickets.
- **Scheduled reviews**: Make flag reviews a part of your process, for example your planning. Teams should justify a flag's existence or schedule them for removal.
- **Update "Definition of Done"**: A feature isn't "done" until its associated feature flag has been removed from the code and archived in Unleash.
- **Use AI to speed up the cleanup**: Rely on [AI coding assistants](https://www.getunleash.io/blog/ai-flag-cleanup) to automate and fixing flag removal issues.


## Testing with feature flags

A common fear is that flags will cause a "combinatorial explosion" of test cases. Don't worry, you don't need to test every possible combination. Instead, focus on these key scenarios:

- **Production default state**: A test suite that runs with all new feature flags turned off. This is your most important suite, as it verifies that adding new, dormant code has not caused regressions in existing functionality.
- **New feature state**: For each new feature, run a dedicated test with that one flag turned on. This isolates and validates the new feature without interference.
- **Fallback state**: Test what happens if Unleash is unavailable. Does your wrapper handle it gracefully and fall back to safe defaults?

The real superpower that flags give you is testing in production—safely.

This doesn't mean showing bugs to your customers. It means using targeting rules to enable a feature only for your internal teams in the live production environment.
For example, you can set a flag to be "on" only for users with an `@your-company.com` email address.

This allows your team to interact with the new feature on real production infrastructure, with real data—a context that is impossible to perfectly replicate in a staging environment.
If you find a bug, it has zero impact on real users. You can fix it and then release it with confidence.

## Key takeaways

To wrap things up, managing feature flags effectively boils down to a few core, hands-on practices.

First, centralize flag definitions in a single file to prevent errors and make them easy to find and remove. Second, always build an abstraction layer or wrapper around the SDK; this gives you a single point for error handling and simplifies future migrations.

For structuring your conditional logic, a simple if/else is usually the best choice for temporary flags, as it's the easiest to clean up.

Finally, evaluate flags once at the highest reasonable level in your application. This is especially crucial in a microservices architecture, where propagating the result of the evaluation downstream ensures a consistent user experience.

-----

## Frequently asked questions (FAQs)

**Where should I define my feature flag names in the code?**
Centralize them in a dedicated file using constants or enums. This creates a single source of truth, prevents typos, and makes cleanup easier.

**Should I call the Unleash SDK directly everywhere or build a helper service?**
Build a wrapper (an abstraction layer). It decouples your app from the SDK, gives you a central place for error handling and logging, and makes future migrations painless.

**How do I handle code for complex features controlled by flags?**
Start with a simple if/else statement. This is the cleanest and easiest-to-maintain solution for most cases. The Strategy pattern should be reserved for complex, long-lived flags like kill switches or permissions, as it can introduce unnecessary complexity for short-lived release flags.

**How do we avoid flag debt?**
Have a process! Use strict [naming conventions](/reference/feature-toggles#set-a-naming-pattern), link flags to tickets in Unleash, make flag removal part of your "Definition of Done," and automate cleanup reminders.

**When and how should I remove a feature flag from the code?**
Once the flag is stable at 100% rollout (or permanently off). The process is: remove the conditional logic and old code, delete the flag definition, and then archive the flag in the Unleash UI.

**Can you use feature flags in microservices?**
Absolutely! Evaluate the flag once in the first service that gets the request (for example, your API gateway). Then, propagate the result of the evaluation (the true/false result or assigned variant) to all downstream services using OpenTelemetry Baggage or custom HTTP headers. This guarantees consistency.

**What's the best way to evaluate a feature flag in code?**
Evaluate it once per request at the highest logical point in your application. Then, pass the boolean result down to the components that need it. This ensures a consistent user experience for that entire interaction.