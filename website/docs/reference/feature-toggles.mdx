---
title: Feature Flags
---

## Overview

Feature flags are a core concept of Unleash. Feature flags allow you to release, test, and manage features and functionality across your application without changing the source code.

Feature flags exist within a [project](./projects) and have distinct configurations and [activation strategies](./activation-strategies) for each of the project's active [environments](./environments). Activation strategies determine if a feature flag is enabled in a specific environment.

Feature flags have the following properties:

- **Name**: [URL-friendly](https://www.rfc-editor.org/rfc/rfc3986#section-2.3) string between 1 and 100 characters; must be unique per instance.
- **Type**: The [feature flag's type](#feature-flag-types); `Release` by default.
- **Project**: The [project](./projects) that contains the feature flag.
- **Description**: A description of the feature flag's purpose; optional.
- **Impression data**: Whether impression data is enabled for the flag; disabled by default.

## Environments and activation strategies

Feature flags have different [activation strategies](./activation-strategies) for each environment to allow you to manage feature rollouts per environment.

To activate a feature within an environment, assign at least one activation strategy to it. If you don't specify a strategy, the default of gradual rollout to 100% is used.

Activation strategies determine if a feature flag activates for a specific [Unleash context](./unleash-context), such as a particular user or segment. When multiple strategies are in place, the flag will activate if any one of them evaluates to true.

### Strategy variants

You can enhance your feature flags with [strategy variants](./strategy-variants.md). Feature flags let you define who gets access to a feature. With variants, you can also determine which version of the feature they see.
For example, you might use variants to run an A/B testing experiment.

Variants are defined by a name and weight, which determines the likelihood of each variant being shown. [Stickiness](./stickiness) ensures that users consistently see the same variant based on predefined parameters.
Variants can also include payloads such as JSON, CSV, or strings to provide users with additional context.


## Feature flag types

:::note Availability

**Version**: `3.5+`

:::


Feature flags have a type to indicate their use case and help you manage and sort your flags. A feature flag's type determines its [expected lifetime](#feature-flag-lifetime), and its visual appearance in the Admin UI.


The following is a list of feature flag types:

| Feature flag type | Used to                                                                                                                                                       | Expected lifetime |
|---------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------|
| Release             | Manage the deployment of new or incomplete features.                                                                                          | 360 days           |
| Experiment          | Perform multivariate or A/B testing.                                                                                                                              | 40 days           |
| Operational         | Transition between technical implementations with minimal risk.                                                                                                            | 7 days            |
| Kill switch         | Gracefully degrade system functionality. | Permanent         |
| Permission          | Control feature access based on user roles or entitlements.                                                                                             | Permanent         |

To learn more, visit [Types of feature flags](../what-is-a-feature-flag#types-of-feature-flags).

## Feature flag state

A feature flag can have one of the following states: _active_, _potentially stale_, and _stale_. Unleash marks all flags as _potentially stale_ automatically once it passes its [expected lifetime](#feature-flag-lifetime).

State, together with expected lifetime, gives you an indication of when to [clean up a feature flag in code](./technical-debt.md).

You can also manually change the state on a feature flag's page by going to **Overview** and clicking **Toggle stale state**.

![Marking a feature flag as stale](/img/mark-flag-stale.png)

Marking a flag as stale helps you deprecate a feature flag without removing the active configuration for connected applications.

You can use this to signal to your team to stop using the feature in your applications. Stale flags will show as stale in the [technical debt dashboard](./technical-debt).

Marking a flag as stale generates the `feature-stale-on` [event](./reference/events#feature-stale-on). You can use [an integration](/integrations/integrations) to trigger automated workflows, for instance, post notifications in a Slack channel, break project builds if the code contains stale flags, or open PRs automatically to remove stale flags from the code.

## Feature flag lifetime

Each feature flag type has an expected lifetime, which gives you an indication of when a feature flag might be stale. While some feature flag types are permanent, most flags are short-lived.

The lifetime and state indicators help you make decisions about what flags need to be [cleaned up](./technical-debt.md) in your codebase. See [11 Principles for building and scaling feature flags](../topics/feature-flags/feature-flag-best-practices) to learn more.

Once a feature flag exists for longer than its expected lifetime, Unleash changes its state to _potentially stale_.

With Admin access, you can configure the lifetime of a feature flag type. In the Admin UI, go to **Configure > Feature flag** types and edit the flag type you'd like to change.

## Feature flag lifecycle

:::note Availability

**Version**: `6.2+`

:::

![Feature Lifecycle example](/img/feature-lifecycle.png 'Feature Lifecycle example')

In Unleash, the feature lifecycle encompasses a holistic view of how mature your feature is based on data collected through metrics and interactions with the Unleash system. 
As such, the lifecycle mirrors your software development process and allows you to identify bottlenecks at any stage of the lifecycle. 
These findings may give you insights or clues to improve the efficiency of your software development process. Read more about how Unleash progresses a feature through the lifecycle below.

### Lifecycle stages

Each stage in the lifecycle has a defined purpose:

#### Initial stage

The feature flag is created but remains unseen in any environment.

**Purpose:** marks the initiation of the feature.

### Pre-live stage

The feature flag has received metrics in non-production environment or has received metrics in a disabled production environment.

**Purpose:** testing and validating the feature before it goes live. 

#### Live stage

The feature has received metrics in the enabled production environment. 
Once enough has been learned about the feature from production usage, you can mark the feature as completed.
When marking a feature as complete, you decide whether to keep the feature, discard it, or keep one variant of the feature.
This information can be used by code cleanup tools to automate feature removal from your code.

**Purpose:** testing and validating the feature in production and marking feature completion.

#### Completed stage

The feature's objectives have been achieved, and it is ready to be phased out.
The lifecycle feature warns you if a completed feature continues to receive traffic, signaling that it hasn't been fully removed from the code.
If you've accidentally marked the feature as completed, you can always revert it to the live stage.

**Purpose:** initiating cleanup processes and signalling when it's safe to archive a feature.

#### Archived stage

The feature is archived in Unleash and can be deleted. If an archived feature is revived, it starts a new lifecycle with a new initial stage. 

**Purpose:** reducing technical debt by removing obsolete features.

### Lifecycle stages and process improvement

Understanding how much time a feature spends in each stage can highlight inefficiencies:
* **Stuck in Initial**: May indicate integration issues in pre-production setups.
* **Stuck in Pre-live**: Suggests challenges in achieving production readiness.
* **Stuck in Live**: Could imply difficulties in data gathering or decision-making regarding the featureâ€™s future.
* **Stuck in Completed**: Indicates delays in decommissioning the feature and cleaning up resources.


## Naming patterns