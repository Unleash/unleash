---
title: 'Feature flag management: Best practices'
description: 'A guide for feature flag management. Best practices for organization, lifecycle management, and avoiding common pitfalls to keep your system efficient and secure.'
---

# Feature flag management at scale: best practies

You've probably heard someone say, “A feature flag is just an if statement.” And in simple cases, that's true. But when your organization has thousands of developers managing hundreds of [feature flags](https://docs.getunleash.io/what-is-a-feature-flag)—with complex targeting rules, audit trails, and dozens of microservices—those if statements get complicated fast. Especially if you don't [set things up properly from the start](../../use-cases/user-management-access-controls-auditing).

This guide shares what we've learned from helping teams run some of the largest feature flag deployments in the world, both through [Unleash Open-Source](https://github.com/Unleash/unleash) and [Unleash Enterprise](https://www.getunleash.io/enterprise-feature-management-platform).

The principles here don't only apply to Unleash—they're relevant for any large-scale feature flag system, whether you're building your own or using a commercial solution. If you're just getting started, check out our [best practices for building and scaling feature flags](./feature-flag-best-practices).

We've broken this guide into three sections, based on the key phases of a large-scale feature flag rollout:

- Instrument
- Stay on top of technical debt
- Use feature flag lifecycle to optimize your development workflow
- Common pitfalls when implementing feature flags at scale
- Organizing your teams
- Keepig cool?

## Organize your feature flag code effectively

Feature flags live in your codebase—and how you implement them matters. The choices you make when organizing flags can impact performance, testability, and long-term maintainability. Here are a few best practices we've learned from working with large-scale systems.

### Define flags at the highest level of abstraction

![Evaluate flags at the edge](/img/evaluate-flags-at-the-edge.svg)

Place feature flag evaluations as high in the stack as possible. For example, when testing a dark mode toggle or a new signup flow, evaluate the flag near the UI layer rather than scattering it across multiple components. This helps you:
	- **Simplify your code**: Control feature behavior from a single point so that the rest of your system does not need to be aware of the flag.
	- **Test more easily**: Isolate the feature for unit and integration testing.
	- **Clean up faster**: Flags defined in one place are easier to find, maintain, and clean up when no longer needed.

For backend logic—such as introducing a new database schema or optimizing a query—evaluate the flag close to the affected module. Make sure your code is easily testable. Evaluate the flag externally and inject the result, or provide two separate implementations. This makes it easier to write unit tests for both versions of the logic.

This enables:
-   Focused testing: Evaluating the flag's impact within the specified module simplifies testing and debugging. You only need to consider the immediate code's behavior, making troubleshooting more efficient.
-   Isolation: Evaluating close to the module helps isolate the impact of the feature flag, reducing the risk of unintended consequences in other parts of the codebase.

::: note

Whenever possible, evaluate your flag in a single place. Centralizing the evaluation simplifies your code and reduces the chances of inconsistent behavior.

:::

### Evaluate feature flags once per user request

![Evaluate flags once](/img/evaluate-flags-only-once.svg)

When rolling out complex features, changes often span multiple parts of a system—whether that's modules within a single application or services in a distributed architecture. It might seem convenient to use the same feature flag across all components and evaluate it locally in each one, but this can lead to problems.

As a user request moves through the system, it hits different parts at different times. Even with synchronized flag states, there's a risk the flag's value changes between evaluations, resulting inconsistent behavior for the user.
Particularly in distributed systems, we cannot assume all parts of the system are perfectly synchronized, as networks are unreliable and can experience transient errors at any time. Most feature flag systems prioritize [availability over consistency](./feature-flag-best-practices#2-prioritize-availability-over-consistency). By only evaluating a feature flag once, we guarantee a consistent experience for our users.

Using the same flag in multiple places fragments the control logic and breaks the single responsibility principle, making code harder to understand and maintain.

Instead, evaluate the flag once—typically at the start of a user request—and pass the result through the system. This keeps behavior predictable and makes the codebase cleaner and easier to manage over time.

## Stay on top of technical debt

Feature flags are powerful—they increase developer productivity, reduce risk, and support data-driven product decisions. But they also come with a catch: they're a form of technical debt.

Technical debt builds up when flags stick around long after they've served their purpose. Over time, outdated or unused flags clutter your codebase, making it harder to read, test, and maintain. This slows down development and can even lead to bugs, security risks, or unexpected behavior—especially if old flags conflict with one another or expose sensitive features.

The simplest way to pay down flag debt? Track your flags and remove them when they're no longer needed. Understanding the full lifecycle of a flag is key to keeping your codebase clean and your team moving fast.

## Use feature flag lifecycle to optimize your development workflow

Every feature flag follows a lifecycle—even if your tooling doesn't make it explicit. Understanding and tracking this lifecycle helps teams reduce technical debt identify bottlenecks in the development workflow.

Here are the typical stages:
	- **Define**: The flag is created, but no code has been written yet.
	- **Develop**: Code is in progress. The feature isn't live, but it's being tested internally.
	- **Production**: The feature is deployed to production and gradually rolled out to users.
	- **Cleanup**: The team has decided to keep or discard the feature. The flag is still active, but it's time to clean up the code.
	- **Archived**: The flag is no longer needed. It's been disabled and the associated code removed.

Tracking flags through these stages helps teams work smarter. Here's how:

**Spot bottlenecks**
  - Stuck in Define? Maybe requirements aren't clear. Perhaps there are integration difficulties.
  - Stuck in Develop? Could point to testing delays or bugs.
  - Stuck in Production? Might be missing success criteria or user feedback.
  - Stuck in Cleanup? Check for accumnulating technical debt.

**Clean up stale flags**
 Flags that outlive their purpose clutter the codebase and can lead to bugs or security risks. Regularly reviewing the lifecycle data helps you keep your code clean and secure.

**Get actionable insights**
Track metrics like time-to-production, rollback rates, or cleanup delays across teams. Over time, these insights can highlight efficiency gains—or uncover hidden slowdowns you might otherwise miss.

## Common pitfalls when implementing feature flags at scale

When you work with feature flags at scale, some decisions seem smart in the moment—but can cause big headaches down the line. Here are two of the most common pitfalls we've seen:

### Parent child dependencies with complex targeting rules

At scale, it's tempting to group related feature flags under a single parent flag to coordinate complex releases. The idea is simple: toggle one parent flag to enable or disable multiple child flags together. The parent can also serve as a global kill switch.

While this might work in theory, in practice it adds significant complexity. Now, enabling or disabling a feature isn't just about a single flag—you have to account for both the parent and the child. It becomes easy to misconfigure rollouts or cause unintended behavior in production.

Things get even trickier when both parent and child flags have their own targeting rules. For example, if both are set to a 50% rollout, are you exposing the feature to 50% or 25% of users? The answer depends on how rollouts are calculated—which can be confusing and inconsistent.

Our advice: Keep it simple. If you use parent-child structures, avoid overlapping rollout rules, and document the hierarchy clearly. Better yet, try to design flags so that they can be managed independently.

### Using feature flags to manage configuration

Both feature flags and configuration settings control an application's behavior. However, it's crucial to distinguish between feature flagging systems and configuration management systems and use each for its intended purpose.

Feature flags are temporary and dynamic. They give you [runtime control](./feature-flag-best-practices#1-enable-runtime-control) to enable or disable functionality in a live environment-perfect for things like [short-lived experiments](./feature-flag-best-practices#3-make-flags-short-lived), such as A/B testing or gradual rollouts.

Configurations, on the other hand, are usually static and long-lived. They often contain sensitive data like API keys or access credentials, which need to be encrypted and carefully managed. Using feature flags for configuration can create security vulnerabilities and operational issues. Most flag systems don't encrypt values the way configuration management tools do.

A good rule of thumb is that if the data is static (you don't expect it to change without application restart), needs encryption, or contains PII (personally identifiable information), manage it through a proper configuration system—not a feature flag.

<table>
  <thead>
    <tr>
      <th>Configuration system</th>
      <th>Feature flag system</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Is: Long-lived, static during runtime</td>
      <td>Is: Short-lived, changes during runtime</td>
    </tr>
    <tr>
      <td>
        Update with config systems:
        <ul>
          <li>Database or server credentials</li>
          <li>Server port</li>
          <li>CORS headers</li>
          <li>API base URL</li>
          <li>SSO setup</li>
        </ul>
      </td>
      <td>
        Update with feature flags:
        <ul>
          <li>Dark mode/light mode</li>
          <li>Stable / Beta feature</li>
          <li>New or old algorithm</li>
          <li>A/B test</li>`
        </ul>`
      </td>
    </tr>
  </tbody>
</table>

### Resuing feature flag names

Feature flag names need to be [globally unique](https://docs.getunleash.io/topics/feature-flags/unique-names). In an ideal world, all flag references would be removed from the codebase as soon as a flag is archived—but in reality, that rarely happens. Using unique names helps protect new features from accidentally linking to old, unused flags that could unintentionally re-enable outdated behavior.

To avoid this risk, enforce a [naming pattern](https://docs.getunleash.io/reference/feature-toggles#set-a-naming-pattern) at flag creation.

### Using large targeting lists

When implementing feature flags, it's crucial to aim for the quickest evaluation times possible. To achieve this, avoid relying on large inclusion lists—like thousands of specific user IDs—which can slow things down and become difficult to maintain.

Instead, focus on the underlying traits that qualify users for a feature. For example, rather than building a large list of beta testers, use a user attribute that can be managed in an external system.
You can then configure your feature flag system to recognize the attributes that indicate that the user is part of the beta testing group.

This approach helps with:
- Maintainability: Adding a new user to the beta group is as simple as updating their group membership, without needing to edit the flag configuration.
- Memory usage: Storing a simple attribute is much more efficient than holding a list of thousands of user IDs in memory.
- Compliance: Restricting personal data to only the systems that need it makes it easier to [stay compliant](./using-unleash/compliance/compliance-overview).


### Defining business logic using feature flags

In our experience, since feature flags reduce the friction of releasing software, teams who adopt feature flags tend to use them more and more. This is a good thing as long as archived flags are removed from the code base keeping tech debt down. You should resist, however, the temptation to codify core business logic inside feature flags, the same way you should [resist wrapping application configuration in feature flags](#12-dont-use-flags-to-manage-configuration).

Here is a good rule of thumb: Experiment with business logic using feature flags. But once you have established the business logic, codify it in code that lives outside of a flag.

For example, if you want to determine whether premium users of your product will use a certain new feature, you can wrap it in a flag and measure the result. Once you have determined that premium users do use the feature, and that all premium users should have access to it, however, you should remove the flag and add the feature to your entitlement service.

If feature flags are so great, why shouldn’t you use them for business logic? A few reasons:

#### Dependencing on third-party services

Coming from a feature flag vendor, it might surprise you that we do not advocate making core business logic dependent on a 3rd party feature flag service. If that flag service is down, then your app could potentially cease to function in the way designed. This applies to using 3rd party feature flag services, as well as home grown feature flags service.

#### Complexity and Maintainability

Embedding business logic within feature flags can make the codebase unnecessarily complex. Business rules can become scattered and entangled with feature flagging logic, making the code harder to read, understand, and maintain. When changes are needed, developers might have to navigate through a labyrinth of feature flags to find and update the relevant logic, increasing the risk of introducing bugs.

#### Performance Implications

Feature flags are typically designed to be checked frequently and quickly, with minimal performance overhead. However, when feature flags are used to control business logic, [they may involve more complex evaluations and data fetching, which can degrade application performance](#14-avoid-giant-feature-flag-targeting-lists). This is particularly problematic for high-traffic applications where performance is critical.

#### Security Risks

Business logic often involves access controls and entitlements. Using feature flags to manage these aspects can expose security vulnerabilities if not handled correctly. Feature flags might be toggled accidentally or maliciously, leading to unauthorized access or exposure of sensitive data.

## Organize your team and internal processes to support feature flags

Before you add your first feature flag, you need to think about how organizational structure and processes that live outside of code will affect your feature flag deployments.

### Align feature flags with organizational and application desig

> Any organization that designs a system will produce a design whose structure is a copy of the organization's communication structure.
>
> – Melvin Conway

![Feature flag organization methods](/img/feature-flag-organization-methods.svg)

There is no getting around [Conway’s law](https://martinfowler.com/bliki/ConwaysLaw.html). Applications tend to resemble the organizations that create them, and your feature flag system is no exception. Rather than fighting this law, acknowledge and embrace it, and pick a way to organize your feature flags that reflects your organization.

A typical Fortune 500 company typically has thousands of software developers. Organizing your feature flag system based on “applications” when your company is organized based on business units or products will lead to a poor experience and additional complexities in managing flag permissions.

Users should be shown information about any flags related to their work, whether on a team, an application, a product, or a project basis. This includes inspecting the flag’s configuration and tracking updates to the flag.

Achieve this by grouping related flags together based on the most appropriate level of abstraction. If you work on static teams that see a feature through from start to finish, group flags by team. If you form project-based teams, group flags by project.

Taken to the extreme, you might be tempted to put all flags into one giant group. Avoid that temptation because it will create permission complexities and information overload.

In an organization that actively uses feature flags, there will invariably be a large number of flags and an even larger number of changes made to those flags. This can quickly become overwhelming and a user may end up losing track of updates that are important to them.

Removing information and updates you don’t care about makes the things you care about stand out that much more.

**Example**: Do all members of Team A need updates on Project X, even if only one member of Team A is working on it? If so, include all team members in Project X’s group. Otherwise, only include the member who works on project X.

### Make flags searchable globally

Modern applications are composed of multiple services with many complex dependencies. While you should try to organize your flags based on high-level abstractions such as applications, teams, or business units, many services cut across these artificial organizing principles.

Just because a user might need to interact with a flag does not mean you should display it by default when it is outside your main organizational parameters. However, all flags should be easily searchable. When a user finds one, they should be able to inspect its configuration and ownership so that they might request additional permissions or [submit change requests for approval](#6-implement-flag-approval-workflows-early).

This is why feature flag systems should be [open by default](./feature-flag-best-practices#5-choose-open-by-default). There are valid use cases for excluding flags from global search. For example, a public company in the middle of an acquisition where exposing flags related to the website or app changes might breach regulatory guidelines. Your feature flag system should accommodate these private projects; however, they should be the exception, not the rule.

### Design for flag permissions to change over time

The owner or maintainer of a flag may change over time as the feature it controls [evolves across its lifecycle](#10-leverage-flag-lifecycles-to-optimize-your-development).

For instance, when a developer starts working on a feature, they’ll place it behind a flag so that they can merge back into the main branch early and often (a development style known as [trunk-based development](https://www.getunleash.io/blog/how-to-implement-trunk-based-development-a-practical-guide#What%20is%20trunk-based%20development)) without affecting the product. At this point, the flag exists to hide unfinished code and should be owned and managed by the developer.

When the feature is ready to be rolled out, the flag’s purpose will change. Its purpose is no longer to hide unfinished code but rather to _expose_ new functionality. This can be done in several ways and will vary from feature to feature.

If the feature is a simple improvement, the change can likely be incrementally rolled out while keeping an eye out for any signs that the feature is misbehaving. This can be managed entirely by the developer.

However, if the feature rollout has certain requirements, it’s quite likely that the developer doesn’t have the entire context that they need. As such, the ownership is now shared between the developer and a product owner. In cases like this, the developer may be in charge of the main switch, enabling or disabling the feature so that they can turn it off if something goes wrong. However, the product owner might decide what targeting strategies to use, such as how many users to roll the feature out to.

This is also often the case for B2B companies where specific customers request certain functionality. A Customer Success Manager will often have better insight into to whom to roll out a new feature first.

To be clear, the developers should still be kept in the loop (after all, when was the last time your Customer Success Managers checked system logs?). However, the flags are now a shared responsibility, and other team members should be given the power and responsibility to make the changes they want to see.

Here are common examples that require updating flag permissions you should plan for:

-   Permissions are wrongly scoped. Someone was left out, or someone who should not have access does.
-   Requirements changed mid-project.
-   The project owner or team lead changed.
-   Teams are reorganized.

The flag lifecycle stage dictates changes in the owners.

### Get flag management permissions right. And audit everything

It is clear now that different teams will require access to flags across their lifecycle. However, not every user will need the same permissions for common flag management tasks.

Here is a partial list of things one or more users will want to do with a feature flag for which you need to configure permissions:

-   Create
-   Delete
-   Turn-on
-   Turn-off
-   Configure targeting
-   Change rollout
-   Read configuration
-   Update configuration

Let’s look at a simple example: a product manager working with the development team to test a new Beta feature.

The developer should most likely be able to turn the flag on and off. Should the product manager? That depends on your organization's culture and requirements. Your feature flag system should be able to deal with this permission complexity.

The same thing goes for editing targeting rules (i.e. who sees the version of the application controlled by the flag) and rollout strategies (i.e., what % of users are exposed to the feature). It is up to your organization how much the product owner can do independently. It might make sense for them to be able to update and edit targeting rules for a flag freely but not control the rollout itself. Or, they might be able to make the edits to targeting and rollout directly but need to submit a change request for their desired changes and have them reviewed by a manager or more technical stakeholder. These permissions are directly related to an organization's security and compliance policies and are important to get right.

Equally important is auditing all of these permissions and changes. As such, knowing where to find the flagging system’s audit log is essential. If there’s a slip-up, you can find out when and where it happened and use those findings to improve your processes. Should you require more approvals before going into production? Do you need to update targeting rules or user segments? In the case of a malicious actor, the audit log can help you identify the actor and the changes they made.

### Base flag permissions on global permissions

Your organization has already established some notions of groups. Leverage that for your feature flag system permissions.

These might be groups based on roles (such as developers, operations, marketing, etc.), or business units, or both.

These groups should be mirrored in your feature flag system to help you organize your users and access rights. Your system should be set up to sync with SSO providers to make this process as painless as possible.

Users who are added or removed from your main SSO directory should be added or removed (based on their role) from your feature flag system. Managing global permissions is complex. Only do it in one place.

### Implement flag approval workflows early

![Change request process](/img/change-request-flow.png)

Depending on the industry and legal framework you’re operating in, you’ll need varying approvals for a feature flag change to go into production. You may be able to just roll something out on a whim, or you might need to get it approved by specific stakeholders before releasing it. Your feature flag tool should help you do this, regardless of how much oversight you need.

**Require approvals where necessary**

When legal requirements say that a change must be peer-reviewed before being put into production (often referred to as the ‘[four-eyes principle](https://www.unido.org/overview-member-states-change-management-faq/what-four-eyes-principle)' or the ‘two-person rule’), it should be easy to do. You should be able to add all the changes you want to make to all the relevant flags and present them as a group, similar to making a pull request on GitHub.

It should be easy for the reviewers to see what changes would be made and what the configuration would look like after the change.

But this isn’t just useful for legal reasons. The process of submitting something for review is useful in and of itself.

Review flag changes before they take effect

Even if you don’t require anyone else's approval before making changes in production environments, there are still benefits to grouping your changes together and reviewing them before actually making them:

1. You can make multiple changes at the same time. If you have a set of changes across flags that should change in tandem, you can make sure they update at the same time, avoiding awkward in-between states.
2. You avoid making changes by mistake. If your cat walks across the keyboard, you can feel safe that they won’t accidentally expose your unfinished code to everyone.
3. You get to review the changes before they go out. You get the full overview of the changes you’re making. You can double-check that the changes will have the effect you want.

## Keeping cool while managing feature flags at scale

These best practices come from working with many of the largest organizations on the planet. We’ve learned that keeping cool while managing feature flags at scale requires careful planning, thoughtful organization, and adherence to several best practices. By aligning feature flags with organizational structure, making flags searchable, and managing permissions effectively, you can maintain a clean and efficient system that sets you up for success from the start. Instrumenting your code correctly and regularly paying down technical debt helps maintain performance and security. Finally, avoiding common pitfalls, such as using feature flags for business logic or configuration management, keeps your system robust and manageable.

Feature flags are a powerful tool for delivering software efficiently while maintaining security and compliance. For developers working in large organizations, that is the best of both worlds. By following the best practices outlined in this guide, you can harness the full potential of feature flags while avoiding the complexities and risks associated with their misuse.

Remember, the key to successful feature flag management at scale lies in clear processes, regular maintenance, and a commitment to best practices. With these in place, you can leverage feature flags to drive innovation and improve your software development lifecycle.

This guide was all about using feature flags at scale. For similar tips on building and scaling the feature flag system itself, see our [feature flag best practices guide](./feature-flag-best-practices).
